<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pineapple126.github.io/</id>
    <title>深海大菠萝盖饭</title>
    <updated>2020-04-10T15:23:38.539Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pineapple126.github.io/"/>
    <link rel="self" href="https://pineapple126.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://pineapple126.github.io/images/avatar.png</logo>
    <icon>https://pineapple126.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 深海大菠萝盖饭</rights>
    <entry>
        <title type="html"><![CDATA[从用户输入 URL 到页面渲染完毕，这中间发生了什么？]]></title>
        <id>https://pineapple126.github.io/post/cong-yong-hu-shu-ru-url-dao-ye-mian-xuan-ran-wan-bi-zhe-zhong-jian-fa-sheng-liao-shi-me/</id>
        <link href="https://pineapple126.github.io/post/cong-yong-hu-shu-ru-url-dao-ye-mian-xuan-ran-wan-bi-zhe-zhong-jian-fa-sheng-liao-shi-me/">
        </link>
        <updated>2020-04-07T07:23:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="从输入-url-到页面展示中间发生了什么">从输入 URL 到页面展示，中间发生了什么？</h2>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1586162608489.png" alt="从输入 URL 到页面展示完整流程示意图" loading="lazy"></figure>
<p><strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</strong></p>
<h2 id="1-用户输入">1. 用户输入</h2>
<p>当用户在地址栏里输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合为完整的 URL。</li>
</ul>
<p>默认情况下，当用户输入关键字并键入回车之后，当前页面将会被替换为新的页面，不过浏览器提供了一个 <code>beforeunload</code> 事件，在这个流程继续之前，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开该页面，因此用户可以用通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再进行任何后续工作。</p>
<h2 id="2-url-请求过程">2. URL 请求过程</h2>
<p>页面资源请求过程，浏览器进程通过 进程间通讯（IPC）把 URL 请求发送给 网络进程，网络进程接收到 URL 请求后，会发起真正的 URL 请求流程。</p>
<p>首先，网络进程会在本地缓存中检查是否缓存了请求资源。如果有缓存资源，则直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求第一步是进行 DNS 解析（将域名转换为 IP 地址），以获取请求服务器的 IP 地址。如果请求的协议是 HTTPS，那么还要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头、响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头中的数据，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重新开始。</p>
<p>注意：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p><strong><code>Context-Type</code> 是 HTTP 头中的一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型。</strong>，然后浏览器会根据 <code>Context-Type</code> 字段的值来决定如何显示响应体的内容。</p>
<p>不同 <code>Context-Type</code> 的后续处理流程也截然不同。如果 <code>Context-Type</code> 字段的值被浏览器判断为<strong>下载类型</strong>，<strong>那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航栏流程就此结束</strong>。但如果是 <strong>HTML</strong>，<strong>那么浏览器则会继续进行导航流程。</strong></p>
<h2 id="3-准备渲染进程">3. 准备渲染进程</h2>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。**官方把这个默认策略叫做 process-per-site-instance。</p>
<p>总结一下：</p>
<ul>
<li>通常情况下，打开的新页面都会使用单独的渲染进程；</li>
<li>如果从 A 页面打开 B 页面，且 A 与 B 都属于<strong>同一站点</strong>的话，B 页面会复用 A 页面的渲染进程。</li>
</ul>
<h2 id="4-提交文档">4. 提交文档</h2>
<p>所谓提交文档，就是指浏览器将网络进程接收到的 HTML 数据提交给渲染进程，具体流程如下：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括安全状态、地址 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>至此，一个完整的导航流程结束，紧接着是渲染阶段</p>
<h2 id="5-渲染阶段">5. 渲染阶段</h2>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<p>渲染模块在执行过程中会被划分为许多子阶段。我们把这样一个处理流程叫做<strong>渲染流水线</strong>，其大致流程如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1586244905056.png" alt="渲染流水线示意图" loading="lazy"></figure>
<p>按照渲染的时间顺序，流水线可分为如下几个阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。在每个阶段中，我们需要注意以下三点内容:</p>
<ul>
<li>每个子阶段都有其<strong>输入内容</strong>；</li>
<li>每个子阶段都有其<strong>处理过程</strong>；</li>
<li>每个子阶段都会生成<strong>输出内容</strong>。</li>
</ul>
<h3 id="构建-dom-树">构建 DOM 树</h3>
<p><strong>由于浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</strong></p>
<p>DOM 树的构建过程可以参考下图：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1586245031193.png" alt="DOM 树构建过程示意图" loading="lazy"></figure>
<p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个简单的 HTML 文件，然后经由 HTML 解析器解析，最终输入树状结构的 DOM。</p>
<h3 id="样式计算recalculate-style">样式计算（Recalculate Style）</h3>
<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大致可分为三个步骤：</p>
<p><strong>1. 把 CSS 转换为浏览器可以理解的结构。</strong></p>
<p>CSS 样式来源主要有三种：</p>
<ul>
<li>通过 link 引入的外部 CSS 文件</li>
<li><code>&lt;style&gt;</code> 标记内的样式</li>
<li>元素 style 属性内嵌的 CSS</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</strong>（渲染引擎会将获取的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能）</p>
<p><strong>2. 转换样式表中的属性值，使其标准化</strong></p>
<p>我们已经将 CSS 文本转换为浏览器可以理解的结构了，<strong>接下来我们要对其进行属性值的标准化操作</strong>。</p>
<p>那什么是标准化呢？假如我们有以下一段 CSS 文本：</p>
<pre><code class="language-css">body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
</code></pre>
<p>可以看到文本内有很多属性值，如 2em、blue、bold 等，<strong>这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎所能够理解的、标准化的计算值</strong>，这个过程就是属性值的标准化。</p>
<p>标准化后的属性值如下图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1586246231460.png" alt="标准化属性值" loading="lazy"></figure>
<p><strong>3. 计算出 DOM 树中每个节点的具体样式</strong></p>
<p>现在样式的属性值已经被标准化了，接下来就要计算 DOM 树中每个节点的样式属性了。而计算过程涉及到 <strong>CSS 的继承规则</strong>和<strong>层叠规则</strong>两部分。</p>
<p>首先是 CSS 的继承规则。<strong>CSS 继承就是每个 DOM 节点都包含父节点的样式。</strong></p>
<p>我们结合下面的实例，看看一张样式表如何应用到 DOM 节点上：</p>
<pre><code class="language-css">body { font-size: 20px }
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
</code></pre>
<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1586246783746.png" alt="计算后 DOM 的样式" loading="lazy"></figure>
<p>从图中可以看出，所有的子节点都继承了父节点的样式。</p>
<p>样式计算的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称是“层叠样式表”正是强调了这一点。</strong></p>
<h3 id="布局阶段">布局阶段</h3>
<p>我们现在已经拥有了 DOM 树和 DOM 树中元素的样式，接下来<strong>我们需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程称为布局。</strong></p>
<p>Chrome 在布局阶段需要完成两个步骤：创建布局树和布局计算。</p>
<p><strong>1. 创建布局树</strong></p>
<p><strong>在 DOM 树显示之前，我们还需要额外地构建一棵只包含可见元素布局树。</strong></p>
<p>我们可以结合下图来看看布局树的构造过程：</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1586329485462.png" alt="布局树构建流程示意图" loading="lazy"></figure>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含在布局树中。</p>
<p>为了构建布局树，浏览器大致完成了下面这些工作：</p>
<ul>
<li>遍历 DOM 树中的节点，并把这些节点加到布局树中；</li>
<li>不可见的节点暂时会被忽略掉。</li>
</ul>
<p><strong>2. 布局计算</strong></p>
<p>现在我们拥有一棵完整的布局树，我们要做的是计算布局树中节点的坐标位置。</p>
<p>在执行布局操作时，会把布局计算的结果重新写回到布局树中，所以布局树既是输入内容，也是输出内容。</p>
<h3 id="分层">分层</h3>
<p>因为页面中有很多复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（Layer Tree）。</p>
<p>通过 Chrome 的“开发者工具”中的“Layers”标签，就可以可视化页面的分层情况。</p>
<p>渲染引擎给页面分了许多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。也即**浏览器的页面实际上被分为了许多图层，这些图层叠加后合成了最终的页面。**我们可以通过下图看看图层和布局树节点之间的关系：</p>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1586331052930.png" alt="布局树和图层树关系示意图" loading="lazy"></figure>
<p>通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。**不管如何，最终每个节点都会直接或间接地从属于一个图层。</p>
<p>通常满足下面两点中任意一点的元素就可以被渲染引擎提升为单独的一个图层：</p>
<ul>
<li><strong>拥有层叠上下文属性的元素会被提升为单独的一层。</strong>（我们假定用户正面向视窗或者网页，而 HTML 元素沿着相对于用户的一条虚拟的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想）</li>
<li><strong>需要裁剪（clip）的地方也会被创建为图层。</strong>（当元素内容超出元素限定范围时，就会发生裁剪。出现裁剪时，渲染引擎会为元素内容单独创建一个图层）</li>
</ul>
<h3 id="图层绘制">图层绘制</h3>
<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。</p>
<p>渲染引擎实现图层的绘制时，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1586506394268.png" alt="绘制列表" loading="lazy"></figure>
<p>绘制一个元素通常需要好几条绘制指令，因此在图层绘制阶段，输出的内容就是这些待绘制列表。</p>
<h3 id="栅格化raster操作">栅格化（raster）操作</h3>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程。</p>
<p>通过<strong>视口（viewport）</strong>（用户可以看到页面的部分）用户只能看到页面的很小一部分，如果要绘制出所有图层内容的话，就会产生很大的开销。</p>
<p>基于这个原因，<strong>合成线程将图层划分为图块（tile）</strong>（图块的大小通常为 256×256 或 512×512），**然后合成线程会按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**而图块是栅格化的最小单位。渲染进程维护了一个栅格化的线程池，所有图块的栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1586507976232.png" alt="合成线程提交图块给栅格化线程池" loading="lazy"></figure>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫做快速栅格化，或者 GPU 栅格化，生成的位图保存在 GPU 内存中。</p>
<h3 id="合成与显示">合成与显示</h3>
<p>一旦所有的图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程中有一个叫 viz 的组件，用于接收来自合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后将内存显示在屏幕上。</p>
<h3 id="渲染总结">渲染总结：</h3>
<p>完整的渲染流水线示意图：</p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1586506955163.png" alt="" loading="lazy"></figure>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成<strong>图层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分为<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换为位图。</li>
<li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程。</li>
<li>浏览器进程根绝 DrawQuad 消息<strong>生成页面</strong>，并显示到显示器上。</li>
</ol>
<h3 id="相关概念">相关概念：</h3>
<p><strong>1. 更新了元素的几何位置（重排）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1586508485468.png" alt="重排" loading="lazy"></figure>
<p>如果我们通过 JS 或者 CSS 修改元素的几何位置属性，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫做<strong>重排</strong>。<strong>重排需要更新完整的渲染流水线，所以开销也是最大的。</strong></p>
<p><strong>2. 更新了元素的绘制属性（重绘）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1586508688667.png" alt="重绘" loading="lazy"></figure>
<p>如果我们修改了元素的绘制属性，那么布局阶段将不会被执行，而是直接进入到绘制阶段，然后执行之后的一系列子阶段，这个过程就叫做<strong>重绘</strong>。相较于重排，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</strong></p>
<p><strong>3. 直接合成阶段</strong></p>
<p>如果我们更改一个既不要布局也不要绘制的属性，会发生什么？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称作<strong>合成</strong>。参考下图：</p>
<figure data-type="image" tabindex="13"><img src="https://pineapple126.github.io//post-images/1586508967109.png" alt="合成" loading="lazy"></figure>
<p><strong>相对于重排和重绘，合成能大大提升绘制效率。</strong></p>
<h2 id="总结从用户输入-url到最终的页面展示到底发生了什么">总结：从用户输入 URL，到最终的页面展示到底发生了什么？</h2>
<ol>
<li>用户输入 URL 并按下回车，浏览器进程检查 URL，组装协议，构成完整的 URL</li>
<li>浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为还没有获得新页面的响应数据</li>
<li>浏览器进程通过进程间通信（IPC）把 URL 请求发送给网络进程</li>
<li>网络进程接收到 URL 请求后检查本地缓存是否含有该请求资源，如果有则直接将该资源返回给浏览器进程（状态码 200）</li>
<li>如果没有，网络进程向 Web 服务器发起 HTTP 请求（网络请求），请求流程如下:<br>
5.1 进行 DNS 解析，获取服务器的 IP 地址：如果缓存过当前域名信息，就会直接返回缓存信息；<br>
5.2 根据 IP 地址和服务器建立 TCP 连接（三次握手）；<br>
5.3 如果是 HTTPS 请求则还需要建立 TLS 连接；<br>
5.4 浏览器端构建并发送请求头信息；<br>
5.5 服务器端响应后，网络进程接收响应头和响应信息，并解析响应内容；<br>
5.6 数据传输完成后，断开 TCP 连接（四次挥手）。如果浏览器端或服务器端在 HTTP 头部加上 <code>Connection: Keep-Alive</code> 字段，TCP 连接将一直保持下去。保持 TCP 连接可以节省建立连接所需的事件，提高资源加载速度。</li>
<li>网络进程响应流程：<br>
6.1 检查状态码，如果是 301/302，则需要重定向，从响应信息中 <code>Location</code> 字段获取地址，重新发起 URL 请求；<br>
6.2 如果不是重定向，首先服务器会根据请求头中的 <code>if-None-Match</code> 字段的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以继续使用，就不用再返回数据了。<br>
6.3 其他状态码响应处理：<br>
检查响应类型 <code>Context-Type</code> 字段：如果是 字节流 类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染阶段；如果是 text/html 类型，则通知浏览器进程，准备进行渲染阶段。</li>
<li>准备渲染阶段：<br>
7.1 浏览器进程获取到来自网络进程的通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是同一个站点（根域名和协议相同就被认为同一站点）<br>
7.2 如果相同，则新页面复用页面 A 的渲染进程；如果不同，则浏览器为页面 B 创建一个新的渲染进程</li>
<li>传输数据、更新状态<br>
8.1 渲染进程准备好后，浏览器进程向渲染进程发起“提交文档”的消息，渲染进程接收到消息后，和网络进程建立数据传输的“管道”<br>
8.2 渲染进程接受完数据后，向浏览器进程发送“确认提交”的消息<br>
8.3 浏览器进程接收到“确认提交”的消息后，更新浏览器界面的状态：包括安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面，此时 Web 页面是空白页。</li>
<li>渲染进程渲染页面：<br>
9.1 构建 DOM 树<br>
9.2 样式计算（构建 CSSOM 树）<br>
9.3 页面布局（构建布局树）<br>
9.4 分层（构建图层树）<br>
9.5 图层绘制（绘制列表）<br>
9.6 分块（将图层划分为图块）<br>
9.7 栅格化（栅格化，是指将图块转换为位图）<br>
9.8 合成和显示</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 23 合并K个排序链表（分治）]]></title>
        <id>https://pineapple126.github.io/post/leetcode-23-mergeKLists/</id>
        <link href="https://pineapple126.github.io/post/leetcode-23-mergeKLists/">
        </link>
        <updated>2020-03-23T11:16:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>问题描述：</strong></p>
<p>合并 k 个排序链表，返回合并后的排序链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<p><strong>基本思路：</strong></p>
<p>对于合并两个排序链表的问题，我们可以轻松解决。只要创建一个新的哑巴节点，再选择两个链表头节点较小的一个与哑巴节点链接起来，循环该操作，直至合并完成。</p>
<p>那么对于合并K个排序链表，我们可以运用分治的思想，不断地将数组不断拆分。（我们用数组 lists 存储着这些链表）</p>
<p>这里借用官方题解的一张图片：</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1584964378982.png" alt="分治演示" loading="lazy"></figure>
<p>那么拆分过程中有以下情形：</p>
<ul>
<li>
<p><code>lists.length === 0</code>        数组 lists 中已无链表，则返回一个空节点；</p>
</li>
<li>
<p><code>lists.length === 1</code>        数组 lists 中仅剩一个链表，因此直接返回该链表；</p>
</li>
<li>
<p><code>lists.length === 2</code>        数组 lists 中有两个链表，我们执行合并操作；</p>
</li>
<li>
<p><code>other</code>         数组 lists 中的链表数过多，需要继续拆分。</p>
</li>
<li>
<p>时间复杂度：O(nlogK)</p>
<ul>
<li>k 为链表总数</li>
<li>n 为合并两个链表所用的时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    // 如果列表中的 链表 为空 则直接返回
    if (lists.length === 0) return null;
    // 如果列表中的 链表 只剩一个直接返回
    if (lists.length === 1) return lists[0];
    // 如果列表中的 链表 有两个 则合并两个链表
    if (lists.length === 2) return mergeTwoLists(lists[0], lists[1]);
    // 否则继续拆分
    let mid = lists.length &gt;&gt; 1;
    let left = lists.slice(0, mid),
        right = lists.slice(mid);
    return mergeTwoLists(mergeKLists(left), mergeKLists(right));
};

function mergeTwoLists(list1, list2) {
    let ans = new ListNode(-1),
        preAns = ans;
    while(list1 &amp;&amp; list2) {
        if (list1.val &lt; list2.val) {
            preAns.next = list1;
            list1 = list1.next;
        } else {
            preAns.next = list2;
            list2 = list2.next;
        }
        preAns = preAns.next;
    }
    preAns.next = list1 ? list1 : list2;
    return ans.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件委托]]></title>
        <id>https://pineapple126.github.io/post/event-delegation/</id>
        <link href="https://pineapple126.github.io/post/event-delegation/">
        </link>
        <updated>2020-03-21T10:08:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p>事件委托就是通过事件冒泡的机制，利用父级元素去触发子级元素的事件。</p>
<p>使用事件委托可以减少内存开销，提高性能。</p>
<h2 id="示例">示例</h2>
<p>例如，我们要对一堆 li 元素绑定相同的事件，如果将事件都绑定到 li 元素上，会增加内存开销、降低性能。而我们可以将事件侦听器绑定到这些 li 元素的父级元素 ul 或 ol 元素上，这样子我们仅需绑定一次事件。当我们需要触发事件时，会通过冒泡机制传递给父级元素触发事件。</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    /* 事件委托的核心原理：给父节点添加侦听器，
        利用事件冒泡机制影响每一个子节点 */
        var ul = document.querySelector(&quot;ul&quot;);
        ul.addEventListener(&quot;click&quot;, function(e) {
            //  e.target 可以得到我们点击的对象
            e.target.style.backgroundColor = &quot;red&quot;;
        });
&lt;/script&gt;
</code></pre>
<p>在这个示例中：</p>
<ul>
<li>我们只操作了一次 DOM，提高了程序的性能</li>
<li>动态创建的子元素，也将拥有事件</li>
</ul>
<h2 id="总结">总结</h2>
<p>综上所述，当我们需要给一组元素添加相同事件时，我们可以通过事件委托的方式将事件直接添加给父级元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的三序遍历]]></title>
        <id>https://pineapple126.github.io/post/traversal-binary-tree/</id>
        <link href="https://pineapple126.github.io/post/traversal-binary-tree/">
        </link>
        <updated>2020-03-20T02:48:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="先序遍历preordertraversal">先序遍历（preorderTraversal）</h2>
<p>节点遍历顺序：根 -&gt; 左 -&gt; 右</p>
<h3 id="递归方式">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    return [
        root.val,
        ...preorderTraversal(root.left),
        ...preorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="迭代方式">迭代方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            res.push(curr.val);
            curr = curr.left;
        }
        curr = stack.pop();
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="中序遍历inordertraversal">中序遍历（inorderTraversal）</h2>
<p>节点遍历顺序：左 -&gt; 根 -&gt; 右</p>
<h2 id="递归方式-2">递归方式</h2>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    return [
        ...inorderTraversal(root.left),
        root.val,
        ...inorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="迭代方式-2">迭代方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        res.push(curr.val);
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="后序遍历postordertraversal">后序遍历（postorderTraversal)</h2>
<p>节点遍历顺序：左 -&gt; 右 -&gt; 根</p>
<h3 id="递归方式-3">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    return [
        ...postorderTraversal(root.left),
        ...postorderTraversal(root.right),
        root.val
    ];
}
</code></pre>
<h3 id="迭代方式-3">迭代方式</h3>
<p><strong>方式一：正序解</strong></p>
<p>实现（1）：如果某一结点的子节点已被遍历过，则将其子节点指向 null。（整个过程就像是给一棵树不断地修剪叶子一样）</p>
<p>基本思路：</p>
<ol>
<li>先遍历左节点，当遍历到叶子节点时，记录其值；</li>
<li>返回至该叶子节点的上一层，并让该叶子节点指向 null；</li>
<li>再遍历右节点，当遍历到叶子节点时，记录值；</li>
<li>再次返回上一层节点，顺便让该叶子节点指向 null。</li>
</ol>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        if (curr.left) {
            stack.push(curr);
            curr = curr.left;
        } else if (curr.right) {
            stack.push(curr);
            curr = curr.right;
        } else {
            res.push(curr.val);
            curr = stack.pop();
            if (curr &amp;&amp; curr.left) curr.left = null;
            else if (curr &amp;&amp; curr.right) curr.right = null;
        }
    }
    return res;
}
</code></pre>
<p>实现（2）：添加标志位 flag，当某一节点的左右子节点的值都已被记录时 flag 为 true，否则为 false。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while (curr || stack.length &gt; 0) {
        while(curr) {
            stack.push([curr, false]);
            curr = curr.left;
        }
        let [node, flag] = stack.pop();
        if (!flag) {
            stack.push([node, true]);
            curr = node.right;
        } else {
            res.push(node.val);
        }
    }
    return res;
}
</code></pre>
<p><strong>方式二：倒序解</strong></p>
<p>思路：该方式类似于先序遍历，只是遍历顺序为 根 -&gt; 右 -&gt; 左。而记录值是从数组的头部插入。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length) {
        while(curr) {
            stack.push(curr);
            res.unshift(curr.val);
            curr = curr.right;
        }
        curr = stack.pop();
        curr = curr.left;
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://pineapple126.github.io/post/sort-algorithm/</id>
        <link href="https://pineapple126.github.io/post/sort-algorithm/">
        </link>
        <updated>2020-03-19T03:05:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2>
<p>基本思想：采用分治的思想，选取一个基准，将待排序数组分为两个小、大数组，不断重复这个过程直至数组有序。</p>
<p>基本步骤：</p>
<ol>
<li>选取基准（pivot）；</li>
<li>根据基准将待排序数组分割为两个数组；</li>
<li>重复以上步骤，直至数组有序。</li>
</ol>
<pre><code class="language-javascript">function quickSort(arr) {
    if (arr.length &lt; 2) return arr;
    let pivot = arr[0];
    let left = [],
        right = [];
    for(let i  = 1; i &lt; arr.length; i++) {
        if (arr[i] &lt; pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot, quickSort(right));
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<p>基本思想：将数组的第一位视为一个有序数组，将剩下的待排序数组逐个插入到已排序数组中。</p>
<pre><code class="language-javascript">function insertSort(arr) {
    for(let i = 1; i &lt; arr.length; i++) {
        let tmp = arr[i],
            j = i;
        for( ; j &gt; 0; j--) {
            if (tmp &gt; arr[j-1]) {
                break;
            }
            arr[j] = arr[j-1];
        }
        arr[j] = tmp;
    }
    return arr;
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>基本思想：采取分治的思想，将两个有序数组合并为一个有序数组。</p>
<pre><code class="language-javascript">function mergeSort(arr) {
    if (arr.length &lt; 2) return arr;
    let res = [];
    let mid = arr.length &gt;&gt; 1;
    let left = mergeSort(arr.slice(0, mid)),
        right = mergeSort(arr.slice(mid));
    while(left.length &amp;&amp; right.length) {
        if (left[0] &lt; right[0]) {
            res.push(left.shift());
        } else {
            res.push(right.shift());
        }
    }
    return res.concat(left, right);
}
</code></pre>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-javascript">function bubbleSort(arr) {
    for(let i = 0; i &lt; arr.length; i++) {
        for(let j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j] &gt; arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
            }
        }
    }
    return arr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型判断]]></title>
        <id>https://pineapple126.github.io/post/type-judgement/</id>
        <link href="https://pineapple126.github.io/post/type-judgement/">
        </link>
        <updated>2020-03-13T08:47:22.000Z</updated>
        <content type="html"><![CDATA[<p>JavaScript 中有 8 种数据类型，又分为基本数据类型和引用数据类型。</p>
<ul>
<li>基本数据类型：Null、Undefined、Number、Boolean、String、Symbol、BigInt</li>
<li>引用数据类新：Object</li>
</ul>
<p>判断数据类型的方法有以下几种：<code>typeof</code> 运算符、<code>instanceof</code> 运算符、<code>constructor</code> 方法和 <code>Object.prototype.toString.call()</code> 方法</p>
<p>我们先创建这些数据类型的变量：</p>
<pre><code class="language-javascript">let nul = null,
    und= undefined,
    num = 1,
    bool = true,
    str = &quot;string&quot;,
    sym = Symbol(),
    bigint = 1n,
    obj = {name: &quot;zs&quot;},
    arr = [1, 2, 3],
    fn = function() { console.log(&quot;function&quot;); };
</code></pre>
<h2 id="typeof">typeof</h2>
<p><code>typeof</code> 可以识别出数据类型，但是不能识别 null 和 array，会将它们归为 Object 类型。判断示例如下：</p>
<pre><code class="language-javascript">console.log(typeof nul);            //  object
console.log(typeof und);            //  undefined
console.log(typeof num);            //  number
console.log(typeof bool);           //  boolean
console.log(typeof str);            //  string
console.log(typeof sym);            //  symbol
console.log(typeof bigint);         //  bigint
console.log(typeof obj);            //  object
console.log(typeof arr);            //  object
console.log(typeof fn);         //  function
</code></pre>
<h2 id="instanceof">instanceof</h2>
<p><code>instanceof</code> 不能识别基本数据类型，但是可以识别出 Array、Function 与 Object。同时，对于 new 声明的类型，还可以检测出多层继承关系。</p>
<pre><code class="language-javascript">console.log(nul instanceof Object);         //  false
console.log(und instanceof Object);         //  false
console.log(num instanceof Number);         //  false
console.log(bool instanceof Boolean);           //  false
console.log(str instanceof String);         //  false
console.log(sym instanceof Symbol);         //  false
console.log(bigint instanceof BigInt);          //  false
console.log(obj instanceof Object);         //  true
console.log(arr instanceof Array);          //  true
console.log(fn instanceof Function);            //  true
</code></pre>
<h2 id="constructor">constructor</h2>
<p>null、undefined 没有 constructor 方法，因此 constructor 不能用于判断 null 和 undefined。并且，constructor 是不安全的，因此 constructor 的指向是可以被改变的。</p>
<pre><code class="language-javascript">console.log(num.constructor === Number);            //  true
console.log(bool.constructor === Boolean);          //  true
console.log(str.constructor === String);            //  true
console.log(sym.constructor === Symbol);            //  true
console.log(bigint.constructor === BigInt);         //  true
console.log(obj.constructor === Object);            //  true
console.log(arr.constructor === Array);         //  true
console.log(fn.constructor === Function);           //  true
</code></pre>
<h2 id="objectprototypetostringcall">Object.prototype.toString.call()</h2>
<p>该方法可以相对较全的判断 JavaScript 的数据类型。</p>
<pre><code class="language-javascript">console.log(Object.prototype.toString.call(nul));           //  [object Null]
console.log(Object.prototype.toString.call(und));           //  [object Undefined]
console.log(Object.prototype.toString.call(num));           //  [object Number]
console.log(Object.prototype.toString.call(bool));          //  [object Boolean]
console.log(Object.prototype.toString.call(str));           //  [object String]
console.log(Object.prototype.toString.call(sym));           //  [object Symbol]
console.log(Object.prototype.toString.call(bigint));            //  [object BigInt]
console.log(Object.prototype.toString.call(obj));           //  [object Object]
console.log(Object.prototype.toString.call(arr));           //  [object Array]
console.log(Object.prototype.toString.call(fn));            //  [object Function]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map集合（2）]]></title>
        <id>https://pineapple126.github.io/post/map/</id>
        <link href="https://pineapple126.github.io/post/map/">
        </link>
        <updated>2020-03-12T03:16:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-中的-map-集合">ES6 中的 Map 集合</h2>
<p>ES6 中的 Map 类型是一种<strong>储存着许多键值对</strong>的<strong>有序列表</strong>，其中的键名和对应的值支持所有的数据类型。键名的等价性判断是通过调用 <code>Object.is()</code> 方法实现的，所以数字 5 与字符串 &quot;5&quot; 会被判定为两种类型，可以分别作为独立的两个键出现在程序中。</p>
<h3 id="map-集合创建方法以及支持的方法和属性">Map 集合创建方法以及支持的方法和属性</h3>
<p>创建方法：调用 <code>new Map()</code> 即可创建一个 Map 集合。</p>
<p>支持方法：</p>
<ul>
<li><code>set(key, value)</code> 方法：向 Map 集合中添加新的元素；</li>
<li><code>get(key)</code> 方法：从 Map 集合中获取信息，若传入的键名不存在，则返回 undefined；</li>
<li><code>has(key)</code> 方法：检测指定的键名在 Map 集合中是否已经存在；</li>
<li><code>delete(key)</code> 方法：从 Map 集合中移除指定键名及其对应的值；</li>
<li><code>clear()</code> 方法：移除 Map 集合中所有的键值对；</li>
<li><code>size</code> 属性：获取当前集合中包含的键值对数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new Map();
map.set(&quot;name&quot;, &quot;Nicholas&quot;);
map.set(&quot;age&quot;, 25);

console.log(map.size);          //  2

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;

console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25

map.delete(&quot;name&quot;);
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.size);          //  1

map.clear();
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.has(&quot;age&quot;));            //  false
console.log(map.get(&quot;age&quot;));            //  undefined
console.log(map.size);          //  0
</code></pre>
<p>也可以向 Map 构造函数传入数组来初始化一个 Map 集合，数组中的每一个元素都是一个子数组，子数组包含一个键值对的键名与值两个元素。示例如下：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;
console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25
console.log(map.size);          //  2
</code></pre>
<h3 id="map-集合中的-foreach-方法">Map 集合中的 forEach() 方法</h3>
<p>Map集合的 <code>forEach()</code> 方法与 Set 集合和数组中的 <code>forEach()</code> 方法类似，回调函数都接受 3 个参数：</p>
<ul>
<li>Map 集合中下一次索引的值</li>
<li>值对应的键名</li>
<li>Map 集合本身</li>
</ul>
<p>这些回调参数与数组中的更相近，第一个参数是值，第二个参数是键名。请看这个示例：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

map.forEach(function (value, key, ownerMap) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerMap === map);
});
</code></pre>
<p>这段代码会输出以下内容：</p>
<pre><code class="language-javascript">name Nicholas
true
age 25
true
</code></pre>
<p>遍历过程中，会按照键值对插入 Map 集合的顺序将相应信息传入 <code>forEach()</code> 方法的回调函数，而在数组中，则会按照数值型索引值的顺序依次传入回调函数。</p>
<p><strong>注意</strong>：可以指定 <code>forEach()</code> 函数的第二个参数作为回调函数的 <code>this</code> 值。</p>
<h2 id="weak-map-集合">Weak Map 集合</h2>
<p>Weak Set 集合是弱引用的 Set 集合，相对应的，Weak Map 集合是弱引用的 Map 集合，也用于存储对象的弱引用。Weak Map 集合中的键名必须是一个对象。集合中保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的键值对。但是只有集合的键名遵从这个规则，键名对应的值如果是个对象，则保存的是对象的强引用，不会触发垃圾回收机制。</p>
<p>Weak Map 集合最大的用途是跟踪 Web 页面中的 DOM 元素，当 DOM 元素消失时，可以自动销毁集合中的相关对象。</p>
<h3 id="使用-weak-map-集合">使用 Weak Map 集合</h3>
<p>ES6 中的 Weak Map 类型是一种存储着许多键值对的无序列表，列表的键名必须是非 null 类型的对象，键名对应的值则可以是任意类型。</p>
<p>我们可以通过 WeakMap 构造函数来创建一个 Weak Map 集合。Weak Map 集合也支持以下方法：</p>
<ul>
<li><code>set()</code></li>
<li><code>get()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new WeakMap(),
    element = document.querySelector(&quot;.element&quot;);

map.set(element, &quot;Original&quot;);

console.log(map.has(element));          //  true
console.log(map.get(element));          //  &quot;Original&quot;

map.delete(element);
console.log(map.has(element));          //  false
console.log(map.get(element));          //  undefined
</code></pre>
<h2 id="小结">小结</h2>
<p>Set 集合是一种包含多个非重复值的有序列表，值与值之间的等价性是通过 <code>Object.is()</code> 方法来判断的，如果相同，则会自动过滤重复的值，所以可以用 Set 集合来过滤数组中的重复元素。</p>
<p>Weak Set 集合是一类特殊的 Set 集合，集合只支持存放对象的弱引用。由于内存管理非常复杂，Weak Set 集合不可以被检查，因此追踪成组的对象是该集合最好的使用方式。</p>
<p>Map 是多个键值对组成的有序集合，键名支持任意数据类型，与 Set 集合相似的是，Map 集合也是通过 <code>Object.is()</code> 方法来过滤重复值。</p>
<p>Weak Map 集合是一类特殊的 Map 集合，只支持对象类型的键名，集合中存放的键是对象的弱引用。Weak Map 集合可以为那些实际使用与生命周期管理分离的对象添加额外信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map 集合（1）]]></title>
        <id>https://pineapple126.github.io/post/set/</id>
        <link href="https://pineapple126.github.io/post/set/">
        </link>
        <updated>2020-03-09T11:55:04.000Z</updated>
        <content type="html"><![CDATA[<p>这是学习阅读《深入理解ES6》第七章 Set 集合与 Map 集合 后整理而成的学习笔记。</p>
<p>Set 集合是一种<strong>无重复元素</strong>的列表；Map 集合内含多组键值对，集合中每个元素分别存放着可访问的键名和它对应的值，Map 集合经常被用于缓存频繁取用的数据。</p>
<h2 id="es5-中的-set-集合与-map-集合">ES5 中的 Set 集合与 Map 集合</h2>
<p>在 ES5 中，开发者们用对象属性来模拟这两种集合：</p>
<pre><code class="language-javascript">var set = Object.create(null);

set.foo = true;

//  检查属性是否存在
if (set.foo) {
    //  要执行的代码
}
</code></pre>
<p>这里的变量 set 是一个原型为 null 的对象，不继承任何属性。在 ES5 中，开发者们经常使用类似的方法检查对象的某个属性值是否存在。</p>
<p>模拟这两种集合的唯一区别是存储的值不同，以下这个示例是用对象模拟 Map 集合：</p>
<pre><code class="language-javascript">var map = Object.create(null);
map.foo = &quot;bar&quot;;

//  获取已存值
var value = map.foo;

console.log(value);         //  &quot;bar&quot;
</code></pre>
<p>一般来说，Set 集合经常被用于检查对象中是否存在某个键名，而 Map 集合常被用于获取已存值的信息。</p>
<h3 id="该方案可能存在的问题">该方案可能存在的问题</h3>
<p>需要注意的是，所有对象的属性名必须是字符串类型，因此必须确保每个键名都是字符串类型且在对象中是唯一的。若以数字为属性名，数字则会被自动转换成字符串；若以对象为属性名，则会被自动转换为对象对应的默认字符串 &quot;[object Object]&quot;。如果不不注意的话，则内部的自动转换机制将会导致很多问题。</p>
<h2 id="es6-中的-set-集合">ES6 中的 Set 集合</h2>
<p>ES6 新增的 Set 类型是一种有序列表，其中含有一些<strong>相互独立</strong>的<strong>非重复值</strong>，通过 Set 集合可以快速访问其中的数据，更有效地追踪各种离散值。</p>
<h3 id="创建-set-集合以及支持的方法与属性">创建 Set 集合以及支持的方法与属性</h3>
<p>调用 <code>new Set()</code> 即可创建 Set 集合。</p>
<p>Set 集合支持以下方法和属性：</p>
<ul>
<li><code>add(value)</code> 方法，用于给 Set 集合添加元素；</li>
<li><code>has(value)</code> 方法，用于判断 Set 集合是否含有 value 值；</li>
<li><code>delete(value)</code> 方法，用于从 Set 集合中删除指定的 value 值；</li>
<li><code>clear()</code> 方法，用于清空 Set 集合；</li>
<li><code>size</code> 属性，可以获取集合中目前的元素数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let set = new Set();
set.add(5);
set.add(&quot;5&quot;);

let key1 = {};
let key2 = {};
set.add(key1);
set.add(key2);

console.log(set.has(5));            //  true
console.log(set.has(&quot;5&quot;));          //  true
console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true

set.delete(5);
set.delete(key1);
console.log(set.has(5));            //  false
console.log(set.has(key1));            //  false
console.log(set.size);          //  2

set.clear();

console.log(set.has(&quot;5&quot;));          //  false
console.log(set.has(key2));         //  false
console.log(set.size);          //  0
</code></pre>
<p>通过这个示例，我们发现数字 5 和字符串 &quot;5&quot;、key1 和 key2 作为独立的值存储入 Set 集合中。实际上，在 Set 集合中，不会对所存值进行强制的类型转换，数字 5 和字符串 &quot;5&quot; 是作为两个独立元素存在，对象key1 和 key2 也不会被转换成字符串，因而两者在 Set 集合中是两个对立的元素。（引擎内部使用 <code>Object.is()</code> 方法检测两个值是否一致，唯一例外的是，Set 集合中的 +0 和 -0 被认为是相等的）</p>
<p><strong>提示</strong>：Set 构造函数可以接受所有可迭代对象作为参数，数组、Set 集合、Map 集合都是可迭代的，因而都可以作为 Set 构造函数的参数使用；构造函数通过迭代器从参数中提取值。</p>
<p>Set 构造函数同样会过滤掉重复的值从而保证集合中的元素各自唯一。示例如下：</p>
<pre><code class="language-javascript">let set = new Set([1,2,2,3,4,5,5,6]);

console.log(set.size);          //  6
</code></pre>
<h3 id="set-集合的-foreach-方法">Set 集合的 forEach() 方法</h3>
<p>ES6 也为 Set 集合添加了 <code>forEach()</code> 方法，其运行机制和数组的 <code>forEach()</code> 方法类似。</p>
<p><code>forEach()</code> 方法的回调函数接受以下 3 个参数：</p>
<ul>
<li>Set 集合中下一次索引的位置</li>
<li>与第一个参数一样的值</li>
<li>被遍历的 Set 集合本身</li>
</ul>
<p>数组和 Map 集合的 <code>forEach()</code> 方法的回调函数都是接受 3 个参数，前两个分别为值和键名，而 Set 集合没有键名，ES6 为了保持方法分歧不大，因此也将 Set 集合中的每个元素也按照键名和值的形式存储，从而保证所有 <code>forEach()</code> 方法的回调函数中前两个参数具有相同意义。</p>
<p>请看以下示例：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

set.forEach(function(value, index, ownerSet) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerSet === set);
});
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-javascript">1 1
true
2 2
true
</code></pre>
<p>在 Set 集合的 <code>forEach()</code> 方法中，第二个参数也与数组的一样，如果需要在回调函数中使用 <code>this</code> 引用，则可以将它作为第二个参数传入 <code>forEach()</code> 函数：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach(function(value) {
            this.output(value);
        }, this);
    }
};

processor.process(set);
</code></pre>
<p>当然我们也可以使用箭头函数，这样在这里就不用向回调函数传入 <code>this</code> 参数了。</p>
<h3 id="将-set-集合转换为数组">将 Set 集合转换为数组</h3>
<p>将数组转换为 Set 集合的过程很简单，只需要给 Set 构造函数传入数组即可；将 Set 集合再转换回数组的过程也很简单，只需要使用<strong>展开运算符</strong>即可。（展开运算符可以将可迭代对象转换为数组）举个例子：</p>
<pre><code class="language-javascript">let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             //  [1, 2, 3, 4, 5]
</code></pre>
<p>在这里，用一个含有重复元素的数组初始化 Set 集合，集合会自动移除这些重复元素；然后再用展开运算符将这些元素放到一个新数组中。</p>
<h3 id="weak-set-集合">Weak Set 集合</h3>
<p>将对象存储在 Set 的实例与存储在变量中完全一样，只要 Set 实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间，于是可以将前面的 Set 类型看作是一个<strong>强引用</strong>的 Set 集合。</p>
<p>为了解决这个问题，ES6 引入了另外一个类型：Weak Set 集合（弱引用 Set 集合）。Weak Set 集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</p>
<p>用 WeakSet 构造函数可以创建 Weak Set 集合，集合支持 3 个方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<p>示例如下：</p>
<pre><code class="language-javascript">let set = new WeakSet(),
    key = {};

//  向集合 set 中添加元素
set.add(key);

console.log(set.has(key));          //  true

set.delete(key);

console.log(set.has(key));          //  false
</code></pre>
<p>WeakSet 构造函数也可以传入一个可迭代对象来创建 Weak Set 集合：</p>
<pre><code class="language-javascript">let key1 = {},
    key2 = {},
    set = new WeakSet([key1, key2]);

console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true
</code></pre>
<p><strong>注意</strong>：WeakSet 构造函数不接受任何原始值，如果数组中包含其他非对象值，程序会抛出错误。</p>
<h3 id="两种-set-类型的主要区别">两种 Set 类型的主要区别</h3>
<p>两种 Set 类型之间最大的区别是 <strong>Weak Set 保存的是对象值得弱引用</strong>。</p>
<p>普通 Set 集合和 Weak Set 集合还有下面几个特性：</p>
<ul>
<li>在 WeakSet 实例中，如果向 <code>add()</code> 方法传入非对象参数会导致程序报错，而向 <code>has()</code> 和 <code>delete()</code> 方法传入非对象参数则会返回 false。</li>
<li>Weak Set 集合不可迭代，所以不能被用于 for-of 循环。</li>
<li>Weak Set 集合不暴露任何迭代器，所以无法通过程序本身来检测其中的内容。</li>
<li>Weak Set 集合不支持 forEach() 方法。</li>
<li>Weak Set 集合不支持 size 属性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖和节流]]></title>
        <id>https://pineapple126.github.io/post/debounce-and-throttle/</id>
        <link href="https://pineapple126.github.io/post/debounce-and-throttle/">
        </link>
        <updated>2020-03-06T11:36:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>防抖</strong>（debounce）：动作绑定事件，在动作发生一段时间后再触发事件。如果这段时间内动作再次发生，则重新等待一段时间后再触发事件。</p>
<p>第一版：根据防抖的定义简单实现防抖功能</p>
<pre><code class="language-javascript">function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;         //  记录调用对象的 this 值
        var args = arguments;           //  记录调用对象的 参数

        clearTimeout(timeout);
        timeout = setTimeout(() =&gt; {
            func.apply(context, args);
        }, wait);
    }
}
</code></pre>
<p>第二版：事件立即执行，然后再根据定义实现防抖</p>
<pre><code class="language-javascript">function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        //  如果 timeout = null 则立即执行
        if (!timeout) {
            func.apply(context, args);
            timeout = setTimeout(() =&gt; {
                timeout = null;
            }, wait);
        } else {
            timeout = setTimeout(() =&gt; {
                func.apply(context, args);
            }, wait);
        }
    }
}
</code></pre>
<p>第三版：将两种结合起来，并添加了手动取消定时器的功能</p>
<pre><code class="language-javascript">/**
 * @param { function } func
 * @param { number } wait 延迟执行毫秒数
 * @param { boolean } immediate  true 表立即执行，false 表非立即执行
 * @return { function }
 */
function debounce(func, wait, immediate) {
    var timeout;

    var debounced = function () {
        var context = this;
        var args = arguments;

        //  如果定时器存在，则清楚定时器，再重新计时
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            //  如果已经执行过，则不再执行
            var callNow = !timeout;
            timeout = setTimeout(() =&gt; {
                timeout = null;
            }, wait);
            if (callNow) func.apply(context, args);
        } else {
            timeout = setTimeout(() =&gt; {
                func.apply(context, args);
            }, wait);
        }
    }
    return debounced;
}
</code></pre>
<p><strong>节流</strong>（throttle）：动作绑定事件，在动作发生一段时间后再触发事件。如果在这段时间内动作再次发生，则无视此次动作，等待事件完成后，才能重新触发。</p>
<p>第一版：时间戳版——使用时间戳，当事件触发时，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳；如果小于，则不必执行。</p>
<pre><code class="language-javascript">function throttle(func, wait) {
    var previous = 0;

    return function () {
        var context = this;
        var args = arguments;

        var now = +new Date();
        if (now - previous &gt; wait) {
            func.apply(context, this);
            previous = now;
        }
    }
}
</code></pre>
<p>第二版：定时器版——当事件触发的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，则不执行，直到定时器执行时执行事件函数，并清空定时器。</p>
<pre><code class="language-javascript">function throttle(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        if (!timeout) {
            timeout = setTimeout(() =&gt; {
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    }
}
</code></pre>
<p>第三版：将时间戳版本与定时器版本合并起来</p>
<pre><code class="language-javascript">/**
 * @param { function } func 函数
 * @param { number } wait 延迟执行毫秒数
 * @param { number } type 1 表示时间戳版，2 表示定时器版
 * @return { function }
 */
function throttle(func, wait, type) {
    var previous = 0;
    var timeout;
    
    return function () {
        var context = this;
        var args = arguments;

        if (type === 1) {
            var now = +new Date();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        } else if (type === 2) {
            if (!timeout) {
                timeout = setTimeout(() =&gt; {
                    timeout = null;
                    func.apply(context, args);
                }, wait);
            }
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用模块封装代码]]></title>
        <id>https://pineapple126.github.io/post/module/</id>
        <link href="https://pineapple126.github.io/post/module/">
        </link>
        <updated>2020-02-28T08:12:23.000Z</updated>
        <content type="html"><![CDATA[<p>这是学习阅读《深入理解ES6》第十三章 用模块封装代码 后整理而成的学习笔记。</p>
<p>JavaScript 用“共享一切”的方法加载代码，这是语言中最容易出错且容易令人感到困惑的地方。为了解决作用域问题，也为了使 JavaScript 应用程序显得有序，因此 ES6 引入了模块。</p>
<h2 id="什么是模块">什么是模块</h2>
<p><strong>模块是自动运行在严格模式下并且没有办法退出运行的 JavaScript 代码</strong>。与共享一切架构相反的是，在模块顶部创建的变量不会自动被添加到全局共享作用域，这个变量仅在模块的顶级作用域中存在，而且模块必须导出一些外部代码可以访问的元素，比如变量或函数。模块也可以从其他模块导入绑定。在模块的顶部，this 的值是 undefined。</p>
<p>模块的魔力所在是仅<strong>导出和导入</strong>我们所需要的绑定，而不是将所有的东西都放到一个文件中。</p>
<h2 id="导出的基本语法">导出的基本语法</h2>
<p>我们可以用 <code>export</code> 关键字将一部分已发布的代码暴露给其他模块，例如：</p>
<pre><code class="language-javascript">//  导出数据
export var color = &quot;red&quot;;
export let name = &quot;Nicolas&quot;;
export const magicNumber = 7;

//  导出函数
export function sum(num1, num2) {
    return num1 + num2;
}

//  导出类
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

//  这个函数模块是私有的
function substract(num1, num2) {
    return num1 - num2;
}

//  定义一个函数
function multiply(num1, num2) {
    return num1 * num2;
}

//  再将其导出
export multiply;
</code></pre>
<p>导出的函数和类声明需要有一个名字，除非是用 <code>default</code> 关键字否则不能用这个语法导出匿名函数或类。任何未显式导出的变量、函数或类都是模块私有的，无法从模块外访问。</p>
<h2 id="导入的基本语法">导入的基本语法</h2>
<p>从模块中导出的功能可以使用 <code>import</code> 关键字在另一个模块中访问，<code>import</code> 语句的两个部分是：<strong>要导入的标识符</strong>和<strong>标识符应当从哪个模块导入</strong>。</p>
<p>语句的基本形式如下：</p>
<pre><code class="language-javascript">import { identifier1, identifier2 } from &quot;./example.js&quot;;
</code></pre>
<p><code>import</code> 后面的大括号表示从给定模块导入的绑定（binding），关键字 from 表示从哪个模块导入给定的绑定，该模块由表示模块路径的字符串指定（模块说明符）。</p>
<p>当从模块中导入一个绑定时，它就好像使用 const 定义的一样。结果是我们无法定义另一个同名变量（包括导入另一个同名绑定），也无法在 import 语句前使用标识符或改变绑定的值。</p>
<h3 id="导入单个绑定">导入单个绑定</h3>
<p>假设在一个名为 &quot;example.js&quot; 的模块中，我们可以导入并以多种方式使用这个模块中的绑定。举例来说，可以只导入一个标识符：</p>
<pre><code class="language-javascript">//  只导入一个
import { sum } from &quot;./example.js&quot;;

console.log(sum(1, 2));     //  3

sum = 1;            //  抛出错误
</code></pre>
<p>尽管 example.js 导出的函数不止一个，但是我们导入的只有 sum() 函数。如果尝试给 sum 赋新值，结果会抛出错误，因为<strong>不能给导入的绑定重新赋值</strong>。</p>
<h3 id="导入多个绑定">导入多个绑定</h3>
<p>如果要导入多个绑定，则可以明确的将他们列出：</p>
<pre><code class="language-javascript">//  导入多个
import { sum, multiply, magicNumber } from &quot;./example.js&quot;;

console.log(sum(1, magicNumber));           //  8
console.log(multiply(1, 2));            //  2
</code></pre>
<h3 id="导入整个模块">导入整个模块</h3>
<p>特殊情况下，可以导入整个模块作为一个单一的对象。然后所有的导出都可以作为对象的属性使用。例如：</p>
<pre><code class="language-javascript">//  导入一切
import * as example from &quot;./example.js&quot;;

console.log(example.sum(1, example.magicNumber));           //  8
console.log(example.multiply(1, 2));            //  2
</code></pre>
<p>需要注意的是，不管在 import 语句中把一个模块写了多少次，该模块只会执行一次。导入模块的代码执行后，实例化过的模块被保存在内存中，只要另一个 import 语句引用它就可以重复使用它。如果同一个应用程序的其他模块也从该模块中引入绑定，那么那些模块与此代码将使用相同的<strong>模块实例</strong>。</p>
<p><strong>注意</strong>：export 和 import 的一个重要限制是，它们必须在其他语句和函数之外使用。模块语法存在的一个原因是要让 JavaScript 引擎静态地确定哪些可以导出，因此，只能在顶部使用 export。而 import 语句为变量、函数和类创建的是<strong>只读</strong>绑定，而不是像正常变量一样简单地引用原始绑定。</p>
<h2 id="导出和导入时重命名">导出和导入时重命名</h2>
<p>我们可以使用 as 关键字在导出过程和导入过程中改变导出元素和导入元素的名称。</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
</code></pre>
<p>在这里，函数 sum() 是本地名称，add() 是导出时使用的名称。当另一个模块要导入这个函数时，必须使用 add 这个名称：</p>
<pre><code class="language-javascript">import { add as sum } from &quot;./example.js&quot;;

console.log(typeof add);            //  &quot;undefined&quot;
console.log(sum(1, 2));         //  3
</code></pre>
<p>这段代码导入 add() 函数时使用了一个导入名称来重命名 sum() 函数。</p>
<h2 id="模块的默认值">模块的默认值</h2>
<p>模块的默认值值得是通过 <code>default</code> 关键字指定的单个变量、函数或类，只能为每个模块设置一个默认的导出值。</p>
<h3 id="导出默认值">导出默认值</h3>
<p>下面是一个使用 default 关键字的简单示例：</p>
<pre><code class="language-javascript">export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>
<p>这个模块导出了一个函数作为它的默认值，default 关键字表示这是一个默认的导出，由于函数被模块所代表，因而它不需要一个名称。</p>
<p>也可以在 export default 之后添加默认导出值的标识符，就像这样：</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export default sum;
</code></pre>
<p>为默认导出值指定标识符的第三种方法是使用重命名语法，如下所示：</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
</code></pre>
<p>在重命名导出时标识符 default 具有特殊含义，用来只是模块的默认值。</p>
<h3 id="导入默认值">导入默认值</h3>
<p>可以使用以下语法从一个模块中导入一个默认值：</p>
<pre><code class="language-javascript">//  导入默认值
import sum from &quot;./examole.js&quot;;

console.log(sum(1, 2));         //  3
</code></pre>
<p>对于导出默认值和一或多个非默认绑定的绑定，可以用一条语句导入所有导出的绑定，例如，假设有一下这个模块：</p>
<pre><code class="language-javascript">export let color = &quot;red&quot;;

export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>
<p>可以用一下这条 import 语句导入 color 和默认函数：</p>
<pre><code class="language-javascript">import sum, { color } from &quot;./example.js&quot;;

console.log(sum(1, 2));         //  3
console.log(color);         //  &quot;red&quot;
</code></pre>
<p>用逗号将默认的本地名称与大括号包裹的非默认值分隔开，请记住，在 export 语句中，默认值必须排在非默认值之前。</p>
<p>与导出默认值相同，也可以在导入默认值时使用重命名语法：</p>
<pre><code class="language-javascript">import { default as sum, color } from &quot;./example.js&quot;;

console.log(sum(1, 2));         //  3
console.log(color);         //  &quot;red&quot;
</code></pre>
<h2 id="重新导出一个绑定">重新导出一个绑定</h2>
<p>如果需要重新导入模块中已经导入的内容，可以使用一条语句完成：</p>
<pre><code class="language-javascript">export { sum } from &quot;./example.js&quot;;
</code></pre>
<p>同样的我们也可以使用不同的名称导出：</p>
<pre><code class="language-javascript">export { sum as add } from &quot;./example.js&quot;;
</code></pre>
]]></content>
    </entry>
</feed>