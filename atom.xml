<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pineapple126.github.io/</id>
    <title>深海大菠萝盖饭</title>
    <updated>2021-03-29T05:42:28.681Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pineapple126.github.io/"/>
    <link rel="self" href="https://pineapple126.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://pineapple126.github.io/images/avatar.png</logo>
    <icon>https://pineapple126.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 深海大菠萝盖饭</rights>
    <entry>
        <title type="html"><![CDATA[Leetcode —— 768. 最多能完成排序的块 II Hard]]></title>
        <id>https://pineapple126.github.io/post/leetcode-max-chunks-to-make-sorted-ii/</id>
        <link href="https://pineapple126.github.io/post/leetcode-max-chunks-to-make-sorted-ii/">
        </link>
        <updated>2021-03-29T04:30:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p><code>arr</code> 是一个可能包含<strong>重复元素</strong>的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，是的连接的结果和按升序排序后的原数组相同。请求出我们最多可以将数组分成多少块?</p>
<p><strong>示例</strong></p>
<pre><code>输入: arr = [5,4,3,2,1]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。

输入: arr = [2,1,3,4,4]
输出: 4
解释:
我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。
然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一滑动窗口">方法一：滑动窗口</h3>
<p>原题有一个提示：</p>
<pre><code>Each k for which some permutation of arr[:k] is equal to sorted(arr)[:k] is where we should cut each chunk.
</code></pre>
<p>即说明原数组进行分块后，每一个分块和排序后的数组中对应的分块数字是一样的，只是顺序不同。因此我们可以使用一个滑动窗口同时扫描原数组和排序数组，当窗口中数字的和一样时，就将数组进行分块。</p>
<pre><code class="language-javascript">var maxChunksToSorted = function (arr) {
  const sorted = [...arr];
  sorted.sort((a, b) =&gt; a - b);

  let count = 0,
    sum = 0;
  for (let i = 0; i &lt; arr.length; i++) {
    sum += arr[i];
    sum -= sorted[i];
    if (sum === 0) {
      count++;
    }
  }
  return count;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(NlogN)，N 为数组长度，数组排序时间认为是 NlogN，滑动窗口遍历数组时间为 N。</li>
<li>空间复杂度：O(N)，N 为数组长度。</li>
</ul>
<h3 id="方法二辅助栈法">方法二：辅助栈法</h3>
<p>根据题意，将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果。</p>
<p>可以得到的一个结论是，每个分块中的数字相对于前一个分块都是递增的(因为有重复数字，所以也可能是相同)，下一个分块中的所有数字都会大于等于上一个分块中的所有数字。</p>
<ul>
<li>因为题目要求能分的最多的块数，所以我们在分块的时候要尽量把块分小，这样就能分得比较多。</li>
<li>在遍历数组的过程中，如果一个数字比之前所有分块的最大值都要大，我们就把它作为一个新的分块。</li>
<li>如果数字小于之前某些分块的最大值，那这些分块都要被合成一个分块(保持栈的单调递增)。</li>
</ul>
<pre><code class="language-javascript">class Stack {
  constructor() {
    this.list = [];
  }
  push(val) {
    this.list.push(val);
  }
  pop() {
    return this.list.pop();
  }
  empty() {
    return this.list.length === 0;
  }
  peek() {
    return this.list[this.list.length - 1];
  }
  size() {
    return this.list.length;
  }
}

var maxChunksToSorted = function (arr) {
  const stack = new Stack();

  for (let i of stack) {
    if (stack.empty() || stack.peek &lt;= i) {
      stack.push(i);
    } else {
      const temp = stack.pop();

      while (stack.peek() &gt; i) {
        stack.pop();
      }

      stack.push(temp);
    }
  }
  return stack.size();
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(NlogN)，N 为数组长度。</li>
<li>空间复杂度：O(N)，N 为数组长度，栈消耗的空间。</li>
</ul>
<blockquote>
<p>来源：力扣（Leetcode）<br>
链接：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://pineapple126.github.io/post/sort-algorithm/</id>
        <link href="https://pineapple126.github.io/post/sort-algorithm/">
        </link>
        <updated>2021-03-19T03:05:08.000Z</updated>
        <content type="html"><![CDATA[<p>无论我们平时是自己写工程代码，还是刷各种算法题目，亦或是面试的时候，我们都可能避免不了要写排序算法，因此对常见的排序算法做一下总结。</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(logn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>m</mi><mi>s</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m^s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-javascript">function bubbleSort(arr) {
    for (let i = 0; i &lt; arr.length; i++) {
        for (let j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
</code></pre>
<h2 id="选择排序">选择排序</h2>
<p>基本思想：给定一个序列，从中找到最小的一个放到序列的第一个位置，再从剩下的 n-1 个中找到最小的放到第二个位置。直到剩下最后一个元素就直接放在最后的位置，排序结束。</p>
<pre><code class="language-javascript">function selectSort(arr) {
    for (let i = 0; i &lt; arr; i++) {
        let temp = arr[i],
        pos = i;

        for (let j = i + 1; j &lt; size; j++) {
            if (arr[j] &lt; temp) {
                pos = j;
                temp = arr[j];
            }
        }
        arr[pos] = arr[i];
        arr[i] = temp;
    }
    return arr;
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<p>基本思想：将数组的第一位视为一个有序数组，将剩下的待排序数组逐个插入到已排序数组中。</p>
<pre><code class="language-javascript">function insertSort(arr) {
    for (let i=1; i &lt; arr.length; i++) {
        let j = i,
            temp = arr[j];
        while (j &gt; 0 &amp;&amp; temp &lt; arr[j]) {
            temp = arr[j];
            j--;
        }
        arr[j] = temp;
    }
    return arr;
}
</code></pre>
<h2 id="快速排序">快速排序</h2>
<p>基本思想：采用分治的思想，选取一个基准，将待排序数组分为两个小、大数组，不断重复这个过程直至数组有序。</p>
<p>基本步骤：</p>
<ol>
<li>选取基准（pivot）；</li>
<li>根据基准将待排序数组分割为两个数组；</li>
<li>重复以上步骤，直至数组有序。</li>
</ol>
<pre><code class="language-javascript">function quickSort(arr) {
    if (arr.length &lt; 2) return arr;
    let pivot = arr[0];
    let left = [],
        right = [];
    for (let i = 1; i &lt; arr.length; i++) {
        if (arr[i] &lt; pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot, quickSort(right));
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>基本思想：采取分治的思想，将两个有序数组合并为一个有序数组。</p>
<pre><code class="language-javascript">function mergeSort(arr) {
    if (arr.length &lt; 2) return arr;
    let res = [];
    let mid = arr.length &gt;&gt; 1;
    let left = mergeSort(arr.slice(0, mid)),
        right = mergeSort(arr.slice(mid));
    while (left.length &amp;&amp; right.length) {
        if (left[0] &lt; right[0]) {
            res.push(left.shift());
        } else {
            res.push(right.shift());
        }
    }
    return res.concat(left, right);
}
</code></pre>
<h2 id="堆排序">堆排序</h2>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序实质上就是步长不定的插入排序。<br>
步长从 n/2 开始，并且总是以 1 结束。</p>
<p>希尔排序也是一种<em>插入排序</em>，它是简单插入排序经过改进之后的一个更高效的版本，也成为<strong>缩小增量排序</strong>，同时该算法是冲破 O(n²) 的第一批算法之一。</p>
<p>基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键字越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p>
<p>基本步骤：选择起始增量 <code>gap = length/2</code>，分组。然后继续以 <code>gap = gap/2</code> 的方式更新增量和分组。这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, ..., 1}，称为<strong>增量序列</strong>。</p>
<pre><code class="language-javascript">function shellSort(arr) {
    // 增量 gap，并逐渐缩小增量
    for (let gap = arr.length &gt;&gt;&gt; 1; gap &gt; 0; gap &gt;&gt;&gt;= 2) {
        // 从第 gap 个元素，逐渐对其所在组进行直接插入排序操作
        for (let i = gap; i &lt; arr.length; i++) {
            let j = i,
                temp = arr[j];
            while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
    }
    return arr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《算法（第4版）》读书笔记——第 1 章 基础]]></title>
        <id>https://pineapple126.github.io/post/algorithms-fourth-edition-basics/</id>
        <link href="https://pineapple126.github.io/post/algorithms-fourth-edition-basics/">
        </link>
        <updated>2021-01-17T06:30:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="本周任务">本周任务</h2>
<p>基础数据类型/排序/树/正则表达式<br>
第 1 章/第 2 章/第 3 章/第 5 章</p>
<h2 id="第-1-章-基础">第 1 章 基础</h2>
<p>和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。</p>
<ul>
<li>1.1 总结相关语法、语言特性和书中将会用到的库。</li>
<li>1.2 介绍用 Java 实现<strong>抽象数据类型</strong>的过程，包括定义它的应用程序编程接口（API）然后通过 Java 的类机制来实现它以供各种用例使用。</li>
<li>1.3 用数组、变长数组和链表实现<strong>背包、队列和栈</strong>的 API。</li>
<li>1.4 分析算法<strong>性能</strong>的方法。</li>
</ul>
<p><strong>算法</strong>，编写一段计算机程序一般都是实现一种已有的方法来解决某个问题。这种方法大多和使用的编程语言无关——它适用于各种计算机以及编程语言。是这种方法而非计算机程序本身描述了解决问题的步骤。**在计算机科学领域，我们用算法这个词来描述一种有限、确定、有效的并适合用计算机程序来实现的解决问题的方法。**算法是计算机科学的基础，是这个领域的核心。</p>
<p>我们关注的大多数算法都需要适当地组织数据，而为了组织数据就产生了<strong>数据结构</strong>，数据结构也是计算机科学研究地核心对象，它和算法的关系非常密切。在本书中，我们的观点是数据结构是算法的副产品或是结果，因为要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，相应地，复杂的算法也许只需要简单的数据结构。</p>
<p>当用计算机解决一个问题时，一般都存在多种不同的方法。对于小型问题，只要管用，方法的不同并没有什么关系。但是对于大型问题（或者是需要解决大量小型问题的应用），我们就需要设计能够有效利用时间和空间的方法了。</p>
<p>无论在任何应用领域，精心设计算法都是解决大型问题最有效的方法。</p>
<h3 id="11-基础编程模型">1.1 基础编程模型</h3>
<p>使用程序来描述算法的好处：</p>
<ul>
<li>程序是对算法精确、优雅和完全的描述；</li>
<li>可以通过运行程序来学习算法的各种性质；</li>
<li>可以在应用程序中直接使用这些算法；</li>
</ul>
<h4 id="111-基本结构">1.1.1 基本结构</h4>
<ul>
<li>原始数据类型：它们在计算机程序中精确地定义整数、浮点数和布尔值等。它们的定义包括取值范围和能够对相应的值进行的操作，它们能够被组合为类似于数学公式定义的表达式。</li>
<li>语句：语句通过创建变量对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：声明、赋值、条件、循环、调用和返回。</li>
<li>数组：数组是多个同种数据类型的值的集合。</li>
<li>静态方法：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。</li>
<li>字符串：字符串是一连串的字符，Java 内置了对他们的一些操作。</li>
<li>标准输入/输出：标准输入输出是程序与外界联系的桥梁。</li>
<li>数据抽象：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。</li>
</ul>
<h4 id="112-原始数据类型与表达式">1.1.2 原始数据类型与表达式</h4>
<p>数据类型就是一组数据和对其所能进行的操作的集合。以下是 4 种 Java 语言最基本的原始数据类型：</p>
<ul>
<li>整型，及其算术运算符（int）；</li>
<li>双精度实数类型，及其算术运算符（double）；</li>
<li>布尔型，它的值（true，false）及其逻辑操作（boolean）；</li>
<li>字符型，它的值是你能够输入的英文字母数字字符和符号（char）。</li>
</ul>
<p>Java 程序的基本组成</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>例子</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>原始数据类型</td>
<td>int double boolean char</td>
<td>一组数据和对其所能进行的操作的集合（Java 语言内置）</td>
</tr>
<tr>
<td>标识符</td>
<td>a abc Ab$ a_b ab123 lo hi</td>
<td>由字母、数字、下划线和 $ 组成的字符串，首字符不能是数字</td>
</tr>
<tr>
<td>变量</td>
<td>【 任意标识符】</td>
<td>表示某种数据类型的值</td>
</tr>
<tr>
<td>运算符</td>
<td>+ - * /</td>
<td>表示某种数据类型的运算</td>
</tr>
<tr>
<td>字面量</td>
<td></td>
<td>值在源代码中的表示</td>
</tr>
<tr>
<td>表达式</td>
<td>lo + (hi - lo) / 2</td>
<td>字面量、变量或是能够计算出结果的一串字面量、变量和运算符的组合</td>
</tr>
</tbody>
</table>
<h4 id="113-语句">1.1.3 语句</h4>
<p>语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。</p>
<ul>
<li>声明语句：创建某种类型的变量并用标识符为其命名。</li>
<li>赋值语句：将（有表达式产生的）某种类型的数值赋予一个变量。Java 还有一些隐式赋值的语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。</li>
<li>条件语句：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。</li>
<li>循环语句：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。</li>
<li>调用和返回语句：和静态方法有关，是改变执行流程和代码组织地另一种方式。</li>
</ul>
<p>程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。</p>
<h4 id="116-递归">1.1.6 递归</h4>
<p>编写递归代码时最重要的有以下三点：</p>
<ul>
<li>递归总有一个简单的情况——方法的第一条语句总是一个包含 return 的条件语句。</li>
<li>递归调用总是去尝试解决一个规模更小的子问题，这样递归才能收敛到最简单的情况。</li>
<li>递归调用的父问题和尝试解决的子问题之间不应该有交集。</li>
</ul>
<p><strong>模块化编程的好处：</strong></p>
<ul>
<li>程序整理的代码量很大时，每次处理的模块大小仍然适中；</li>
<li>可以共享和重用代码而无需重新实现；</li>
<li>很容易用改进的实现替换老的实现；</li>
<li>可以为解决编程问题建立合适的抽象模型；</li>
<li>缩小调试范围</li>
</ul>
<h4 id="1111-展望">1.1.11 展望</h4>
<p>使用<strong>数据抽象</strong>的原因：</p>
<ul>
<li>数据抽象允许我们通过模块化编程复用代码。</li>
<li>数据抽象是我们可以轻易构造多种所谓的链式数据结构，它们比数组更灵活，在许多情况下都是高效算法的基础。</li>
<li>借助数据抽象我们可以准确地定义所面对的算法问题。</li>
</ul>
<h2 id="第-2-章-排序">第 2 章 排序</h2>
<p>排序就是将一组对象按照某种逻辑顺序重新排列的过程。</p>
<p>学习排序算法的三大实际意义：</p>
<ul>
<li>对排序算法的分析将有助于全面理解本书中比较性能的方法；</li>
<li>类似的技术也能有效解决其他类型的问题；</li>
<li>排序算法常常是我们解决其他问题的第一步。</li>
</ul>
<h3 id="21-初级排序算法">2.1 初级排序算法</h3>
<h4 id="212-选择排序">2.1.2 选择排序</h4>
<p>一种最简单的排序算法是这样的：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaScript Source Map 是什么？]]></title>
        <id>https://pineapple126.github.io/post/javascript-source-map/</id>
        <link href="https://pineapple126.github.io/post/javascript-source-map/">
        </link>
        <updated>2020-11-18T13:12:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-什么是-source-map">一、什么是 Source Map ?</h2>
<p>顾名思义，Source Map 是保存源代码映射关系的文件，相信用过 webpack 的开发者对它应该不会陌生。在项目开发完进行打包后，在打包的文件里通常除了 js、css、图片字体等资源文件外，大家一定还见过 xxx.js.map 的文件。这种带 map 的后缀的文件就是 Source Map 文件 —— 它就是一个位置文件，保存了源代码和转换之后代码的位置关系。下图展示了部分打包之后生成的 Source Map 文件：</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1605715644396.png" alt="source_map" loading="lazy"></figure>
<h2 id="二-为什么要使用-source-map">二、为什么要使用 Source Map ？</h2>
<p>明白了什么是 Source Map 之后，可是我们为什么要使用 Source Map 呢？由于现代前端项目的发展，前端代码变得越来越庞大和复杂。大部分源码都需要经过转换，才能投入到生产环境中使用。常见的转换过程包括但不限于：</p>
<ul>
<li>压缩混淆（UglifyJS）</li>
<li>编译（TypeScript，CoffeeScript）</li>
<li>转译（Babel）</li>
<li>合并多个文件，减少带宽请求</li>
</ul>
<p>经过上述转换的代码，往往都会变得面目全非，就像下面这样：</p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1605717052787.png" alt="source_map_after" loading="lazy"></figure>
<p>这样虽然对带宽很友好，但是调试起来就不是那么轻松了。我们在代码出错的时候，肯定最希望能定位其在源码中的位置。比如下面这两个错误提示：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1605717160418.png" alt="source_map_error" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1605717173913.png" alt="source_map_error_with_sourcemap" loading="lazy"></figure>
<p>对于大多数开发者来说，希望看到的应该是第二种提示方式，而这就是Source Map能够输出的能力。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便。</p>
<h2 id="三-source-map-文件的格式及含义">三、Source Map 文件的格式及含义</h2>
<pre><code class="language-json">{
    &quot;version&quot;: 3,
    &quot;file&quot;: &quot;out.js&quot;,
    &quot;sourceRoot&quot;: &quot;&quot;,
    &quot;sources&quot;: [
        &quot;log,js&quot;,
        &quot;main.js&quot;
    ],
    &quot;names&quot;: [
        &quot;sayHello&quot;,
        &quot;name&quot;,
        &quot;length&quot;,
        &quot;substr&quot;,
        &quot;console&quot;,
        &quot;log&quot;
    ],
    &quot;mappings&quot;: &quot;AAAA,SAASA,SAAUC&quot;
}
</code></pre>
<p>整个文件就是一个 JSON 对象，可以被解释器读取。他主要有以下几个属性：</p>
<ul>
<li>version：Source Map 的版本，目前为 3。</li>
<li>file：转换后的文件名。</li>
<li>sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</li>
<li>sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。</li>
<li>names：转换前的所有变量名和属性名。</li>
<li>mappings：记录位置信息的字符串。</li>
</ul>
<p><strong>mappings 属性</strong></p>
<p>下面才是真正有趣的部分：两个文件的各个位置是如何一一对应的。</p>
<p>关键就是 map 文件的 mappings 属性。这是一个很长的字符串，它分成三层。</p>
<ul>
<li>第一层是<strong>行对应</strong>，以分号（；）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。</li>
<li>第二层是<strong>位置对应</strong>，以逗号（，）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。</li>
<li>第三层是<strong>位置转换</strong>，以 <strong>VLQ 编码</strong>表示，代表该位置对应的转换前的源码位置。</li>
</ul>
<p>举例来说，假定mappings属性的内容如下：</p>
<pre><code>mappings:&quot;AAAAA,BBBBB;CCCCC&quot;
</code></pre>
<p>就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。</p>
<p><strong>位置对应的原理</strong></p>
<p>每个位置使用五位，表示五个字段。</p>
<p>从左边算起，</p>
<ul>
<li>第一位，表示这个位置在（转换后的代码的）的第几列。<strong>输出文件列位置</strong></li>
<li>第二位，表示这个位置属于sources属性中的哪一个文件。<strong>输入文件名索引</strong></li>
<li>第三位，表示这个位置属于转换前代码的第几行。<strong>输入文件行号</strong></li>
<li>第四位，表示这个位置属于转换前代码的第几列。<strong>输入文件列号</strong></li>
<li>第五位，表示这个位置属于names属性中的哪一个变量。<strong>字符索引</strong></li>
</ul>
<p>有几点需要说明。首先，所有的值都是以 0 作为基数的。其次，第五位不是必需的，如果该位置没有对应 names 属性中的变量，可以省略第五位。再次，每一位都采用 VLQ 编码表示；由于 VLQ 编码是变长的，所以每一位可以由多个字符构成。</p>
<p>如果某个位置是 AAAAA，由于 A 在 VLQ 编码中表示 0，因此这个位置的五个位实际上都是 0。它的意思是，该位置在转换后代码的第 0 列，对应 sources 属性中第 0 个文件，属于转换前代码的第 0 行第 0 列，对应 names 属性中的第 0 个变量。</p>
<h2 id="vlq-编码">VLQ 编码</h2>
<p><strong>定义</strong></p>
<blockquote>
<p>A variable-length quantity (VLQ) is a universal code that uses an arbitrary number of binary octets (eight-bit bytes) to represent an arbitrarily large integer.<br>
翻译一下：VLQ是用任意个2进制字节组去表示一个任意数字的编码形式。</p>
</blockquote>
<p>VLQ 的编码形式很多，这篇文章中要说明的是下面这种：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1605719630938.png" alt="VLQ_code" loading="lazy"></figure>
<ul>
<li>一个组包含 6 个二进制位。</li>
<li>在每组的第一位 C 用来标识其后面是否会跟着另一个 VLQ 字节组，值为 0 表示其是最后一个 VLQ 字节组，值为 1 表示后面还跟着另一个 VLQ 字节组。</li>
<li>在第一组中，最后 1 位用来表示符号，值为 0 则表示正数，为 1 表示负数。其他组的最后一位都是表示数字。</li>
<li>其他位都是表示数字。</li>
</ul>
<p>这种编码方式也成为 Base64 VLQ 编码，因为每一个组对应一个 Base64 编码。</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1605719957709.png" alt="VLQ_base64" loading="lazy"></figure>
<p>参考文章</p>
<ul>
<li>[1] <a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></li>
<li>[2] <a href="https://juejin.im/post/6844903869928079373">深入理解 SourceMap</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.12 —— 922. 按奇偶排序数组 II Easy]]></title>
        <id>https://pineapple126.github.io/post/leetcode-sort-array-by-parity-ii/</id>
        <link href="https://pineapple126.github.io/post/leetcode-sort-array-by-parity-ii/">
        </link>
        <updated>2020-11-12T09:17:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p><strong>示例</strong></p>
<pre><code>输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一两次遍历">方法一：两次遍历</h3>
<p>遍历一遍数组把所有的偶数放进 <code>even</code> 数组内，再遍历一遍数组把所有的奇数放进 <code>odd</code> 数组内。</p>
<pre><code class="language-javascript">var sortArrayByParityII = function(A) {
  const odd = A.filter(val =&gt; (val &amp; 1) === 1);
  const even = A.filter(val =&gt; (val &amp; 1) === 0);
  const ans = [];
  for (let i=0; i&lt;A.length/2; i++) {
    ans.push(even.shift(), odd.shift());
  }
  return ans;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h3 id="方法二双指针">方法二：双指针</h3>
<p>如果原数组可以修改，则可以使用就地算法求解。</p>
<p>为数组的偶数下标部分和奇数下标部分分别维护指针 i, j。随后，在每一步中，如果 A[i] 为奇数，则不断地向前移动 j（每次移动两个单位），直到遇见下一个偶数。此时，可以直接将 A[i] 与 A[j] 交换。我们不断进行这样的过程，最终能够将所有的整数放在正确的位置上。</p>
<pre><code class="language-javascript">var sortArrayByParityII = function(A) {
    const len = A.length;
    let j = 1;
    for (let i=0; i&lt;len; i+=2) {
        if (A[i] &amp; 1) {
            while (A[j] &amp; 1) {
                j += 2;
            }
            [A[i], A[j]] = [A[j], A[i]];
        }
    }
    return A;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：O(1)。不考虑输出数组的空间占用。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.9 —— 973. 最接近原点的 K 个点]]></title>
        <id>https://pineapple126.github.io/post/leetcode-k-closest-points-to-origin/</id>
        <link href="https://pineapple126.github.io/post/leetcode-k-closest-points-to-origin/">
        </link>
        <updated>2020-11-09T15:38:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。</p>
<p>（这里，平面上两点之间的距离是欧几里德距离。）</p>
<p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p>
<p><strong>示例</strong></p>
<pre><code>输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="排序">排序</h3>
<p>将每个点到原点的欧几里得距离的平方从小到大排序后，取出前 K 个即可。</p>
<pre><code class="language-javascript">var kClosest = function(points, K) {
    const getDistance = (point) =&gt; {
        return Math.pow(point[0], 2) + Math.pow(point[1], 2);
    }
    points.sort((a, b) =&gt; {
        return getDistance(a) - getDistance(b);
    });
    return points.slice(0, K);
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 points 的长度。算法的时间复杂度即排序的时间复杂度。</li>
<li>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/k-closest-points-to-origin</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「前端进阶」JS中的栈内存堆内存]]></title>
        <id>https://pineapple126.github.io/post/stack-memery-and-heap-memery-in-js/</id>
        <link href="https://pineapple126.github.io/post/stack-memery-and-heap-memery-in-js/">
        </link>
        <updated>2020-11-08T10:32:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>文章来源于掘金，作者 云中桥</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。</p>
<p>其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。</p>
<h2 id="栈数据结构">栈数据结构</h2>
<p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。<br>
栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。<br>
由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。<br>
为了得到栈底的元素，必须先拿掉上面的元素。<br>
在这里，为方便理解，通过类比乒乓球盒子来分析栈的存取方式。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1604846528569.jpg" alt="stack_structure" loading="lazy"></figure>
<p>这种乒乓球的存放方式与栈中存取数据的方式如出一辙。<br>
处于盒子中最顶层的乒乓球 5，它一定是最后被放进去，但可以最先被使用。<br>
而我们想要使用底层的乒乓球 1，就必须将上面的 4 个乒乓球取出来，让乒乓球1处于盒子顶层。<br>
这就是栈空间先进后出，后进先出的特点。</p>
<h2 id="堆数据结构">堆数据结构</h2>
<p>堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，我们只需要关心书的名字。</p>
<h2 id="变量类型与内存的关系">变量类型与内存的关系</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p>基本数据类型共有 7 种：</p>
<ol>
<li>null</li>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>symbol</li>
<li>bigint</li>
</ol>
<p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p>
<p>为了更好的搞懂基本数据类型变量与栈内存，我们结合以下例子与图解进行理解：</p>
<pre><code class="language-javascript">let num1 = 1;
let num2 = 1;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1604846803112.jpg" alt="stack_example" loading="lazy"></figure>
<p>PS: 需要注意的是闭包中的基本数据类型变量不保存在栈内存中，而是保存在堆内存中。这个问题，我们后文再说。</p>
<h3 id="引用数据类型">引用数据类型</h3>
<p>Array,Function,Object...可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。</p>
<p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<p>为了更好的搞懂变量对象与堆内存，我们结合以下例子与图解进行理解。</p>
<pre><code class="language-javascript">// 基本数据类型-栈内存
let a1 = 0;
// 基本数据类型-栈内存
let a2 = 'this is string';
// 基本数据类型-栈内存
let a3 = null;

// 对象的指针存放在栈内存中，指针指向的对象存放在堆内存中
let b = { m: 20 };
// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中
let c = [1, 2, 3];
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1604846889629.jpg" alt="heap_example" loading="lazy"></figure>
<p>因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量中获取了该对象的地址指针， 然后再从堆内存中取得我们需要的数据。</p>
<h2 id="从内存角度来看变量复制">从内存角度来看变量复制</h2>
<h3 id="基本数据类型的复制">基本数据类型的复制</h3>
<pre><code class="language-javascript">let a = 20;
let b = a;
b = 30;
console.log(a); // 此时 a 的值是多少，是 30？还是 20？
</code></pre>
<p>答案是：20</p>
<p>在这个例子中，a、b 都是基本类型，它们的值是存储在栈内存中的，a、b 分别有各自独立的栈空间， 所以修改了 b 的值以后，a 的值并不会发生变化。</p>
<p>从下图可以清晰的看到变量是如何复制并修改的。</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1604847075199.jpg" alt="basic_data_type_copy" loading="lazy"></figure>
<h3 id="引用数据类型的复制">引用数据类型的复制</h3>
<pre><code class="language-javascript">let m = { a: 10, b: 20 };
let n = m;
n.a = 15;
console.log(m.a) //此时m.a的值是多少，是10？还是15？
</code></pre>
<p>答案是：15</p>
<p>在这个例子中，m、n都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变自动分配一个新的值保存在变量中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改 n.a 的值后，相应的 m.a 也就发生了改变。</p>
<p>从下图可以清晰的看到变量是如何复制并修改的。</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1604847155965.jpg" alt="reference_data_type_copy" loading="lazy"></figure>
<h2 id="栈内存和堆内存的优缺点">栈内存和堆内存的优缺点</h2>
<p>在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。</p>
<p>栈内存由于它的特点，所以它的系统效率较高。堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。</p>
<h2 id="栈内存和堆内存的垃圾回收">栈内存和堆内存的垃圾回收</h2>
<p>栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。</p>
<h2 id="闭包与堆内存">闭包与堆内存</h2>
<p>闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。</p>
<p>我们先来看什么是闭包：</p>
<pre><code class="language-javascript">function A() {
  let a = 1;
  function B() {
      console.log(a);
  }
  return B;
}
let res = A();
</code></pre>
<p>函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p>
<p>函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<pre><code>读者注释：作者此处对于闭包的定义不是很准确，闭包不应该简单地理解成
调用外部函数变量并且被外部函数返回的内部函数，闭包是一个变量对象，
储存着被 被外部函数返回的内部函数 引用着的 外部函数的变量。

以作者给出的例子来讲，内部函数 B 引用着外部函数 A 的变量 a，并且内部
函数 B 被外部函数 A 返回。那么我们称变量集合 { a } 是函数 A 的闭包。
</code></pre>
<blockquote>
<p>本文完</p>
</blockquote>
<blockquote>
<p>作者：云中桥<br>
链接：https://juejin.im/post/6844903873992196110<br>
来源：掘金</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.8 —— 122. 买卖股票的最佳时机 II]]></title>
        <id>https://pineapple126.github.io/post/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-beney-2/</id>
        <link href="https://pineapple126.github.io/post/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-beney-2/">
        </link>
        <updated>2020-11-07T16:22:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一动态规划">方法一：动态规划</h3>
<p>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>
<p>定义状态 <code>dp[i][0]</code> 表示第 i 天交易完后手里没有股票的最大利润，<code>dp[i][1]</code> 表示第 i 天交易完后手里持有一直股票的最大利润（i 从 0 开始）。</p>
<p>考虑 <code>dp[i][0]</code> 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 <code>dp[i-1][0]</code>，或者前一天结束的时候手里持有一支股票，即 <code>dp[i-1][1]</code>，这时候我们要将其卖出，并获得 <code>prices[i]</code> 的收益。因此为了收益最大化，我们列出如下的转移方程：</p>
<pre><code>dp[i][0] = max{dp[i-1][0], dp[i-1][1] + prices[i]}
</code></pre>
<p>再来考虑 <code>dp[i][1]</code>，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code>，或者前一天结束时还没有股票，即 <code>dp[i−1][0]</code>，这时候我们要将其买入，并减少 <code>prices[i]</code> 的收益。可以列出如下的转移方程：</p>
<pre><code>dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}
</code></pre>
<p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 <code>dp[0][0]=0</code>，<code>dp[0][1]=−prices[0]</code>。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 <code>dp[n−1][0]</code> 的收益必然是大于 <code>dp[n−1][1]</code> 的，最后的答案即为 <code>dp[n−1][0]</code>。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    const len = prices.length;
    const dp = Array(len).fill(0).map(x =&gt; Array(2).fill(0));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (let i=1; i&lt;len; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
    }
    return dp[len-1][0];
};
</code></pre>
<p><strong>空间优化</strong></p>
<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0]</code> 和 <code>dp[i−1][1]</code> 存放在两个变量中，通过它们计算出 <code>dp[i][0]</code> 和 <code>dp[i][1]</code> 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    const len = prices.length;
    let dp0 = 0,
        dp1 = -prices[0];
    for (let i=1; i&lt;len; i++) {
        dp0 = Math.max(dp0, dp1 + prices[i]);
        dp1 = Math.max(dp1, dp0 - prices[i]);
    }
    return dp0;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为 O(1)，因此时间复杂度为 O(2n)=O(n)。</li>
<li>空间复杂度：O(n)。我们需要开辟 O(n) 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 O(1)。</li>
</ul>
<h3 id="方法二贪心">方法二：贪心</h3>
<p>虽然「不能同时参与多笔交易」，但是在每一笔交易中我们完全可以<strong>见好就收，积少成多</strong>，因此就有了一个大致的思路：我们可以<strong>在一天中既卖出又买入</strong>。只要第 i 天比第 i-1 天的价格高，就在第 i-1 天买入，并在第 i 天卖出。这样每一次的累计利润必然是最大的。</p>
<p>简而言之：<strong>上升区域，全部都算入利润当中</strong>。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    let profit = 0;
    for (let i=1; i&lt;prices.length; i++) {
        profit += Math.max(0, prices[i] - prices[i-1]);
    }
    return profit;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。我们只需要遍历一次数组即可。</li>
<li>空间复杂度：O(1)。只需要常数空间存放若干变量。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.6 —— 1356. 根据数字二进制下 1 的数目排序 Easy]]></title>
        <id>https://pineapple126.github.io/post/leetcode-sort-integers-by-the-number-of-1-bits/</id>
        <link href="https://pineapple126.github.io/post/leetcode-sort-integers-by-the-number-of-1-bits/">
        </link>
        <updated>2020-11-06T12:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>
<p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<p>示例：</p>
<pre><code>输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一暴力">方法一：暴力</h3>
<p>对每个十进制的数转二进制的时候统计一下 1 的个数即可。</p>
<pre><code class="language-javascript">var sortByBits = function(arr) {
    const countBits = n =&gt; {
        let count = 0;
        while (n &gt; 0) {
            count += n &amp; 1;
            n &gt;&gt; 1;
        }
        return count;
    }
    return arr.sort((a, b) =&gt; {
        return countBits(a) - countBits(b) || a - b;
    });
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 为整数数组 arr 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为整数数组 arr 的长度。</li>
</ul>
<h3 id="解法二递推预处理">解法二：递推预处理</h3>
<p>我们定义 bit[i] 为数字 i 二进制表示下数字 1 的个数，则可以列出递推式：</p>
<pre><code>bit[i] = bit[i&gt;&gt;1] + (i&amp;1)
</code></pre>
<p>所以我们线性预处理 bitbit 数组然后去排序即可。</p>
<pre><code class="language-javascript">var sortByBits = function(arr) {
    const maxVal = arr.sort((a, b) =&gt; b - a)[0];
    const bit = Array(maxVal+1).fill(0);
    for (let i=1; i&lt;=maxVal; i++) {
        bit[i] = bit[i&gt;&gt;1] + (i&amp;1);
    }
    return arr.sort((a, b) =&gt; {
        return bit[a] - bit[b] || a - b;
    });
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 为整数数组 arr 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为整数数组 arr 的长度。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端模块化的十年征程]]></title>
        <id>https://pineapple126.github.io/post/modularization/</id>
        <link href="https://pineapple126.github.io/post/modularization/">
        </link>
        <updated>2020-11-03T16:30:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>文章来源于知乎，作者 外婆的</p>
</blockquote>
<p><strong>这是一篇关于前端模块化的文章，但这里并不讲新技术，而是谈一谈——历史</strong></p>
<blockquote>
<p>夫以铜为镜，可以正衣冠；以史为镜，可以知兴替 ——《旧唐书·魏徵传》</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>也许在谈论具体的内容之前，我们需要谈论一下关键词的定义。 什么是&quot;模块&quot;？在不同的语境下模块有不同的含义。</p>
<p>但在本文中，我们从广义的角度出发，将它解释为两个方面：</p>
<ul>
<li><strong>外部的模块</strong>: 指代引入前端工程的某个外部的包(package),可能由多个JS文件组成，但会通过入口暴露给我们项目调用。</li>
<li><strong>内部的模块</strong>: 指代我们自己的工程项目中编码的最小单元： 即单个的JS文件。</li>
</ul>
<p>模块化已经发展了有十余年了，不同的工具和轮子层出不穷，但总结起来，它们解决的问题主要有三个：</p>
<ul>
<li>外部模块的管理</li>
<li>内部模块的组织</li>
<li>模块源码到目标代码的编译和转换</li>
</ul>
<h2 id="时间线">时间线</h2>
<p>下面是最各大工具或框架的诞生时间，不知不觉，模块化的发展已有十年之久了。</p>
<pre><code> 生态                       诞生时间
 Node.js                    2009 年   
 NPM                        2010 年   
 requireJS(AMD)             2010 年
 seaJS(CMD)                 2011 年
 broswerify                 2011 年
 webpack                    2012 年
 grunt                      2012 年 
 gulp                       2013 年
 react                      2013 年 
 vue                        2014 年
 angular                    2016 年
 redux                      2015 年 
 vite                       2020 年
 snowpack                   2020 年          
</code></pre>
<h2 id="外部模块的管理">外部模块的管理</h2>
<p>在模块化的过程中，首先要解决的就是<strong>外部模块的管理问题</strong>。</p>
<h3 id="nodejs-和-npm-的发布">Node.js 和 NPM 的发布</h3>
<p>时间倒回到2009年，一个叫**莱恩(Ryan Dahl)**的精神小伙创立了一个能够运行 JavaScript 的服务器环境——Node.js，并在一年之后，发布了 Node.js 自带的模块管理工具 npm，npm 的全称是node package manager，也就是 Node 包管理器。</p>
<p>Node 的出现给 JavaScript 的带来了许多改变：</p>
<p>一方面, Node 使 JavaScript 不局限于前端，同时还成为了一门后端语言。更重要的是: 经过 10 年的发展，Node.js 已经完全融入到了前端开发流程中。我们用它创建静态资源服务器，实现热重载和跨域代理等功能，同时还用它源代码中的特殊写法做编译转换处理(JSX/Sass/TypeScript)，将代码翻译成浏览器可以理解的格式(ES5/CSS)。到今天，即使我们不用Node.js独立开发程序后台，它作为开发工具的重要性也不会改变。</p>
<p>另一方面, Node.js 自带的 JS 模块管理工具 npm，从根本上改变了前端使用外部模块的方式，如果要打个比方的话，就好比从原始社会进入了现代社会。</p>
<h3 id="npm-时代以前的外部模块使用方式">NPM 时代以前的外部模块使用方式</h3>
<p>在一开始没有 npm 的时候，如果我们需要在项目里使用某个外部模块，我们可能会去官网直接把文件下载下来放到项目中，同时在入口 html 中通过 script 标签引用它。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1604595619073.jpg" alt="downloading_jquery" loading="lazy"></figure>
<p>每引用一个外部模块，我们都要重复这个过程：</p>
<ol>
<li>需要用到 jQuery，去 jQuery 官网下载 jQuery 库，导入到项目中</li>
<li>需要用到 lodash,去 lodash 官网下载 lodash 库</li>
<li>需要用到某个 BootStrap，去 BootStrap官网官网下载 BootStrap 库，导入到项目中</li>
<li>...</li>
</ol>
<p>除了这些全局的 UI 库或工具库，我们可能还会使用到很多实现细节功能的辅助模块，如果都按这种方式使用未免过于粗暴，而且给我们带来许多麻烦：</p>
<ul>
<li>使用上缺乏便利性</li>
<li>难以跟踪各个外部模块的来源</li>
<li>没有统一的版本管理机制</li>
</ul>
<p>而 npm 的出现改变了这种情况。</p>
<h3 id="npm-时代以后外部模块的使用方式">NPM 时代以后外部模块的使用方式</h3>
<p>我们上面说过，NPM 在2010年伴随着 Node.js 的新版本一起发布，是一个 Node 自带的模块管理工具。</p>
<p>从概念上看它由以下两个部分组成：</p>
<ul>
<li>NPM 是一个远程的 JavaScript 代码仓库，所有的开发者都可以向这里提交可共享的模块，并给其他开发者下载和使用</li>
<li>NPM还包含一个命令行工具，开发者通过运行 npm publish 命令把自己写的模块发布到 NPM 仓库上去，通过运行 npm install [模块名]，可以将别人的模块下载到自己项目根目录中一个叫 node_modules 的子目录下</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1604421836062.jpg" alt="npm_install" loading="lazy"></figure>
<p>每次 npm install 的时候，都会在 package.json 这个文件中更新模块和对应的版本信息。</p>
<pre><code class="language-json">// package.json
{ 
    ...
    &quot;dependencies&quot;: {
        &quot;bootstrap&quot;: &quot;^4.5.2&quot;,
        &quot;jquery&quot;: &quot;^3.5.1&quot;
    }
}
</code></pre>
<p>于是乎，包括 jQuery 等知名模块开发者的前端工程师们，都通过 npm publish 的方式把自己的模块发布到 NPM 上去了。前端开发者们真正有了一个属于自己的社区和平台，如万千漂泊游船归于港湾，而 NPM 也名声渐噪。</p>
<p>早在 2019 年 6 月，NPM 平台上的模块数量就超过了 100 万，而到写下这篇文章的时候，NPM 模块数量已超过了 140 万。</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1604422887037.jpg" alt="npm_website" loading="lazy"></figure>
<p>NPM 的出现实际上是一个必然，前端工程的复杂化要求我们必须要有这么一个集中的 JS 库管理平台。但为什么它会是 NPM 呢？这和后来 Node.js 的火热有很大关系，因为 NPM 是 Node.js 内置的包管理器，所以跟随着 Node 得到了开发者的追捧。</p>
<p>综上所述，NPM 解决了外部模块的管理问题。</p>
<h2 id="内部模块的组织">内部模块的组织</h2>
<p>在模块化的过程中，还需要解决的是内部模块的组织问题。</p>
<h3 id="模块化第一阶段原生-js-组织阶段">模块化第一阶段：原生 JS 组织阶段</h3>
<p>在最原始的时代，我们是通过下面这种方式组织我们的模块代码的，将不同的 JS 文件在 html 中一一引入。每个文件代表一个模块</p>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;script src=&quot;./a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./b.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./c.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./d.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>并通过模块模式去组织代码：如下所示，我们通过一个“立即调用的函数表达式”(IIFE)去组织模块</p>
<ul>
<li>将每个模块包裹在一个函数作用域里面执行，这样就可以最大程度地避免污染全局执行环境</li>
<li>通过执行匿名函数得到模块输出，可以暴露给下面的其他模块使用</li>
</ul>
<pre><code class="language-html">&lt;script&gt;
    var module1 = (function () {
    var x = 1;
    return { a: x };
  })();
&lt;/script&gt;
&lt;script&gt;
    var module2 = (function () {
    var a = module1.a;   
    return { b: a };
 })();
&lt;/script&gt;
</code></pre>
<p>但这种使用方式仍然比较粗暴</p>
<ul>
<li>随着项目扩大，html文件中会包含大量script标签。</li>
<li>script标签的先后顺序并不能很好地契合模块间的依赖关系。在复杂应用中，模块的依赖关系通常树状或网状的，如a.js依赖于b.js和c.js，b.js依赖于b1.js和b2.js。相对复杂的依赖关系难以用script标签的先后顺序组织。</li>
<li>让代码的逻辑关系难以理解，也不便于维护，容易出现某个脚本加载时依赖的变量尚未加载而导致的错误。</li>
<li>因为对script标签顺序的要求而使用同步加载，但这却容易导致加载时页面卡死的问题。</li>
<li>仍然会因为全局变量污染全局环境，导致命名冲突。</li>
</ul>
<p>我们需要针对这些问题提出解决方案，<strong>而 AMD 和 CMD 就是为解决这些问题而提出的规范</strong>。</p>
<h3 id="模块化的第二阶段在线处理阶段">模块化的第二阶段：在线处理阶段</h3>
<h4 id="模块化规范的野蛮生长">模块化规范的野蛮生长</h4>
<p>10 多年以前，前端模块化刚刚开始，正处在野蛮生长的阶段。这个过程中诞生了诸多模块化规范: AMD/CMD/CommonJS/ES6 Module。没错，前端并没有一开始就形成统一的模块化规范，而是多个规范同时多向发展。直到某一类规范占据社区主流之时，模块化规范野蛮生长的过程才宣告结束。</p>
<p>首先开始在前端流行的模块化规范是 AMD/CMD, 以及实践这两种规范的 require.js 和 Sea.js, AMD 和 CMD 可看作是&quot;<strong>在线处理</strong>&quot;模块的方案，也就是等到用户浏览 web 页面下载了对应的require.js和sea.js文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。模块组织过程在线上进行。</p>
<h4 id="amd-cmd">AMD &amp;&amp; CMD</h4>
<blockquote>
<p>AMD 和 CMD 只是一种设计规范，而不是一种实现。</p>
</blockquote>
<h4 id="amd">AMD</h4>
<p>我们先来说下 AMD，它的全称是 <code>Asynchronous Module Definition</code>，即“异步模块定义”。它是一种组织前端模块的方式。</p>
<p><strong>AMD的理念可以用如下两个API概括： define和require</strong></p>
<p><strong>define</strong> 方法用于定义一个模块，它接受两个参数：</p>
<ul>
<li>第一个参数是一个数组，表示这个模块所依赖的其他模块</li>
<li>第二个参数是一个方法，这个方法通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，同时将返回值传递给依赖它的其他模块使用。</li>
</ul>
<pre><code class="language-javascript">// module0.js
define(['Module1', 'Module2'], function (module1, module2) {
    var result1 = module1.exec();
    var result2 = module2.exec();
    return {
      result1: result1,
      result2: result2
    }
});    
</code></pre>
<p><strong>require</strong> 用于真正执行模块，通常 AMD 框架会以 require 方法作为入口，进行依赖关系分析并依次有序地进行加载。</p>
<pre><code class="language-javascript">// 入口文件
require(['math'], function (math) {
　 math.sqrt(15)
});
</code></pre>
<p><strong>define &amp;&amp; require 的区别</strong></p>
<p>可以看到 define 和 require 在依赖模块声明和接收方面是一样的，它们的区别在于 define 能自定义模块而 require 不能，require 的作用是执行模块加载。</p>
<p><strong>通过 AMD 规范组织后的 JS 文件看起来像下面这样</strong></p>
<p>depModule.js</p>
<pre><code class="language-javascript">define(function () {
  return printSth: function () {
    alert(&quot;some thing&quot;)
  }
});
</code></pre>
<p>app.js</p>
<pre><code class="language-javascript">define(['depModule'], function (mod) {
  mod.printSth();
});
</code></pre>
<p>index.html</p>
<pre><code class="language-html">&lt;!-- amd.js意为某个实现了AMD规范的库 --&gt;
&lt;script src=&quot;...amd.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  require(['app'], function (app) {
    // ...入口文件
  })
&lt;/script&gt;
</code></pre>
<p>我们可以看到，AMD 规范去除了纯粹用 script 标签顺序组织模块带来的问题：</p>
<ol>
<li>通过依赖数组的方式声明依赖关系，具体依赖加载交给具体的 AMD 框架处理</li>
<li>避免声明全局变量带来的环境污染和变量冲突问题</li>
<li>正如 AMD 其名所言(Asynchronous), 模块是异步加载的，防止 JS 加载阻塞页面渲染</li>
</ol>
<p><strong>遵循AMD规范实现的模块加载器</strong></p>
<p>我们前面说过，AMD 只是一个倡议的规范，那么它有哪些实现呢？</p>
<p>根据史料记载，AMD 的实现主要有两个: requireJS 和 curl.js, 其中 requireJS 在2010年推出，是 AMD 的主流框架。</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1604588072430.jpg" alt="requirejs" loading="lazy"></figure>
<pre><code>官网: https://requirejs.org/
</code></pre>
<h4 id="cmd">CMD</h4>
<p>CMD 是除 AMD 以外的另外一种模块组织规范。CMD 即 <code>Common Module Definition</code>，意为“通用模块定义”。</p>
<p>和 AMD 不同的是，CMD 没有提供前置的依赖数组，而是接收一个 factory 函数，这个 factory 函数包括 3 个参数：</p>
<ul>
<li><strong>require</strong>: 一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>
<li><strong>exports</strong>: 一个对象，用于对其他模块提供输出接口，例如：exports.name = &quot;xxx&quot;</li>
<li><strong>module</strong>: 一个对象，存储了当前模块相关的一些属性和方法，其中 module.exports 属性等同于上面的 exports</li>
</ul>
<p>如下所示</p>
<pre><code class="language-javascript">// CMD
define(function (requie, exports, module) {
    //依赖就近书写
    var module1 = require('Module1');
    var result1 = module1.exec();
    module.exports = {
      result1: result1,
    }
});

// AMD
define(['Module1'], function (module1) {
    var result1 = module1.exec();
    return {
      result1: result1,
    }
}); 
</code></pre>
<p><strong>CMD &amp;&amp; AMD的区别</strong></p>
<p>从上面的代码比较中我们可以得出 AMD 规范和 CMD 规范的区别：</p>
<p>一方面，在依赖的处理上</p>
<ul>
<li>AMD 推崇依赖前置，即通过依赖数组的方式提前声明当前模块的依赖</li>
<li>CMD 推崇依赖就近，在编程需要用到的时候通过调用 require 方法动态引入</li>
</ul>
<p>另一方面，在本模块的对外输出上</p>
<ul>
<li>AMD 推崇通过返回值的方式对外输出</li>
<li>CMD 推崇通过给 module.exports 赋值的方式对外输出</li>
</ul>
<p><strong>遵循CMD规范实现的模块加载器</strong></p>
<p>sea.js 是遵循 CMD 规范实现的模块加载器，又或者更准确的说法是: CMD 正是在 sea.js 推广的过程中逐步确立的规范，并不是 CMD 诞生了 sea.js。相反，是 sea.js 诞生了 CMD</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1604588468864.jpg" alt="seajs" loading="lazy"></figure>
<blockquote>
<p>CMD 和 AMD 并不是互斥的，require.js 和 sea.js 也并不是完全不同，实际上，通过阅读 API 文档我们会发现，CMD 后期规范容纳了 AMD 的一些写法。</p>
</blockquote>
<p><strong>AMD &amp;&amp; CMD背后的实现原理</strong></p>
<p>下面以 sea.js 为例</p>
<ol>
<li>解析 define 方法内的 require 调用</li>
</ol>
<p>我们之前说过, sea.js 属于 CMD, 所以它的依赖是就近获取的，</p>
<p>所以 sea.js 会多做一项工作：也就是对 define 接收方法体内 require 调用的解析。</p>
<p>先定义 parseDependencies 方法: 通过正则匹配获取字符串中的 require 中的参数并存储到数组中返回</p>
<pre><code class="language-javascript">var REQUIRE_RE = /&quot;(?:\\&quot;|[^&quot;])*&quot;|'(?:\\'|[^'])*'|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&quot;'])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []
  code.replace(SLASH_RE, &quot;&quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
</code></pre>
<p>然后通过 toString 将 define 接收的方法转化为字符串，然后调用 parseDependencies 解析。这样我们就获取到了一个 define 方法里面所有的依赖模块的数组</p>
<pre><code class="language-javascript">// Parse dependencies according to the module factory code
if (!isArray(deps) &amp;&amp; isFunction(factory)) {
    deps =  parseDependencies(factory.toString())
}     
</code></pre>
<ol start="2">
<li>然后 Sea.js 执行的时候，会从入口开始遍历依赖模块，并依次将它们加载到浏览器中，加载方法如下所示。</li>
</ol>
<pre><code class="language-javascript">function request(url, callback, charset, crossorigin) {
  var node = doc.createElement(&quot;script&quot;)
  addOnload(node, callback, url) // 添加回调，回调函数在 3 中
  node.async = true //异步
  node.src = url
  head.appendChild(node)
}         
</code></pre>
<p>而且在每个依赖加载完后都会通过回调的方式调用3中的onload方法</p>
<ol start="3">
<li>在 onload 方法中，sea.js 会设置一个计数变量 remain，用来计算依赖是否加载完毕。每加载完一个模块就执行 remain - 1 操作，并通过 remain === 0 判断依赖是否全部加载完毕。</li>
</ol>
<p>如果全部加载完毕就执行4中的 mod.callback 方法</p>
<pre><code class="language-javascript">Module.prototype.onload = function() {
  var mod = this
  mod.status = STATUS.LOADED 
  for (var i = 0, len = (mod._entry || []).length; i &lt; len; i++) {
    var entry = mod._entry[i]
    if (--entry.remain === 0) {
      entry.callback()
    }
  }
  delete mod._entry
}           
</code></pre>
<blockquote>
<p>大概因为 require.js 出来比较早的原因，所以没有用 Promise.all 一类的 API</p>
</blockquote>
<ol start="4">
<li>当判断 entry.remain === 0 时，也即依赖模块全部加载完毕时，会调用一开始 callback 方法，去依次执行加载完毕的依赖模块，并将输出传递给 use 方法回调</li>
</ol>
<pre><code class="language-javascript">// sea.js的use方法类似于AMD规范中的require方法,用于执行入口函数
Module.use = function (ids, callback, uri) {
  var mod = Module.get(uri, isArray(ids) ? ids : [ids])
  mod.callback = function() {
    var exports = []
    var uris = mod.resolve();
    // 依次执行加载完毕的依赖模块，并将输出传递给use方法回调
    for (var i = 0, len = uris.length; i &lt; len; i++) {
      exports[i] = cachedMods[uris[i]].exec()
   }
   // 执行use方法回调
   if (callback) {
      callback.apply(global, exports)
   }
  }
}
</code></pre>
<pre><code>参考资料： https://segmentfault.com/a/1190000016001572    
</code></pre>
<h4 id="es6-的模块化风格">ES6 的模块化风格</h4>
<p>关于 AMD/CMD 的介绍到此为止，后面的事情我们都知道了，伴随着 babel 等编译工具和 webpack 等自动化工具的出现，AMD/CMD 逐渐湮没在历史的浪潮当中，然后大家都习惯于用 CommonJS 和 ES6 的模块化方式编写代码了。</p>
<p>这一切是怎么发生的呢？ 请看</p>
<h5 id="commonjs-es6">CommonJS &amp;&amp; ES6</h5>
<p>CommonJS 是 Node.js 使用的模块化方式，而 import/export 则是 ES6 提出的模块化规范。它们的语法规则如下。</p>
<pre><code class="language-javascript"> // ES6
import { foo } from './foo'; // 输入
export const bar = 1;        // 输出

// CommonJS
const foo = require('./foo'); // 输入
module.exports = { 。         // 输出
    bar:1
}
</code></pre>
<p>实际上我们能感觉到，这种模块化方式用起来比CMD/AMD方便。</p>
<p>但在最开始的时候，我们却不能在前端页面中使用它们，因为浏览器并不能理解这种语法。</p>
<p><strong>但后来，编译工具babel的出现让这变成了可能</strong></p>
<h5 id="babel的出现和es6模块化的推广">babel的出现和ES6模块化的推广</h5>
<p>在2014年十月，babel1.7 发布。babel 是一个 JavaScript 编译器，它让我们能够使用符合开发需求的编程风格去编写代码，然后通过babel的编译转化成对浏览器兼容良好的 JavaScript。</p>
<p>Bablel 的出现改变了我们的前端开发观点。它让我们意识到：对前端项目来说，开发的代码和生产的前端代码可以是不一样的，也应该是不一样的。</p>
<ul>
<li>在开发的时候，我们追求的是编程的便捷性和可阅读性。</li>
<li>而在生产中，我们追求的是代码对各种浏览器的兼容性。</li>
</ul>
<p>babel 编译器让我们能做到这一点。在 babel 出现之前的 AMD/CMD 时代，开发和生产的代码并没有明显的区分性，开发是怎样的生产出来后也就是怎样的。</p>
<p>而 babel 则将开发和生产这两个流程分开了，同时让我们可以用 ES6 中的 import/export 进行模块化开发。</p>
<p>至此，AMD/CMD 的时代宣告结束，ES6 编程的时代到来.</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1604594624961.jpg" alt="babel" loading="lazy"></figure>
<h5 id="babel-的工作原理">Babel 的工作原理</h5>
<p>Babel 的工作流程可概括为三个阶段:</p>
<ul>
<li><strong>Parse</strong>(解析): 通过词法分析和语法分析，将源代码解析成抽象语法树(AST)</li>
<li><strong>Transform</strong>(转换)：对解析出来的抽象语法树做中间转换处理</li>
<li><strong>Generate</strong>(生成)：用经过转换后的抽象语法树生成新的代码</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1604594788324.jpg" alt="babel_principle" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1604594814444.jpg" alt="babel_principle2" loading="lazy"></figure>
<h3 id="模块化的第三阶段预处理阶段">模块化的第三阶段：预处理阶段</h3>
<p>现在时间来到了 2013 年左右，AMD/CMD 的浪潮已经逐渐退去，模块化的新阶段——预编译阶段开始了。</p>
<p>一开始的CMD/AMD方案，可看作是“<strong>在线编译</strong>”模块的方案，也就是等到用户浏览 web 页面下载了 js 文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。但这样却不可避免的带来了一些问题：</p>
<ul>
<li>在线组织模块的方式会延长前端页面的加载时间，影响用户体验。</li>
<li>加载过程中发出了海量的http请求，降低了页面性能。</li>
</ul>
<p><strong>于是开发者们想了对应的方法去解决这些问题：</strong></p>
<ul>
<li>开发一个工具，让它把组织模块的工作提前做好，在代码部署上线前就完成，从而节约页面加载时间</li>
<li>使用工具进行代码合并，把多个script的代码合并到少数几个script里，减少http请求的数量。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1604595124513.jpg" alt="pretreatment" loading="lazy"></figure>
<p>在这样的背景下，一系列模块预处理的工具如雨后春笋般出现了。</p>
<p>典型的代表是 2011 年出现的 <strong>broswerify</strong> 和 2012 年发明的 <strong>webpack</strong>。</p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1604595379830.jpg" alt="broswerify_webpack" loading="lazy"></figure>
<p>它们一开始的定位是类似的，都是通过预先打包的方式，把前端项目里面的多个文件打包成单个文件或少数几个文件，这样的话就可以压缩首次页面访问时的http请求数量，从而提高性能。</p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1604595239383.jpg" alt="bundle" loading="lazy"></figure>
<p>当然后面的事情我们都知道了，webpack 因为发展得更好而占据了主流的前端社区，而 broswerify 则渐渐消失在红尘之中。</p>
<p><strong>broswerify</strong></p>
<p>以 broswerify 为例，我们可以通过npm安装它</p>
<pre><code>npm install -g broswerify
</code></pre>
<p>broswerify 允许我们通过 CommonJS 的规范编写代码，例如下面的入口文件 main.js</p>
<pre><code class="language-javascript">// main.js
var a = require('./a.js');
var b = require('./b.js');
...     
</code></pre>
<p>然后我们可以用 broswerify 携带的命令行工具处理 main.js，它会自动分析依赖关系并进行打包,打包后会生成集合文件 bundle.js。</p>
<pre><code>broswerify main.js -o bundle.js     
</code></pre>
<p><strong>webpack</strong></p>
<p>webpack 是自 broswerify 出现一年以后，后来居上并占据主流的打包工具。webpack 内部使用 babel 进行解析，所以 ES6 和 CommonJS 等模块化方式是可以在 webpack 中自由使用的。</p>
<p>通过安装 webpack 这一 npm 模块便可使用 webpack 工具</p>
<pre><code class="language-javascript">npm install --save-dev webpack
</code></pre>
<p>它要求我们编写一份名为 webpack.config.js 的配置文件，并以 entry 字段和 output 字段分别表示打包的入口和输出路径</p>
<pre><code class="language-javascript">// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {   
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }
};   
</code></pre>
<p>打包完毕后，我们的index.html只需要加载bundle.js就可以了。</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
    &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;   
</code></pre>
<h4 id="打包工具面临的问题-解决方案">打包工具面临的问题 &amp;&amp; 解决方案</h4>
<p>代码打包当然不是一本万利的，它们也面临着一些副作用带来的问题，其中最主要的就是打包后代码体积过大的问题</p>
<p>代码打包的初衷是减少类似 CMD 框架造成的加载脚本(http 请求)数量过多的问题，但也带来了打包后单个 script 脚本体积过大的问题：如此一来，首屏加载会消耗很长时间并拖慢速度，可谓是物极必反。</p>
<p>webpack 于是引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包</p>
<blockquote>
<p>虽然允许拆多个包了，但包的总数仍然比较少，比 CMD 等方案加载的包少很多</p>
</blockquote>
<p><strong>Code Splitting有可分为两个方面的作用：</strong></p>
<ul>
<li><strong>一是实现第三方库和业务代码的分离</strong>：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度</li>
<li><strong>二是实现按需加载</strong>: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。</li>
</ul>
<p><strong>A. 实现第三方库和业务代码的分离</strong></p>
<p>这种代码拆分可通过 webpack 独特的插件机制完成。plugins 字段是是一个数组，可接收不同的plugins 实例，从而给 webpack 打包程序附加不同的功能，CommonsChunkPlugin 就是一个实现代码拆分的插件。</p>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: 'commons',        // the commons chunk name
      filename: 'commons.js', // the filename of the commons chunk)
      minChunks: 3,           // Modules must be shared between 3 entries
    });
  ]
};          
</code></pre>
<p>通过上面的配置，webpack 在执行打包的时候会把被引用超过 3 次的依赖文件视为&quot;公共文件&quot;，并单独打包到 commons.js 中，而不是打包到主入口文件里。</p>
<p>对于 React，Redux,lodash 这些第三方库，因为引用次数远远超过 3 次，当然也是会被打包到common.js 中去的。</p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1604595944743.jpg" alt="bundle2" loading="lazy"></figure>
<p><strong>B. 实现按需加载</strong></p>
<p>正如其字面意思，按需加载就是等到需要的时候才加载一部分模块。并不选择将其代码打包到首次加载的入口bundle 中，而是等待触发的时机，届时才通过动态脚本插入的方式进行加载: 即创建 script 元素，添加脚本链接并通过 appendChild 加入到 html 元素中</p>
<p>例如我们需要实现一个功能，在点击某个按钮的时候，使用某个模块的功能。这时我们可以使用 ES6 的import 语句动态导入，webpack 会支持 import 的功能并实现按需加载</p>
<pre><code class="language-javascript">button.addEventListener('click',function(){
  import('./a.js').then(data =&gt; {
    // use data
  })
});
</code></pre>
<h3 id="模块化的第四阶段自动化构建阶段">模块化的第四阶段：自动化构建阶段</h3>
<p>正当打包工具方兴未艾的时候，另外一个发展浪潮也几乎在同步发生着。</p>
<p>它就是 —— 全方位的自动化构建工具的发展。</p>
<p>什么叫自动化构建工具呢？ 简单的说就是： 我们需要这样一个工具，专门为开发过程服务，尽可能满足我们开发的需求，提高开发的效率。</p>
<p>前面说过，在模块化的过程中，我们渐渐有了“开发流程”和“生产流程”的区分，而自动化构建工具就是在开发流程中给开发者最大的自由度和便捷性，同时在生产流程中能保证浏览器兼容性和良好性能的工具。而所有的功能已经由插件直接提供，所以被称作“自动化” 构建工具。</p>
<figure data-type="image" tabindex="13"><img src="https://pineapple126.github.io//post-images/1604596105632.jpg" alt="automation" loading="lazy"></figure>
<p>在这时，我们已经不再满足于“打包”这个功能了，我们渴望做更多的事情：</p>
<ul>
<li>开发时使用丰富且方便的 JS 新特性，如用 ES6，typescript 编程，由自动化构建工具转化成浏览器兼容的 ES5 格式的 JS 代码</li>
<li>用Sass，less 编写阅读性和扩展性良好的样式代码，由自动化构建工具转化成浏览器兼容的 CSS 代码</li>
<li>提供开发时 SourceMap 功能，也即提供生产代码(如 ES5)到源代码(typescript)的映射，方便开发调试</li>
<li>提供生产时代码压缩功能，压缩js和css，删除注释，替换变量名(长变短)，减少代码加载体积</li>
<li>提供开发热重载功能(Hot Module Reload), 也即在编辑器保存代码的时候自动刷新浏览调试页面。</li>
<li>当然也还包括基本的模块打包功能</li>
<li>其他.....</li>
</ul>
<p><strong>自动化构建工具的代表性工具有三个，分别是</strong></p>
<ul>
<li>2012年出现的 <strong>webpack</strong></li>
<li>2012年出现的 <strong>grunt</strong></li>
<li>2013年出现的 <strong>gulp</strong></li>
</ul>
<blockquote>
<p>下图中，左中右分别是gulp, grunt 和 webpack</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://pineapple126.github.io//post-images/1604596267079.jpg" alt="gulp_grunt_webpack" loading="lazy"></figure>
<p>这一次，webpack 并没有止步于成为一个单纯的打包工具，而是参与到自动化构建的浪潮里，并且成为了最后的赢家。而 grunt 和 gulp 则像过去的 Sea.js,Require.js 等工具一样。逐渐地从热潮中隐退，静静地待在前端社区里的一方僻静的角落里</p>
<h4 id="gulp-webpack">gulp &amp;&amp; webpack</h4>
<p>因为篇幅关系，我们下面只来介绍下 gulp 和 webpack 这两个自动化构建工具。</p>
<h5 id="gulp-和-webpack-的区别">gulp 和 webpack 的区别</h5>
<p>对于使用者来说，gulp 和 webpack 最大的区别也许在它们的使用风格上</p>
<ul>
<li>gulp 是编程式的自动化构建工具</li>
<li>webpack 是配置式的自动化构建工具<br>
下面我们以 less 代码的编译为例，展示 Gulp 和 webpack 的区别</li>
</ul>
<p><strong>Gulp</strong></p>
<p>Gulp 基本的风格是编程式的, 它是一种基于流即 Node.js 封装起来的 stream 模块的自动化构建工具，一般先通过 gulp.src 将匹配的文件转化成stream(流)的形式，然后通过一连串的 pipe 方法进行链式的加工处理处理，对后通过 dest 方法输出到指定路径。</p>
<pre><code class="language-javascript">// gulpfile.js
const { src, dest } = require('gulp');
const less = require('gulp-less');
const minifyCSS = require('gulp-csso');

function css() {
  return src('client/templates/*.less')
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(dest('build/css'))
}             
</code></pre>
<p><strong>Webpack</strong></p>
<p><strong>webpack</strong> 的基本风格则是配置式的，它通过 loader 机制实现文件的编译转化。通过配置一组 loader 数组，每个 loader 会被链式调用，处理当前文件代码后输出给下一个 loader, 全部处理完毕后进行输出</p>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/, // 正则匹配less文件
        use: [
          { loader: 'style-loader' }, // creates style nodes from JS strings
          { loader: 'css-loader' },   // translates CSS into CommonJS
          { loader: 'less-loader' },  // compiles Less to CSS
        ],
      },
    ],
  },
};       
</code></pre>
<h5 id="gulp-和-webpack-的共同点">gulp 和 webpack 的共同点</h5>
<p>gulp 和 webpack 并没有自己完成所有的功能，而是搭建起一个平台，吸引世界各地的开发者们贡献插件，并构建起来一个繁荣的生态。</p>
<p>从提供的功能上看，gulp 和 webpack 在很多方面是类似的,这从它们的相关生态上也可以看得出来</p>
<p><strong>Gulp</strong></p>
<ul>
<li>gulp-uglify : 压缩js文件</li>
<li>gulp-less : 编译less</li>
<li>gulp-sass：编译sass</li>
<li>gulp-livereload : 实时自动编译刷新</li>
<li>gulp-load-plugins：打包插件</li>
</ul>
<p><strong>Webpack</strong></p>
<ul>
<li>uglifyjs-webpack-plugin: 压缩js文件</li>
<li>less-loader: 编译less</li>
<li>sass-loader： 编译sass</li>
<li>devServer.hot配置为true: 实时自动编译刷新</li>
<li>....</li>
</ul>
<h5 id="gulp-的没落和-webpack-的兴起">Gulp 的没落和 webpack 的兴起</h5>
<p>经过了七八年的发展，webpack 逐渐取代了 gulp 成为前端开发者的主流自动化构建工具。</p>
<p><strong>究其原因</strong></p>
<ul>
<li>一方面，是因为 gulp 是编程式的，webpack 是配置式的，webpack 用起来更加简单方便，上手难度相对低一些，所以得到众多开发者的喜欢</li>
<li>另一方面，从 2014 年 React,Vue 等 SPA 应用的热潮兴起后，webpack 和它们的结合性更好，所以也助长了 webpack 生态的繁荣</li>
</ul>
<p><strong>模块化的故事，到这里就先告一段落了。</strong></p>
<h4 id="十年征程前端模块化终于从呱呱坠地到长大成人">十年征程，前端模块化终于从呱呱坠地到长大成人,</h4>
<figure data-type="image" tabindex="15"><img src="https://pineapple126.github.io//post-images/1604596780777.jpg" alt="modularization" loading="lazy"></figure>
<p><strong>自动构建工具的新趋势：bundleless</strong></p>
<p><strong>webpack 之所以在诞生之初采用集中打包方式进行开发，有几个方面的原因</strong>:</p>
<ul>
<li>一是浏览器的兼容性还不够良好，还没提供对 ES6 的足够支持(import|export)，需要把每个 JS 文件打包成单一 bundle 中的闭包的方式实现模块化</li>
<li>二是为了合并请求，减少 HTTP/1.1 下过多并发请求带来的性能问题</li>
</ul>
<p><strong>而发展到今天，过去的这些问题已经得到了很大的缓解，因为</strong></p>
<ul>
<li>主流现代浏览器已经能充分支持 ES6 了,import 和 export 随心使用</li>
<li>HTTP2.0 普及后并发请求的性能问题没有那么突出了</li>
</ul>
<p>bundleless 就是把开发中拖慢速度的打包工作给去掉，从而获得更快的开发速度。代表性工具是 vite 和 snowpack.</p>
<figure data-type="image" tabindex="16"><img src="https://pineapple126.github.io//post-images/1604596992861.jpg" alt="snowpack_vite" loading="lazy"></figure>
<ul>
<li><strong>vite</strong>: 尤雨溪开发的 bundleless 工具，能很好的配合 Vue 框架的开发，github 上 star 为 11k</li>
<li><strong>snowpack</strong>: 另一个 bundleless 工具，目前框架生态更广泛一些，支持 React/Vue/Svelte，github 上 star 为11.9k</li>
</ul>
<p>具体的内容介绍可看之前写的一篇文章，这里暂不多介绍了</p>
<blockquote>
<p>本文完。</p>
</blockquote>
<hr>
<blockquote>
<p>作者：外婆的<br>
链接：https://zhuanlan.zhihu.com/p/265632724<br>
来源：知乎</p>
</blockquote>
]]></content>
    </entry>
</feed>