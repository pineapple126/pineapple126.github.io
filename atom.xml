<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pineapple126.github.io/</id>
    <title>深海大菠萝盖饭</title>
    <updated>2020-09-16T05:24:30.397Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pineapple126.github.io/"/>
    <link rel="self" href="https://pineapple126.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://pineapple126.github.io/images/avatar.png</logo>
    <icon>https://pineapple126.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 深海大菠萝盖饭</rights>
    <entry>
        <title type="html"><![CDATA[《透视 HTTP 协议》学习记录——破冰篇]]></title>
        <id>https://pineapple126.github.io/post/http-study-route-1/</id>
        <link href="https://pineapple126.github.io/post/http-study-route-1/">
        </link>
        <updated>2020-04-14T03:48:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-http-的前世今生">1. HTTP 的前世今生</h2>
<h3 id="创世纪">创世纪</h3>
<p>1989 年，任职于欧洲核子研究中心的<strong>蒂姆·伯纳斯 - 李（Tim Berners-Lee）<strong>在他的论文中提出了</strong>在互联网上构建超链接文档系统的构想</strong>。在论文中他确立了三项关键技术：</p>
<ol>
<li>URI（Uniform Resource Identifier），即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML（HyperText Markup Language），即超文本标记语言，描述超文本文档；</li>
<li>HTTP（HyperText Transfer Protocol），即超文本传输协议，用来传输超文本。</li>
</ol>
<p>因此可以说，“HTTP”是在这一年诞生的。</p>
<h3 id="http09">HTTP/0.9</h3>
<p>20 世纪 90 年代初期，网络上绝大多数资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>
<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器与客户端处理，也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都只是可读的，所以只允许使用 “GET”动作从服务器上获取 HTML 文档，并在响应之后立即关闭连接，功能有限。</p>
<p>HTTP/0.9 虽然简单，但是它作为一个“原型”，充分验证了 Web 服务的可行性。</p>
<h3 id="http10">HTTP/1.0</h3>
<p>1993 年，NCSA（美国国家超级计算应用中心）开发出了第一个可以图文混排的浏览器 Mosaic，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，JEPG 图像格式和 MP3 音乐格式等计算机多媒体技术被发明出来，成功吸引了广大网民的热情，更多的人开始使用互联网，研究 HTTP 并提出改进意见。</p>
<p>于是在这些已有实践的基础上，经过一系列草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，例如：</p>
<ul>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能错误的原因；</li>
<li>引入了协议版本号的概念；</li>
<li>引入了 HTTP Header 的概念，让 HTTP处理请求和响应更加灵活；</li>
<li>传输的数据不再局限于文本。</li>
</ul>
<p>但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力。</p>
<p>小贴士：HTTP/1.0 的 RFC 编号是 1945，而 HTTP/0.9 则没有 RFC 。</p>
<h3 id="http11">HTTP/1.1</h3>
<p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”。这一场“战役”推动了 Web 的发展，HTTP/1.0 在这个过程中经受住了考验。于是在“浏览器大战”结束后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十年的传奇。</p>
<p>HTTP/1.1 虽然是对 HTTP/1.0 的修正，但一个重要区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上的所有浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一次“立法&quot;。</p>
<p>HTTP/1.1 主要变更有：</p>
<ul>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ul>
<p>由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分为六分较小的文档，编号为 7230 - 7235，优化了一些细节，没有什么实质性的改动。</p>
<h3 id="http2">HTTP/2</h3>
<p>互联网标准化组织以 Google 推出的 SPDY 协议为基础制定新版本的 HTTP 协议，在 2015 年发布了 HTTP/2，RFC 编号 7540。</p>
<p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做出了很大的努力，主要特点有：</p>
<ul>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求通信加密。</li>
</ul>
<p>目前，HTTP/2 的普及率还比较低，大多数网站使用的仍然是 HTTP/1.1。</p>
<h3 id="http3">HTTP/3</h3>
<p>在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC。</p>
<p>2018 年，互联网标准化组织提议将 “HTTP over QUIC”更名为 “HTTP/3”并获得批准，HTTP/3 正式进入标准化制定阶段。</p>
<h2 id="2-http-是什么http-又不是什么">2. HTTP 是什么？HTTP 又不是什么？</h2>
<h3 id="http-是什么">HTTP 是什么？</h3>
<p>HTTP（HyperText Transfer Protocol），即超文本传输协议。它可以分解为三部分：<strong>超文本</strong>、<strong>传输</strong>和<strong>协议</strong>。我们从后向前逐个解析，来理解这三个词。</p>
<ol>
<li>
<p>“<strong>协议</strong>”：在现实生活中，“协议”意味着两个及以上参与者为了达成某个共同目的而对彼此的一种行为约定或规范。在这里，<strong>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</strong></p>
</li>
<li>
<p>“<strong>传输</strong>”：HTTP 是一个“<strong>传输协议</strong>”，所谓“传输”（Transfer），就是把一堆东西从 A 点搬到 B 点，或者是从 B 点搬到 A 点，即 “A &lt;===&gt; B”。这里包含了两项重要信息：一、HTTP 协议是一个“<strong>双向协议</strong>”。二、数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 两个角色，允许中间有“中转”或“接力”。（如：A &lt;=&gt; X &lt;=&gt; Y &lt;=&gt; Z &lt;=&gt; B）因此，<strong>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</strong></p>
</li>
<li>
<p>“<strong>超文本</strong>”：所谓“文本”，就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分杂乱无章的二进制包（datagram），而是完整的，有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。而所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p>
</li>
</ol>
<p>综上所述，我们可以给出比“超文本传输协议”这七个字更准确更具有技术含量的解释：<strong>HTTP 是一个在计算机世界里专门用来在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</strong></p>
<h3 id="http-不是什么">HTTP 不是什么？</h3>
<p>“HTTP 不是什么？”等价于询问“HTTP 不能干什么？”</p>
<p>HTTP 不是互联网，但是 HTTP 是构建互联网的一块重要拼图，而且是比重最大的一块。</p>
<p>HTTP 不是编程语言，而是计算机与计算机沟通交流的语言。</p>
<p>HTTP 也不是一个孤立的协议，HTTP 协议通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠的数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。这些协议相互交织，构成了一个协议网，而 HTTP 处于中心位置。</p>
<p>我们可以这样定义 HTTP：<strong>与 HTTP 协议相关的所有应用层技术的总和。</strong></p>
<h2 id="3-与-http-相关的各种概念">3. 与 HTTP 相关的各种概念</h2>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1586866865483.png" alt="" loading="lazy"></figure>
<p><strong>总结：</strong></p>
<ul>
<li>互联网上绝大多数资源都是用 HTTP 协议传输；</li>
<li>浏览器是 HTTP 协议里的请求方，即 User Agent;</li>
<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>
<li>CDN（Content Delivery Network，内容分发网络） 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>
<li>爬虫（Crawler）是另一类的 User Agent，是自动访问网络资源的程序。</li>
</ul>
<h2 id="4-与-http-相关的各种协议">4. 与 HTTP 相关的各种协议</h2>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1586866943488.png" alt="" loading="lazy"></figure>
<h3 id="tcpip">TCP/IP</h3>
<p><strong>IP 协议</strong>是“<span style="color: red;">I</span>nternet <span style="color: red;">P</span>rotocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点之间传输数据包。IP 协议使用“<strong>IP 地址</strong>”的概念来定位互联网中的每一台计算机。</p>
<p>现在我们大多使用的 IP 协议是 v4 版（IPv4），总共有 2^32，大约有 42 亿个可以分配的地址。但随着互联网的飞速发展，IP 地址的分配很快就“捉襟见肘”。所以，又出现了 IPv6，有 2^128 个。</p>
<p><strong>TCP 协议</strong>是“<span style="color: red;">T</span>ransmission <span style="color: red;">C</span>ontrol <span style="color: red;">P</span>rotocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<span style="color: red;">可靠的</span>（保证数据不丢失）、<span style="color: red;">字节流</span>（保证数据完整）形式的通信，是 HTTP 协议得以实现的基础。</p>
<p>HTTP 是一个“传输协议”，他不关心寻址、路由、数据完整性等传输细节，而 TCP/IP 协议刚好可以满足这些工作的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地成为“<strong>HTTP over TCP/IP</strong>”。</p>
<h3 id="uriurl">URI/URL</h3>
<p><strong>URI</strong>（Uniform Resource Identifier），中文名字是 <strong>统一资源标识符</strong>，使用它就能唯一地标记互联网上地资源。</p>
<p>URI 另一个常见的表现形式是 <strong>URL</strong>（Uniform Resource Location），<strong>统一资源定位符</strong>，也即我们俗称的“网址”，它是 URI 地一个子集，两者之间差异不大，不做严格划分。</p>
<p>举一个简单的例子：</p>
<pre><code>http://nginx.org/en/download.html
</code></pre>
<p>我们可以将 URI 划分为三个部分：</p>
<ol>
<li>协议名：即访问该资源应当使用的协议，在这里是“HTTP”；</li>
<li>主机名：即互联网上主机的标记，可以是域名或者 IP 地址，在这里是“ngix.org”；</li>
<li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li>
</ol>
<h3 id="https">HTTPS</h3>
<p>HTTPS 的全称是“<strong>HTTP over SSL/TLS</strong>”，也就是运行在 SSL/TLS 协议上的 HTTP。</p>
<p>这里的 SSL/TLS 是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是一个可靠的传输协议，可以被当作 HTTP 的下层。</p>
<p>SSL 的全称是“<strong>Secure Socket Layer</strong>”，由网景公司发明，当发展到 3.0 时被标准化，该名为 TLS，即 <strong>Transport Layer Security</strong>。SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>
<h3 id="代理">代理</h3>
<p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，即可以转发客户端的请求，也可以转发服务器的响应。</p>
<p>代理分为很多类，常见的有：</p>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界即知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>
<li>反向代理：靠近服务器，代替服务器响应客户端的请求。</li>
</ol>
<p>CDN 实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，例如：</p>
<ul>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP，使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩，加密等额外的功能。</li>
</ul>
<h3 id="总结">总结</h3>
<ol>
<li>TCP/IP 是网络世界最常使用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>
<li>DNS 域名是 IP 地址的等价替代，需要用域名解析系统实现到 IP 地址的映射；</li>
<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>
<li>HTTPS 相当于“HTTP + SSL/TLS + TCP/IP”，为 HTTP 套了一个安全的外壳；</li>
<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>
</ol>
<h2 id="5-四层模型与七层模型">5. 四层模型与七层模型</h2>
<h3 id="tcpip-网络分层模型四层模型">TCP/IP 网络分层模型（四层模型）</h3>
<p>层次图如下：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1586940265489.png" alt="TCP/IP 网络分层模型" loading="lazy"></figure>
<p>第一层：<strong>链接层</strong>（Link Layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备。</p>
<p>第二层：<strong>网际层</strong>（Internet Layer），IP 协议就处于这一层。因为 IP 协议定义了 “IP 地址”的概念，所以可以在链接层的基础上，用 IP 地址代替 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络。</p>
<p>第三层：<strong>传输层</strong>（Transport Layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作地层次，另外还有它地一个小伙伴 UDP。TCP 是一个有状态的协议，需要双方先建立连接后才能发送数据，而且保证数据不丢失。而 UDP 是无状态的协议，不用事先建立连接就可以发送数据，但不保证数据一定会发送到对方。</p>
<p>第四层：<strong>应用层</strong>（Application Layer），这一层主要是各种面向具体应用的协议。如：Telnet、SSH、FTP、SMTP 以及 HTTP。</p>
<h3 id="osi-网络分层模型七层模型">OSI 网络分层模型（七层模型）</h3>
<p>OSI（Open System Interconnected Reference Model），全称是<strong>开放式系统网络互联通信参考模型</strong>，是由国际标准组织（ISO）设计出来的用来统一既存的各种网络协议的网络分层模型。</p>
<p>层次图如下：</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1586940969763.png" alt="OSI 网络分层模型" loading="lazy"></figure>
<p>OSI 模型分为了七层，部分层次和 TCP/IP 很像，从下到上分别是：</p>
<p>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等；</p>
<p>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</p>
<p>第三层：网络层，相当于 TCP/IP 的网际层；</p>
<p>第四层：传输层，相当于 TCP/IP 的传输层；</p>
<p>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</p>
<p>第六层：表示层，把数据转换为合适、可理解的语法和语义；</p>
<p>第七层：应用层，面向具体的应用传输数据。</p>
<p><strong>注意</strong>：OSI 为每一层标记了明确的编号，最底是一层，最上层是七层，而 TCP/IP 的层次只有名字而没有编号。</p>
<h3 id="两个层次模型的映射关系">两个层次模型的映射关系</h3>
<p>OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易在两个模型间实现对应关系：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1586941518170.png" alt="两种层次模型的映射关系" loading="lazy"></figure>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 响应代码]]></title>
        <id>https://pineapple126.github.io/post/http-status-code/</id>
        <link href="https://pineapple126.github.io/post/http-status-code/">
        </link>
        <updated>2020-04-13T06:29:38.000Z</updated>
        <content type="html"><![CDATA[<p>HTTP 响应状态代码的职责是<strong>当客户端向服务器发送请求时，描述返回的请求结果</strong>（即指示特定 HTTP 请求是否已成功完成）。借助状态码，用户可以知道服务器是正常处理了请求，还是出现了错误。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1587284793494.PNG" alt="相应的状态码可描述请求的处理过程" loading="lazy"></figure>
<p><strong>响应代码的类别：</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="1xx-信息响应">1XX 信息响应</h2>
<p><strong><code>100 Continue</code></strong></p>
<p>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><strong><code>101 Switching Protocol</code></strong></p>
<p>该代码是响应客户端的 <code>Upgrade</code> 标头发送的，并且指示服务器也正在切换的协议。</p>
<p><strong><code>102 Processing</code></strong></p>
<p>此代码表示服务器已收到并正在处理该请求，但没有响应可用。</p>
<p><strong><code>103 Early Hints</code></strong></p>
<p>此状态代码主要用于与 <code>Link</code> 连接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</p>
<hr>
<h2 id="2xx-成功响应">2XX 成功响应</h2>
<p>2XX 的响应结果表明请求被正常处理了。</p>
<p><strong><code>200 OK</code></strong></p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1587284933631.PNG" alt="200" loading="lazy"></figure>
<p>请求成功。默认情况下状态码为 200 的响应可以被缓存。</p>
<p>不同请求方式对于请求成功的意义如下：</p>
<ul>
<li>GET：资源已被提取并在消息正文中传输。</li>
<li>HEAD：实体标头位于消息正文中。</li>
<li>POST：描述动作结果的资源在消息体中传输。</li>
<li>TRACE：消息正文包含服务器收到的请求消息。</li>
</ul>
<p><strong><code>201 Created</code></strong></p>
<p>201 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 <code>Location</code> 首部的值。</p>
<p>该状态码的常规使用场景是作为 <code>POST</code> 请求的返回值。</p>
<p><strong><code>202 Accepted</code></strong></p>
<p>202 表示服务器端已经接收到请求消息，但是尚未进行处理。对于这个消息的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p>
<p>该状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</p>
<p><strong><code>203 Non-Authoritative Information</code></strong></p>
<p>203 表示请求已经被响应，但是获得的负载与源头服务器的状态码为 200 的响应相比，经过了拥有转换功能的 proxy （代理服务器）的修改。</p>
<p><strong><code>204 No Content</code></strong></p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1587285036464.PNG" alt="204" loading="lazy"></figure>
<p>204 是成功状态响应码，表示该请求已经成功了，但是在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么服务器显示的页面不发生更新。</p>
<p>一般在只需要从客户端向服务器发送信息，而对客户端不需要发送新消息内容的情况下使用。</p>
<p><strong><code>206 Partical Content</code></strong></p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1587285243593.PNG" alt="206" loading="lazy"></figure>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中含有由 Content-Range 指定范围的实体内容。</p>
<hr>
<h2 id="3xx-重定向">3XX 重定向</h2>
<p>3XX 响应结果表示浏览器需要执行某些特殊的处理以正确处理请求。</p>
<p><strong><code>300 Multiple Choices</code></strong></p>
<p>300 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。（由于没有如何进行选择的方法，该状态码极少使用）</p>
<p>加入服务器可以提供一个优先选择，那么它应该生成一个 <code>Location</code> 首部。</p>
<p><strong><code>301 Moved Permanently</code></strong></p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1587285423555.PNG" alt="301" loading="lazy"></figure>
<p><code>301 永久重定向</code> 说明请求的资源已经被移动到了有 <code>Location</code> 头部指定的 URL 上，是固定的不会再改变。搜索引擎会根据响应修正。</p>
<p><strong><code>302 Found</code></strong></p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1587285515711.PNG" alt="302" loading="lazy"></figure>
<p><code>302 Found</code> 重定向状态码表明请求的资源被暂时的移动到了由 <code>Location</code> 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新。</p>
<p><strong><code>303 See Other</code></strong></p>
<p>HTTP <strong>303 See Other</strong> 重定向状态码，通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或者上传进度页面。</p>
<p><strong><code>304 Not Modified</code></strong></p>
<p>HTTP <strong>304 Not Modified</strong>说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法，例如 GET 或 HEAD 或在请求中附带了头部信息：<code>If-None-Match</code> 或 <code>If-Modified-Since</code>。</p>
<hr>
<h2 id="4xx-客户端响应">4XX 客户端响应</h2>
<p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<p><strong><code>400 Bad Request</code></strong></p>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1587285839787.PNG" alt="400" loading="lazy"></figure>
<p>HTTP <strong>400 Bad Request</strong> 响应状态码表示由于语法无效，服务器无法理解该请求。客户端不应该在未修改的情况下重复此请求。</p>
<p><strong><code>401 Unauthorized</code></strong></p>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1587285913524.PNG" alt="401" loading="lazy"></figure>
<p>状态码 <strong>401 Unauthorized</strong> 表示发送的请求需要有通过 HTTP 认证的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</p>
<p>返回含有 401 的响应必须包含一个是用于被请求资源的 <code>WWW-Authenticate</code> 首部用以质询的用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p><strong><code>403 Forbidden</code></strong></p>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1587286139595.PNG" alt="403" loading="lazy"></figure>
<p>状态码 <strong>403 Forbidden</strong> 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。<strong>（权限不够）</strong></p>
<p>未获得文件系统的访问授权，访问授权出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。</p>
<p><strong><code>404 Not Found</code></strong></p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1587286253568.PNG" alt="404" loading="lazy"></figure>
<p>状态码 <strong>404 Not Found</strong> 代表客户端错误，指的是服务器端无法找到所请求的资源。404 状态码并不能说明请求的资源是临时的还是永久丢失。</p>
<hr>
<h2 id="5xx-服务器响应">5XX 服务器响应</h2>
<p>5XX 的响应结果表明服务器本身发生错误。</p>
<p><strong><code>500 Internal Server Error</code></strong></p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1587286352389.PNG" alt="500" loading="lazy"></figure>
<p><strong>500 Internal Server Error</strong> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。</p>
<p><strong><code>501 Not Implemented</code></strong></p>
<p><strong>501 Not Implemented</strong> 服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法只有 GET 和 HEAD。</p>
<p><strong><code>502 Bad Gateway</code></strong></p>
<p><strong>502 Bad Gateway</strong> 是一种 HTTP 协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</p>
<p><strong><code>503 Service Unavailable</code></strong></p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1587286644684.PNG" alt="503" loading="lazy"></figure>
<p><strong>503 Service Unavailable</strong> 是一种 HTTP 协议的服务器端错误状态码，它表示服务器尚未处于可以接受请求的状态。</p>
<p>通常造成这种情况的原因是由于服务器停机维护或者已超载。</p>
<p><strong><code>504 Gateway Timeout</code></strong></p>
<p><strong>504 Gateway Timeout</strong> 是一种 HTTP 协议的服务器端错误状态代码，表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>
<p><strong><code>505 HTTP Version Not Support</code></strong></p>
<p><strong>505 HTTP Version Not Support</strong> 是一种 HTTP 协议的服务器端错误状态码，表示服务器不支持请求所使用的 HTTP 版本。</p>
<p><strong><code>511 Network Authentication Required</code></strong></p>
<p><strong>511 Network Authentication Required</strong> 是一种 HTTP 协议的错误状态码，表示客户端需要通过验证才能使用该网络。</p>
<p>该状态码不是有源头服务器产生的，而是由控制网络访问的拦截代理服务器生成的。</p>
<hr>
<p>参考书籍及文档：</p>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">MDN web docs——HTTP 响应代码</a></li>
<li>《图解 HTTP》上野宣 —— 第 4 章 返回结果的 http 状态码</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从用户输入 URL 到页面渲染完毕，这中间发生了什么？]]></title>
        <id>https://pineapple126.github.io/post/what-happened-between-input-url-and-web-presentation/</id>
        <link href="https://pineapple126.github.io/post/what-happened-between-input-url-and-web-presentation/">
        </link>
        <updated>2020-04-07T07:23:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="从输入-url-到页面展示中间发生了什么">从输入 URL 到页面展示，中间发生了什么？</h2>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1586580599184.png" alt="从输入 URL 到页面展示完整流程示意图" loading="lazy"></figure>
<p>用户输入阶段 -&gt; 导航阶段 -&gt; 准备渲染 -&gt; 提交文档 -&gt; 渲染阶段</p>
<p><strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</strong></p>
<h2 id="1-用户输入">1. 用户输入</h2>
<p>当用户在地址栏里输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合为完整的 URL。</li>
</ul>
<p>默认情况下，当用户输入关键字并键入回车之后，当前页面将会被替换为新的页面，不过浏览器提供了一个 <code>beforeunload</code> 事件，在这个流程继续之前，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开该页面，因此用户可以用通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再进行任何后续工作。</p>
<h2 id="2-url-请求过程">2. URL 请求过程</h2>
<p>页面资源请求过程，浏览器进程通过 进程间通讯（IPC）把 URL 请求发送给 网络进程，网络进程接收到 URL 请求后，会发起真正的 URL 请求流程。</p>
<p>首先，网络进程会在本地缓存中检查是否缓存了请求资源。如果有缓存资源，则直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求第一步是进行 DNS 解析（将域名转换为 IP 地址），以获取请求服务器的 IP 地址。如果请求的协议是 HTTPS，那么还要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头、响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头中的数据，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重新开始。</p>
<p>注意：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p><strong><code>Context-Type</code> 是 HTTP 头中的一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型。</strong>，然后浏览器会根据 <code>Context-Type</code> 字段的值来决定如何显示响应体的内容。</p>
<p>不同 <code>Context-Type</code> 的后续处理流程也截然不同。如果 <code>Context-Type</code> 字段的值被浏览器判断为<strong>下载类型</strong>，<strong>那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航栏流程就此结束</strong>。但如果是 <strong>HTML</strong>，<strong>那么浏览器则会继续进行导航流程。</strong></p>
<h2 id="3-准备渲染进程">3. 准备渲染进程</h2>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。**官方把这个默认策略叫做 process-per-site-instance。</p>
<p>总结一下：</p>
<ul>
<li>通常情况下，打开的新页面都会使用单独的渲染进程；</li>
<li>如果从 A 页面打开 B 页面，且 A 与 B 都属于<strong>同一站点</strong>的话，B 页面会复用 A 页面的渲染进程。</li>
</ul>
<h2 id="4-提交文档">4. 提交文档</h2>
<p>所谓提交文档，就是指浏览器将网络进程接收到的 HTML 数据提交给渲染进程，具体流程如下：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括安全状态、地址 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>至此，一个完整的导航流程结束，紧接着是渲染阶段</p>
<h2 id="5-渲染阶段">5. 渲染阶段</h2>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<p>渲染模块在执行过程中会被划分为许多子阶段。我们把这样一个处理流程叫做<strong>渲染流水线</strong>，其大致流程如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1586244905056.png" alt="渲染流水线示意图" loading="lazy"></figure>
<p>按照渲染的时间顺序，流水线可分为如下几个阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。在每个阶段中，我们需要注意以下三点内容:</p>
<ul>
<li>每个子阶段都有其<strong>输入内容</strong>；</li>
<li>每个子阶段都有其<strong>处理过程</strong>；</li>
<li>每个子阶段都会生成<strong>输出内容</strong>。</li>
</ul>
<h3 id="构建-dom-树">构建 DOM 树</h3>
<p><strong>由于浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</strong></p>
<p>DOM 树的构建过程可以参考下图：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1586245031193.png" alt="DOM 树构建过程示意图" loading="lazy"></figure>
<p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个简单的 HTML 文件，然后经由 HTML 解析器解析，最终输入树状结构的 DOM。</p>
<h3 id="样式计算recalculate-style">样式计算（Recalculate Style）</h3>
<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大致可分为三个步骤：</p>
<p><strong>1. 把 CSS 转换为浏览器可以理解的结构。</strong></p>
<p>CSS 样式来源主要有三种：</p>
<ul>
<li>通过 link 引入的外部 CSS 文件</li>
<li><code>&lt;style&gt;</code> 标记内的样式</li>
<li>元素 style 属性内嵌的 CSS</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</strong>（渲染引擎会将获取的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能）</p>
<p><strong>2. 转换样式表中的属性值，使其标准化</strong></p>
<p>我们已经将 CSS 文本转换为浏览器可以理解的结构了，<strong>接下来我们要对其进行属性值的标准化操作</strong>。</p>
<p>那什么是标准化呢？假如我们有以下一段 CSS 文本：</p>
<pre><code class="language-css">body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
</code></pre>
<p>可以看到文本内有很多属性值，如 2em、blue、bold 等，<strong>这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎所能够理解的、标准化的计算值</strong>，这个过程就是属性值的标准化。</p>
<p>标准化后的属性值如下图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1586246231460.png" alt="标准化属性值" loading="lazy"></figure>
<p><strong>3. 计算出 DOM 树中每个节点的具体样式</strong></p>
<p>现在样式的属性值已经被标准化了，接下来就要计算 DOM 树中每个节点的样式属性了。而计算过程涉及到 <strong>CSS 的继承规则</strong>和<strong>层叠规则</strong>两部分。</p>
<p>首先是 CSS 的继承规则。<strong>CSS 继承就是每个 DOM 节点都包含父节点的样式。</strong></p>
<p>我们结合下面的实例，看看一张样式表如何应用到 DOM 节点上：</p>
<pre><code class="language-css">body { font-size: 20px }
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
</code></pre>
<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1586246783746.png" alt="计算后 DOM 的样式" loading="lazy"></figure>
<p>从图中可以看出，所有的子节点都继承了父节点的样式。</p>
<p>样式计算的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称是“层叠样式表”正是强调了这一点。</strong></p>
<h3 id="布局阶段">布局阶段</h3>
<p>我们现在已经拥有了 DOM 树和 DOM 树中元素的样式，接下来<strong>我们需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程称为布局。</strong></p>
<p>Chrome 在布局阶段需要完成两个步骤：创建布局树和布局计算。</p>
<p><strong>1. 创建布局树</strong></p>
<p><strong>在 DOM 树显示之前，我们还需要额外地构建一棵只包含可见元素布局树。</strong></p>
<p>我们可以结合下图来看看布局树的构造过程：</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1586329485462.png" alt="布局树构建流程示意图" loading="lazy"></figure>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含在布局树中。</p>
<p>为了构建布局树，浏览器大致完成了下面这些工作：</p>
<ul>
<li>遍历 DOM 树中的节点，并把这些节点加到布局树中；</li>
<li>不可见的节点暂时会被忽略掉。</li>
</ul>
<p><strong>2. 布局计算</strong></p>
<p>现在我们拥有一棵完整的布局树，我们要做的是计算布局树中节点的坐标位置。</p>
<p>在执行布局操作时，会把布局计算的结果重新写回到布局树中，所以布局树既是输入内容，也是输出内容。</p>
<h3 id="分层">分层</h3>
<p>因为页面中有很多复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（Layer Tree）。</p>
<p>通过 Chrome 的“开发者工具”中的“Layers”标签，就可以可视化页面的分层情况。</p>
<p>渲染引擎给页面分了许多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。也即**浏览器的页面实际上被分为了许多图层，这些图层叠加后合成了最终的页面。**我们可以通过下图看看图层和布局树节点之间的关系：</p>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1586331052930.png" alt="布局树和图层树关系示意图" loading="lazy"></figure>
<p>通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。**不管如何，最终每个节点都会直接或间接地从属于一个图层。</p>
<p>通常满足下面两点中任意一点的元素就可以被渲染引擎提升为单独的一个图层：</p>
<ul>
<li><strong>拥有层叠上下文属性的元素会被提升为单独的一层。</strong>（我们假定用户正面向视窗或者网页，而 HTML 元素沿着相对于用户的一条虚拟的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想）</li>
<li><strong>需要裁剪（clip）的地方也会被创建为图层。</strong>（当元素内容超出元素限定范围时，就会发生裁剪。出现裁剪时，渲染引擎会为元素内容单独创建一个图层）</li>
</ul>
<h3 id="图层绘制">图层绘制</h3>
<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。</p>
<p>渲染引擎实现图层的绘制时，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1586506394268.png" alt="绘制列表" loading="lazy"></figure>
<p>绘制一个元素通常需要好几条绘制指令，因此在图层绘制阶段，输出的内容就是这些待绘制列表。</p>
<h3 id="栅格化raster操作">栅格化（raster）操作</h3>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程。</p>
<p>通过<strong>视口（viewport）</strong>（用户可以看到页面的部分）用户只能看到页面的很小一部分，如果要绘制出所有图层内容的话，就会产生很大的开销。</p>
<p>基于这个原因，<strong>合成线程将图层划分为图块（tile）</strong>（图块的大小通常为 256×256 或 512×512），**然后合成线程会按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**而图块是栅格化的最小单位。渲染进程维护了一个栅格化的线程池，所有图块的栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1586507976232.png" alt="合成线程提交图块给栅格化线程池" loading="lazy"></figure>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫做快速栅格化，或者 GPU 栅格化，生成的位图保存在 GPU 内存中。</p>
<h3 id="合成与显示">合成与显示</h3>
<p>一旦所有的图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程中有一个叫 viz 的组件，用于接收来自合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后将内存显示在屏幕上。</p>
<h3 id="渲染总结">渲染总结：</h3>
<p>完整的渲染流水线示意图：</p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1586506955163.png" alt="" loading="lazy"></figure>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成<strong>图层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分为<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换为位图。</li>
<li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程。</li>
<li>浏览器进程根绝 DrawQuad 消息<strong>生成页面</strong>，并显示到显示器上。</li>
</ol>
<h3 id="相关概念">相关概念：</h3>
<p><strong>1. 更新了元素的几何位置（重排）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1586508485468.png" alt="重排" loading="lazy"></figure>
<p>如果我们通过 JS 或者 CSS 修改元素的几何位置属性，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫做<strong>重排</strong>。<strong>重排需要更新完整的渲染流水线，所以开销也是最大的。</strong></p>
<p><strong>2. 更新了元素的绘制属性（重绘）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1586508688667.png" alt="重绘" loading="lazy"></figure>
<p>如果我们修改了元素的绘制属性，那么布局阶段将不会被执行，而是直接进入到绘制阶段，然后执行之后的一系列子阶段，这个过程就叫做<strong>重绘</strong>。相较于重排，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</strong></p>
<p><strong>3. 直接合成阶段</strong></p>
<p>如果我们更改一个既不要布局也不要绘制的属性，会发生什么？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称作<strong>合成</strong>。参考下图：</p>
<figure data-type="image" tabindex="13"><img src="https://pineapple126.github.io//post-images/1586508967109.png" alt="合成" loading="lazy"></figure>
<p><strong>相对于重排和重绘，合成能大大提升绘制效率。</strong></p>
<h2 id="总结从用户输入-url到最终的页面展示到底发生了什么">总结：从用户输入 URL，到最终的页面展示到底发生了什么？</h2>
<ol>
<li>用户输入 URL 并按下回车，浏览器进程检查 URL，组装协议，构成完整的 URL</li>
<li>浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为还没有获得新页面的响应数据</li>
<li>浏览器进程通过进程间通信（IPC）把 URL 请求发送给网络进程</li>
<li>网络进程接收到 URL 请求后检查本地缓存是否含有该请求资源，如果有则直接将该资源返回给浏览器进程（状态码 200）</li>
<li>如果没有，网络进程向 Web 服务器发起 HTTP 请求（网络请求），请求流程如下:<br>
5.1 进行 DNS 解析，获取服务器的 IP 地址：如果缓存过当前域名信息，就会直接返回缓存信息；<br>
5.2 根据 IP 地址和服务器建立 TCP 连接（三次握手）；<br>
5.3 如果是 HTTPS 请求则还需要建立 TLS 连接；<br>
5.4 浏览器端构建并发送请求头信息；<br>
5.5 服务器端响应后，网络进程接收响应头和响应信息，并解析响应内容；<br>
5.6 数据传输完成后，断开 TCP 连接（四次挥手）。如果浏览器端或服务器端在 HTTP 头部加上 <code>Connection: Keep-Alive</code> 字段，TCP 连接将一直保持下去。保持 TCP 连接可以节省建立连接所需的事件，提高资源加载速度。</li>
<li>网络进程响应流程：<br>
6.1 检查状态码，如果是 301/302，则需要重定向，从响应信息中 <code>Location</code> 字段获取地址，重新发起 URL 请求；<br>
6.2 如果不是重定向，首先服务器会根据请求头中的 <code>if-None-Match</code> 字段的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以继续使用，就不用再返回数据了。<br>
6.3 其他状态码响应处理：<br>
检查响应类型 <code>Context-Type</code> 字段：如果是 字节流 类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染阶段；如果是 text/html 类型，则通知浏览器进程，准备进行渲染阶段。</li>
<li>准备渲染阶段：<br>
7.1 浏览器进程获取到来自网络进程的通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是同一个站点（根域名和协议相同就被认为同一站点）<br>
7.2 如果相同，则新页面复用页面 A 的渲染进程；如果不同，则浏览器为页面 B 创建一个新的渲染进程</li>
<li>传输数据、更新状态<br>
8.1 渲染进程准备好后，浏览器进程向渲染进程发起“提交文档”的消息，渲染进程接收到消息后，和网络进程建立数据传输的“管道”<br>
8.2 渲染进程接受完数据后，向浏览器进程发送“确认提交”的消息<br>
8.3 浏览器进程接收到“确认提交”的消息后，更新浏览器界面的状态：包括安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面，此时 Web 页面是空白页。</li>
<li>渲染进程渲染页面：<br>
9.1 构建 DOM 树<br>
9.2 样式计算（构建 CSSOM 树）<br>
9.3 页面布局（构建布局树）<br>
9.4 分层（构建图层树）<br>
9.5 图层绘制（绘制列表）<br>
9.6 分块（将图层划分为图块）<br>
9.7 栅格化（栅格化，是指将图块转换为位图）<br>
9.8 合成和显示</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 23 合并K个排序链表（分治）]]></title>
        <id>https://pineapple126.github.io/post/leetcode-23-mergeKLists/</id>
        <link href="https://pineapple126.github.io/post/leetcode-23-mergeKLists/">
        </link>
        <updated>2020-03-23T11:16:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>问题描述：</strong></p>
<p>合并 k 个排序链表，返回合并后的排序链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<p><strong>基本思路：</strong></p>
<p>对于合并两个排序链表的问题，我们可以轻松解决。只要创建一个新的哑巴节点，再选择两个链表头节点较小的一个与哑巴节点链接起来，循环该操作，直至合并完成。</p>
<p>那么对于合并K个排序链表，我们可以运用分治的思想，不断地将数组不断拆分。（我们用数组 lists 存储着这些链表）</p>
<p>这里借用官方题解的一张图片：</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1584964378982.png" alt="分治演示" loading="lazy"></figure>
<p>那么拆分过程中有以下情形：</p>
<ul>
<li>
<p><code>lists.length === 0</code>        数组 lists 中已无链表，则返回一个空节点；</p>
</li>
<li>
<p><code>lists.length === 1</code>        数组 lists 中仅剩一个链表，因此直接返回该链表；</p>
</li>
<li>
<p><code>lists.length === 2</code>        数组 lists 中有两个链表，我们执行合并操作；</p>
</li>
<li>
<p><code>other</code>         数组 lists 中的链表数过多，需要继续拆分。</p>
</li>
<li>
<p>时间复杂度：O(nlogK)</p>
<ul>
<li>k 为链表总数</li>
<li>n 为合并两个链表所用的时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    // 如果列表中的 链表 为空 则直接返回
    if (lists.length === 0) return null;
    // 如果列表中的 链表 只剩一个直接返回
    if (lists.length === 1) return lists[0];
    // 如果列表中的 链表 有两个 则合并两个链表
    if (lists.length === 2) return mergeTwoLists(lists[0], lists[1]);
    // 否则继续拆分
    let mid = lists.length &gt;&gt; 1;
    let left = lists.slice(0, mid),
        right = lists.slice(mid);
    return mergeTwoLists(mergeKLists(left), mergeKLists(right));
};

function mergeTwoLists(list1, list2) {
    let ans = new ListNode(-1),
        preAns = ans;
    while(list1 &amp;&amp; list2) {
        if (list1.val &lt; list2.val) {
            preAns.next = list1;
            list1 = list1.next;
        } else {
            preAns.next = list2;
            list2 = list2.next;
        }
        preAns = preAns.next;
    }
    preAns.next = list1 ? list1 : list2;
    return ans.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件委托]]></title>
        <id>https://pineapple126.github.io/post/event-delegation/</id>
        <link href="https://pineapple126.github.io/post/event-delegation/">
        </link>
        <updated>2020-03-21T10:08:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p>事件委托就是通过事件冒泡的机制，利用父级元素去触发子级元素的事件。</p>
<p>使用事件委托可以减少内存开销，提高性能。</p>
<h2 id="示例">示例</h2>
<p>例如，我们要对一堆 li 元素绑定相同的事件，如果将事件都绑定到 li 元素上，会增加内存开销、降低性能。而我们可以将事件侦听器绑定到这些 li 元素的父级元素 ul 或 ol 元素上，这样子我们仅需绑定一次事件。当我们需要触发事件时，会通过冒泡机制传递给父级元素触发事件。</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    /* 事件委托的核心原理：给父节点添加侦听器，
        利用事件冒泡机制影响每一个子节点 */
        var ul = document.querySelector(&quot;ul&quot;);
        ul.addEventListener(&quot;click&quot;, function(e) {
            //  e.target 可以得到我们点击的对象
            e.target.style.backgroundColor = &quot;red&quot;;
        });
&lt;/script&gt;
</code></pre>
<p>在这个示例中：</p>
<ul>
<li>我们只操作了一次 DOM，提高了程序的性能</li>
<li>动态创建的子元素，也将拥有事件</li>
</ul>
<h2 id="总结">总结</h2>
<p>综上所述，当我们需要给一组元素添加相同事件时，我们可以通过事件委托的方式将事件直接添加给父级元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的三序遍历]]></title>
        <id>https://pineapple126.github.io/post/traversal-binary-tree/</id>
        <link href="https://pineapple126.github.io/post/traversal-binary-tree/">
        </link>
        <updated>2020-03-20T02:48:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="先序遍历preordertraversal">先序遍历（preorderTraversal）</h2>
<p>节点遍历顺序：根 -&gt; 左 -&gt; 右</p>
<h3 id="递归方式">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    return [
        root.val,
        ...preorderTraversal(root.left),
        ...preorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="非递归方式">非递归方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            res.push(curr.val);
            curr = curr.left;
        }
        curr = stack.pop();
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="中序遍历inordertraversal">中序遍历（inorderTraversal）</h2>
<p>节点遍历顺序：左 -&gt; 根 -&gt; 右</p>
<h2 id="递归方式-2">递归方式</h2>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    return [
        ...inorderTraversal(root.left),
        root.val,
        ...inorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="非递归方式-2">非递归方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        res.push(curr.val);
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="后序遍历postordertraversal">后序遍历（postorderTraversal)</h2>
<p>节点遍历顺序：左 -&gt; 右 -&gt; 根</p>
<h3 id="递归方式-3">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    return [
        ...postorderTraversal(root.left),
        ...postorderTraversal(root.right),
        root.val
    ];
}
</code></pre>
<h3 id="非递归方式-3">非递归方式</h3>
<p><strong>方式一：正序解</strong></p>
<p>实现（1）：如果某一结点的子节点已被遍历过，则将其子节点指向 null。（整个过程就像是给一棵树不断地修剪叶子一样）</p>
<p>基本思路：</p>
<ol>
<li>先遍历左节点，当遍历到叶子节点时，记录其值；</li>
<li>返回至该叶子节点的上一层，并让该叶子节点指向 null；</li>
<li>再遍历右节点，当遍历到叶子节点时，记录值；</li>
<li>再次返回上一层节点，顺便让该叶子节点指向 null。</li>
</ol>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        if (curr.left) {
            stack.push(curr);
            curr = curr.left;
        } else if (curr.right) {
            stack.push(curr);
            curr = curr.right;
        } else {
            res.push(curr.val);
            curr = stack.pop();
            if (curr &amp;&amp; curr.left) curr.left = null;
            else if (curr &amp;&amp; curr.right) curr.right = null;
        }
    }
    return res;
}
</code></pre>
<p>实现（2）：添加标志位 flag，当某一节点的左右子节点的值都已被记录时 flag 为 true，否则为 false。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while (curr || stack.length &gt; 0) {
        while(curr) {
            stack.push([curr, false]);
            curr = curr.left;
        }
        let [node, flag] = stack.pop();
        if (!flag) {
            stack.push([node, true]);
            curr = node.right;
        } else {
            res.push(node.val);
        }
    }
    return res;
}
</code></pre>
<p><strong>方式二：倒序解</strong></p>
<p>思路：该方式类似于先序遍历，只是遍历顺序为 根 -&gt; 右 -&gt; 左。而记录值是从数组的头部插入。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length) {
        while(curr) {
            stack.push(curr);
            res.unshift(curr.val);
            curr = curr.right;
        }
        curr = stack.pop();
        curr = curr.left;
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://pineapple126.github.io/post/sort-algorithm/</id>
        <link href="https://pineapple126.github.io/post/sort-algorithm/">
        </link>
        <updated>2020-03-19T03:05:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2>
<p>基本思想：采用分治的思想，选取一个基准，将待排序数组分为两个小、大数组，不断重复这个过程直至数组有序。</p>
<p>基本步骤：</p>
<ol>
<li>选取基准（pivot）；</li>
<li>根据基准将待排序数组分割为两个数组；</li>
<li>重复以上步骤，直至数组有序。</li>
</ol>
<pre><code class="language-javascript">function quickSort(arr) {
    if (arr.length &lt; 2) return arr;
    let pivot = arr[0];
    let left = [],
        right = [];
    for(let i  = 1; i &lt; arr.length; i++) {
        if (arr[i] &lt; pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot, quickSort(right));
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<p>基本思想：将数组的第一位视为一个有序数组，将剩下的待排序数组逐个插入到已排序数组中。</p>
<pre><code class="language-javascript">function insertSort(arr) {
    for(let i = 1; i &lt; arr.length; i++) {
        let tmp = arr[i],
            j = i;
        for( ; j &gt; 0; j--) {
            if (tmp &gt; arr[j-1]) {
                break;
            }
            arr[j] = arr[j-1];
        }
        arr[j] = tmp;
    }
    return arr;
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>基本思想：采取分治的思想，将两个有序数组合并为一个有序数组。</p>
<pre><code class="language-javascript">function mergeSort(arr) {
    if (arr.length &lt; 2) return arr;
    let res = [];
    let mid = arr.length &gt;&gt; 1;
    let left = mergeSort(arr.slice(0, mid)),
        right = mergeSort(arr.slice(mid));
    while(left.length &amp;&amp; right.length) {
        if (left[0] &lt; right[0]) {
            res.push(left.shift());
        } else {
            res.push(right.shift());
        }
    }
    return res.concat(left, right);
}
</code></pre>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-javascript">function bubbleSort(arr) {
    for(let i = 0; i &lt; arr.length; i++) {
        for(let j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j] &gt; arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
            }
        }
    }
    return arr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型判断]]></title>
        <id>https://pineapple126.github.io/post/type-judgement/</id>
        <link href="https://pineapple126.github.io/post/type-judgement/">
        </link>
        <updated>2020-03-13T08:47:22.000Z</updated>
        <content type="html"><![CDATA[<p>JavaScript 中有 8 种数据类型，又分为基本数据类型和引用数据类型。</p>
<ul>
<li>基本数据类型：Null、Undefined、Number、Boolean、String、Symbol、BigInt</li>
<li>引用数据类新：Object</li>
</ul>
<p>判断数据类型的方法有以下几种：<code>typeof</code> 运算符、<code>instanceof</code> 运算符、<code>constructor</code> 方法和 <code>Object.prototype.toString.call()</code> 方法</p>
<p>我们先创建这些数据类型的变量：</p>
<pre><code class="language-javascript">let nul = null,
    und= undefined,
    num = 1,
    bool = true,
    str = &quot;string&quot;,
    sym = Symbol(),
    bigint = 1n,
    obj = {name: &quot;zs&quot;},
    arr = [1, 2, 3],
    fn = function() { console.log(&quot;function&quot;); };
</code></pre>
<h2 id="typeof">typeof</h2>
<p><code>typeof</code> 可以识别出数据类型，但是不能识别 null 和 array，会将它们归为 Object 类型。判断示例如下：</p>
<pre><code class="language-javascript">console.log(typeof nul);            //  object
console.log(typeof und);            //  undefined
console.log(typeof num);            //  number
console.log(typeof bool);           //  boolean
console.log(typeof str);            //  string
console.log(typeof sym);            //  symbol
console.log(typeof bigint);         //  bigint
console.log(typeof obj);            //  object
console.log(typeof arr);            //  object
console.log(typeof fn);         //  function
</code></pre>
<h2 id="instanceof">instanceof</h2>
<p><code>instanceof</code> 不能识别基本数据类型，但是可以识别出 Array、Function 与 Object。同时，对于 new 声明的类型，还可以检测出多层继承关系。</p>
<pre><code class="language-javascript">console.log(nul instanceof Object);         //  false
console.log(und instanceof Object);         //  false
console.log(num instanceof Number);         //  false
console.log(bool instanceof Boolean);           //  false
console.log(str instanceof String);         //  false
console.log(sym instanceof Symbol);         //  false
console.log(bigint instanceof BigInt);          //  false
console.log(obj instanceof Object);         //  true
console.log(arr instanceof Array);          //  true
console.log(fn instanceof Function);            //  true
</code></pre>
<h2 id="constructor">constructor</h2>
<p>null、undefined 没有 constructor 方法，因此 constructor 不能用于判断 null 和 undefined。并且，constructor 是不安全的，因此 constructor 的指向是可以被改变的。</p>
<pre><code class="language-javascript">console.log(num.constructor === Number);            //  true
console.log(bool.constructor === Boolean);          //  true
console.log(str.constructor === String);            //  true
console.log(sym.constructor === Symbol);            //  true
console.log(bigint.constructor === BigInt);         //  true
console.log(obj.constructor === Object);            //  true
console.log(arr.constructor === Array);         //  true
console.log(fn.constructor === Function);           //  true
</code></pre>
<h2 id="objectprototypetostringcall">Object.prototype.toString.call()</h2>
<p>该方法可以相对较全的判断 JavaScript 的数据类型。</p>
<pre><code class="language-javascript">console.log(Object.prototype.toString.call(nul));           //  [object Null]
console.log(Object.prototype.toString.call(und));           //  [object Undefined]
console.log(Object.prototype.toString.call(num));           //  [object Number]
console.log(Object.prototype.toString.call(bool));          //  [object Boolean]
console.log(Object.prototype.toString.call(str));           //  [object String]
console.log(Object.prototype.toString.call(sym));           //  [object Symbol]
console.log(Object.prototype.toString.call(bigint));            //  [object BigInt]
console.log(Object.prototype.toString.call(obj));           //  [object Object]
console.log(Object.prototype.toString.call(arr));           //  [object Array]
console.log(Object.prototype.toString.call(fn));            //  [object Function]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map集合（2）]]></title>
        <id>https://pineapple126.github.io/post/map/</id>
        <link href="https://pineapple126.github.io/post/map/">
        </link>
        <updated>2020-03-12T03:16:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-中的-map-集合">ES6 中的 Map 集合</h2>
<p>ES6 中的 Map 类型是一种<strong>储存着许多键值对</strong>的<strong>有序列表</strong>，其中的键名和对应的值支持所有的数据类型。键名的等价性判断是通过调用 <code>Object.is()</code> 方法实现的，所以数字 5 与字符串 &quot;5&quot; 会被判定为两种类型，可以分别作为独立的两个键出现在程序中。</p>
<h3 id="map-集合创建方法以及支持的方法和属性">Map 集合创建方法以及支持的方法和属性</h3>
<p>创建方法：调用 <code>new Map()</code> 即可创建一个 Map 集合。</p>
<p>支持方法：</p>
<ul>
<li><code>set(key, value)</code> 方法：向 Map 集合中添加新的元素；</li>
<li><code>get(key)</code> 方法：从 Map 集合中获取信息，若传入的键名不存在，则返回 undefined；</li>
<li><code>has(key)</code> 方法：检测指定的键名在 Map 集合中是否已经存在；</li>
<li><code>delete(key)</code> 方法：从 Map 集合中移除指定键名及其对应的值；</li>
<li><code>clear()</code> 方法：移除 Map 集合中所有的键值对；</li>
<li><code>size</code> 属性：获取当前集合中包含的键值对数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new Map();
map.set(&quot;name&quot;, &quot;Nicholas&quot;);
map.set(&quot;age&quot;, 25);

console.log(map.size);          //  2

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;

console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25

map.delete(&quot;name&quot;);
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.size);          //  1

map.clear();
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.has(&quot;age&quot;));            //  false
console.log(map.get(&quot;age&quot;));            //  undefined
console.log(map.size);          //  0
</code></pre>
<p>也可以向 Map 构造函数传入数组来初始化一个 Map 集合，数组中的每一个元素都是一个子数组，子数组包含一个键值对的键名与值两个元素。示例如下：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;
console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25
console.log(map.size);          //  2
</code></pre>
<h3 id="map-集合中的-foreach-方法">Map 集合中的 forEach() 方法</h3>
<p>Map集合的 <code>forEach()</code> 方法与 Set 集合和数组中的 <code>forEach()</code> 方法类似，回调函数都接受 3 个参数：</p>
<ul>
<li>Map 集合中下一次索引的值</li>
<li>值对应的键名</li>
<li>Map 集合本身</li>
</ul>
<p>这些回调参数与数组中的更相近，第一个参数是值，第二个参数是键名。请看这个示例：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

map.forEach(function (value, key, ownerMap) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerMap === map);
});
</code></pre>
<p>这段代码会输出以下内容：</p>
<pre><code class="language-javascript">name Nicholas
true
age 25
true
</code></pre>
<p>遍历过程中，会按照键值对插入 Map 集合的顺序将相应信息传入 <code>forEach()</code> 方法的回调函数，而在数组中，则会按照数值型索引值的顺序依次传入回调函数。</p>
<p><strong>注意</strong>：可以指定 <code>forEach()</code> 函数的第二个参数作为回调函数的 <code>this</code> 值。</p>
<h2 id="weak-map-集合">Weak Map 集合</h2>
<p>Weak Set 集合是弱引用的 Set 集合，相对应的，Weak Map 集合是弱引用的 Map 集合，也用于存储对象的弱引用。Weak Map 集合中的键名必须是一个对象。集合中保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的键值对。但是只有集合的键名遵从这个规则，键名对应的值如果是个对象，则保存的是对象的强引用，不会触发垃圾回收机制。</p>
<p>Weak Map 集合最大的用途是跟踪 Web 页面中的 DOM 元素，当 DOM 元素消失时，可以自动销毁集合中的相关对象。</p>
<h3 id="使用-weak-map-集合">使用 Weak Map 集合</h3>
<p>ES6 中的 Weak Map 类型是一种存储着许多键值对的无序列表，列表的键名必须是非 null 类型的对象，键名对应的值则可以是任意类型。</p>
<p>我们可以通过 WeakMap 构造函数来创建一个 Weak Map 集合。Weak Map 集合也支持以下方法：</p>
<ul>
<li><code>set()</code></li>
<li><code>get()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new WeakMap(),
    element = document.querySelector(&quot;.element&quot;);

map.set(element, &quot;Original&quot;);

console.log(map.has(element));          //  true
console.log(map.get(element));          //  &quot;Original&quot;

map.delete(element);
console.log(map.has(element));          //  false
console.log(map.get(element));          //  undefined
</code></pre>
<h2 id="小结">小结</h2>
<p>Set 集合是一种包含多个非重复值的有序列表，值与值之间的等价性是通过 <code>Object.is()</code> 方法来判断的，如果相同，则会自动过滤重复的值，所以可以用 Set 集合来过滤数组中的重复元素。</p>
<p>Weak Set 集合是一类特殊的 Set 集合，集合只支持存放对象的弱引用。由于内存管理非常复杂，Weak Set 集合不可以被检查，因此追踪成组的对象是该集合最好的使用方式。</p>
<p>Map 是多个键值对组成的有序集合，键名支持任意数据类型，与 Set 集合相似的是，Map 集合也是通过 <code>Object.is()</code> 方法来过滤重复值。</p>
<p>Weak Map 集合是一类特殊的 Map 集合，只支持对象类型的键名，集合中存放的键是对象的弱引用。Weak Map 集合可以为那些实际使用与生命周期管理分离的对象添加额外信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map 集合（1）]]></title>
        <id>https://pineapple126.github.io/post/set/</id>
        <link href="https://pineapple126.github.io/post/set/">
        </link>
        <updated>2020-03-09T11:55:04.000Z</updated>
        <content type="html"><![CDATA[<p>这是学习阅读《深入理解ES6》第七章 Set 集合与 Map 集合 后整理而成的学习笔记。</p>
<p>Set 集合是一种<strong>无重复元素</strong>的列表；Map 集合内含多组键值对，集合中每个元素分别存放着可访问的键名和它对应的值，Map 集合经常被用于缓存频繁取用的数据。</p>
<h2 id="es5-中的-set-集合与-map-集合">ES5 中的 Set 集合与 Map 集合</h2>
<p>在 ES5 中，开发者们用对象属性来模拟这两种集合：</p>
<pre><code class="language-javascript">var set = Object.create(null);

set.foo = true;

//  检查属性是否存在
if (set.foo) {
    //  要执行的代码
}
</code></pre>
<p>这里的变量 set 是一个原型为 null 的对象，不继承任何属性。在 ES5 中，开发者们经常使用类似的方法检查对象的某个属性值是否存在。</p>
<p>模拟这两种集合的唯一区别是存储的值不同，以下这个示例是用对象模拟 Map 集合：</p>
<pre><code class="language-javascript">var map = Object.create(null);
map.foo = &quot;bar&quot;;

//  获取已存值
var value = map.foo;

console.log(value);         //  &quot;bar&quot;
</code></pre>
<p>一般来说，Set 集合经常被用于检查对象中是否存在某个键名，而 Map 集合常被用于获取已存值的信息。</p>
<h3 id="该方案可能存在的问题">该方案可能存在的问题</h3>
<p>需要注意的是，所有对象的属性名必须是字符串类型，因此必须确保每个键名都是字符串类型且在对象中是唯一的。若以数字为属性名，数字则会被自动转换成字符串；若以对象为属性名，则会被自动转换为对象对应的默认字符串 &quot;[object Object]&quot;。如果不不注意的话，则内部的自动转换机制将会导致很多问题。</p>
<h2 id="es6-中的-set-集合">ES6 中的 Set 集合</h2>
<p>ES6 新增的 Set 类型是一种有序列表，其中含有一些<strong>相互独立</strong>的<strong>非重复值</strong>，通过 Set 集合可以快速访问其中的数据，更有效地追踪各种离散值。</p>
<h3 id="创建-set-集合以及支持的方法与属性">创建 Set 集合以及支持的方法与属性</h3>
<p>调用 <code>new Set()</code> 即可创建 Set 集合。</p>
<p>Set 集合支持以下方法和属性：</p>
<ul>
<li><code>add(value)</code> 方法，用于给 Set 集合添加元素；</li>
<li><code>has(value)</code> 方法，用于判断 Set 集合是否含有 value 值；</li>
<li><code>delete(value)</code> 方法，用于从 Set 集合中删除指定的 value 值；</li>
<li><code>clear()</code> 方法，用于清空 Set 集合；</li>
<li><code>size</code> 属性，可以获取集合中目前的元素数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let set = new Set();
set.add(5);
set.add(&quot;5&quot;);

let key1 = {};
let key2 = {};
set.add(key1);
set.add(key2);

console.log(set.has(5));            //  true
console.log(set.has(&quot;5&quot;));          //  true
console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true

set.delete(5);
set.delete(key1);
console.log(set.has(5));            //  false
console.log(set.has(key1));            //  false
console.log(set.size);          //  2

set.clear();

console.log(set.has(&quot;5&quot;));          //  false
console.log(set.has(key2));         //  false
console.log(set.size);          //  0
</code></pre>
<p>通过这个示例，我们发现数字 5 和字符串 &quot;5&quot;、key1 和 key2 作为独立的值存储入 Set 集合中。实际上，在 Set 集合中，不会对所存值进行强制的类型转换，数字 5 和字符串 &quot;5&quot; 是作为两个独立元素存在，对象key1 和 key2 也不会被转换成字符串，因而两者在 Set 集合中是两个对立的元素。（引擎内部使用 <code>Object.is()</code> 方法检测两个值是否一致，唯一例外的是，Set 集合中的 +0 和 -0 被认为是相等的）</p>
<p><strong>提示</strong>：Set 构造函数可以接受所有可迭代对象作为参数，数组、Set 集合、Map 集合都是可迭代的，因而都可以作为 Set 构造函数的参数使用；构造函数通过迭代器从参数中提取值。</p>
<p>Set 构造函数同样会过滤掉重复的值从而保证集合中的元素各自唯一。示例如下：</p>
<pre><code class="language-javascript">let set = new Set([1,2,2,3,4,5,5,6]);

console.log(set.size);          //  6
</code></pre>
<h3 id="set-集合的-foreach-方法">Set 集合的 forEach() 方法</h3>
<p>ES6 也为 Set 集合添加了 <code>forEach()</code> 方法，其运行机制和数组的 <code>forEach()</code> 方法类似。</p>
<p><code>forEach()</code> 方法的回调函数接受以下 3 个参数：</p>
<ul>
<li>Set 集合中下一次索引的位置</li>
<li>与第一个参数一样的值</li>
<li>被遍历的 Set 集合本身</li>
</ul>
<p>数组和 Map 集合的 <code>forEach()</code> 方法的回调函数都是接受 3 个参数，前两个分别为值和键名，而 Set 集合没有键名，ES6 为了保持方法分歧不大，因此也将 Set 集合中的每个元素也按照键名和值的形式存储，从而保证所有 <code>forEach()</code> 方法的回调函数中前两个参数具有相同意义。</p>
<p>请看以下示例：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

set.forEach(function(value, index, ownerSet) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerSet === set);
});
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-javascript">1 1
true
2 2
true
</code></pre>
<p>在 Set 集合的 <code>forEach()</code> 方法中，第二个参数也与数组的一样，如果需要在回调函数中使用 <code>this</code> 引用，则可以将它作为第二个参数传入 <code>forEach()</code> 函数：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach(function(value) {
            this.output(value);
        }, this);
    }
};

processor.process(set);
</code></pre>
<p>当然我们也可以使用箭头函数，这样在这里就不用向回调函数传入 <code>this</code> 参数了。</p>
<h3 id="将-set-集合转换为数组">将 Set 集合转换为数组</h3>
<p>将数组转换为 Set 集合的过程很简单，只需要给 Set 构造函数传入数组即可；将 Set 集合再转换回数组的过程也很简单，只需要使用<strong>展开运算符</strong>即可。（展开运算符可以将可迭代对象转换为数组）举个例子：</p>
<pre><code class="language-javascript">let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             //  [1, 2, 3, 4, 5]
</code></pre>
<p>在这里，用一个含有重复元素的数组初始化 Set 集合，集合会自动移除这些重复元素；然后再用展开运算符将这些元素放到一个新数组中。</p>
<h3 id="weak-set-集合">Weak Set 集合</h3>
<p>将对象存储在 Set 的实例与存储在变量中完全一样，只要 Set 实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间，于是可以将前面的 Set 类型看作是一个<strong>强引用</strong>的 Set 集合。</p>
<p>为了解决这个问题，ES6 引入了另外一个类型：Weak Set 集合（弱引用 Set 集合）。Weak Set 集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</p>
<p>用 WeakSet 构造函数可以创建 Weak Set 集合，集合支持 3 个方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<p>示例如下：</p>
<pre><code class="language-javascript">let set = new WeakSet(),
    key = {};

//  向集合 set 中添加元素
set.add(key);

console.log(set.has(key));          //  true

set.delete(key);

console.log(set.has(key));          //  false
</code></pre>
<p>WeakSet 构造函数也可以传入一个可迭代对象来创建 Weak Set 集合：</p>
<pre><code class="language-javascript">let key1 = {},
    key2 = {},
    set = new WeakSet([key1, key2]);

console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true
</code></pre>
<p><strong>注意</strong>：WeakSet 构造函数不接受任何原始值，如果数组中包含其他非对象值，程序会抛出错误。</p>
<h3 id="两种-set-类型的主要区别">两种 Set 类型的主要区别</h3>
<p>两种 Set 类型之间最大的区别是 <strong>Weak Set 保存的是对象值得弱引用</strong>。</p>
<p>普通 Set 集合和 Weak Set 集合还有下面几个特性：</p>
<ul>
<li>在 WeakSet 实例中，如果向 <code>add()</code> 方法传入非对象参数会导致程序报错，而向 <code>has()</code> 和 <code>delete()</code> 方法传入非对象参数则会返回 false。</li>
<li>Weak Set 集合不可迭代，所以不能被用于 for-of 循环。</li>
<li>Weak Set 集合不暴露任何迭代器，所以无法通过程序本身来检测其中的内容。</li>
<li>Weak Set 集合不支持 forEach() 方法。</li>
<li>Weak Set 集合不支持 size 属性。</li>
</ul>
]]></content>
    </entry>
</feed>