<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pineapple126.github.io/</id>
    <title>深海大菠萝盖饭</title>
    <updated>2020-04-01T04:39:50.063Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pineapple126.github.io/"/>
    <link rel="self" href="https://pineapple126.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://pineapple126.github.io/images/avatar.png</logo>
    <icon>https://pineapple126.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 深海大菠萝盖饭</rights>
    <entry>
        <title type="html"><![CDATA[李兵专栏阅读记录]]></title>
        <id>https://pineapple126.github.io/post/li-bing-zhuan-lan-yue-du-ji-lu/</id>
        <link href="https://pineapple126.github.io/post/li-bing-zhuan-lan-yue-du-ji-lu/">
        </link>
        <updated>2021-04-08T13:40:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="chrome-架构">Chrome 架构</h2>
<h3 id="进程和线程">进程和线程</h3>
<p><strong>进程</strong>：<strong>一个进程就是一个程序的实例</strong>。当我们启动一个程序时，操作系统会为该程序创建一块内存，用来存放有效代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫做<strong>进程</strong>。（进程支持并行处理任务）</p>
<p><strong>线程</strong>：线程就是由进程来启动和管理的用于执行任务的一种结构。线程是不能单独存在的。</p>
<p>线程是依附于进程的，而进程中使用多线程并行处理能提高运算效率。</p>
<p><strong>进程和线程的之间的关系：</strong></p>
<pre><code>1. 进程中的任意一线程执行出错，都会导致整个进程崩溃；
2. 线程之间共享进程中的数据；
3. 当一个进程关闭之后，操作系统会回收进程所占用的所有内存；
4. 进程之间的内容相互隔离。
</code></pre>
<h3 id="单进程浏览器时代">单进程浏览器时代</h3>
<p><strong>单进程浏览器是指浏览器的所有功能模块都运行在一个进程里</strong>，这些模块包括了网络、插件、JavaScript 运行环境、渲染引擎和页面等。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1585655641805.png" alt="单进程浏览器架构示意图" loading="lazy"></figure>
<p>如此多的模块放在同一个进程内运行是导致单进程浏览器<strong>不稳定</strong>、<strong>不流畅</strong>和<strong>不安全</strong>的主要因素。</p>
<h3 id="多进程浏览器时代">多进程浏览器时代</h3>
<p><strong>早期多进程架构</strong></p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1585661831782.png" alt="早期 Chrome 进程架构图" loading="lazy"></figure>
<p>不同进程之间的相互隔离解决了<strong>不稳定</strong>的问题；每个页面拥有一个渲染进程，即使 JavaScript 阻塞了渲染进程，也只是影响当前的渲染页面，从而解决了<strong>不流畅</strong>的问题；采用多进程架构的好处是可以使用<strong>安全沙盒</strong>，我们可以将沙盒看成是操作系统给进程上了一把锁，沙盒里面的</p>
<h2 id="什么是执行上下文executing-context">什么是执行上下文（Executing Context）？</h2>
<p>执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。分为全局执行上下文和函数执行上下文。</p>
<ul>
<li>当 JavaScript 执行全局代码时，会编译全局代码并创建一个全局执行上下文，在代码的生命周期内，全局执行上下文只有一个。</li>
<li>当调用一个函数时，会编译函数代码并创建一个函数执行上下文，一般情况下，函数执行完成后，该函数执行上下文会被销毁。</li>
</ul>
<h2 id="什么是调用栈call-stack">什么是调用栈（Call Stack）？</h2>
<p>调用栈就是用来管理函数调用关系的一种数据结构，也是 JavaScript 引擎追踪函数执行的一个机制。调用栈又称执行栈，用于存储代码执行期间创建的所有执行上下文。</p>
<h2 id="什么是作用域scope">什么是作用域（Scope）？</h2>
<p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗得理解，作用域就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性与生命周期。</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<h2 id="什么是作用域链scope-chain">什么是作用域链（Scope Chain）？</h2>
<p>当我们在当前作用域内查找某个变量时，会一层一层的向外层作用域去寻找，直至找到该变量。若直至全局作用域还是没有找到该变量，就宣布放弃。这个通过作用域寻找变量的链条就成为作用域链。</p>
<h2 id="什么是词法作用域lexical-scope">什么是词法作用域（Lexical Scope）？</h2>
<p>词法作用域就是指作用域由代码中的函数声明的位置来决定的，所以词法作用域就是静态的作用域，通过它我们可以预测代码在执行过程中如何查找标识符。（词法作用域是在代码阶段就确定的，和函数的调用位置没有关系）</p>
<h2 id="什么是闭包">什么是闭包？</h2>
<p>在 JavaScript 中，根据词法作用域的规则，内部函数可以访问在外部函数中声明的变量。当通过调用一个外部函数返回一个内部函数后，即使外部函数已经执行完毕了，但是内部函数引用外部函数的变量仍然保存在内存中。我们把这些被引用的变量的集合称作闭包。</p>
<h2 id="new-运算符执行的操作">new 运算符执行的操作？</h2>
<pre><code>1. 创建一个空对象；
2. 将该对象的原型设置为构造函数的原型；
3. 将构造函数的 this 值指向该对象；
4. 若构造函数存在返回值且不为对象，则返回该对象。
</code></pre>
<pre><code class="language-javascript">function objectFactory() {
    var obj = new Object();
    Constructor = [].shift.call(arguments);
    obj.__proto__ = Constructor.prototype;
    var ret = Constructor.apply(obj, arguments);
    return Object.prototype.toString.call(ret) === &quot;[object Object]&quot;
        ? ret : obj;
}
</code></pre>
<h2 id="什么是回调函数">什么是回调函数？</h2>
<p>当我们把一个函数作为参数传递给另外一个函数时，这个被当作参数的函数就是回调函数。</p>
<p>我们把回调函数在主函数返回之前执行的回调过程称为同步回调；回调函数是在主函数外部执行的回调过程称为异步回调。</p>
<h2 id="什么是消息队列和事件循环">什么是消息队列和事件循环？</h2>
<p>消息队列是一种数据结构，可以存放将要执行的任务。而主线程不断从消息队列的头部取出任务并执行的过程称为事件循环。</p>
<p>不过随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒已经不能胜任部分领域的任务。为了实现任务执行时的实时性和效率的权衡，因此引入了宏任务和微任务的概念。</p>
<p>宏任务就是在任务队列中的任务；微任务是一个需要异步执行的函数，它的执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<p>当主线程从消息队列中取出宏任务执行时，JS 引擎会为当前宏任务创建执行上下文的同时再创建一个微任务队列，用于存储当前宏任务在执行过程中产生的微任务。</p>
<p>在当前主函数执行结束之后，宏任务结束之前会执行微任务队列中的任务，微任务执行过程中产生的微任务会再添加到当前微任务队列中，直至为任务队列为空结束。</p>
<p>宏任务：</p>
<ul>
<li>I/O</li>
<li>setTimeout</li>
<li>setInterval</li>
</ul>
<p>微任务：</p>
<ul>
<li>process.nextTick（Node）</li>
<li>promise 产生的回调函数</li>
<li>MutationObserver（浏览器）</li>
</ul>
<h3 id="事件循环执行顺序">事件循环执行顺序</h3>
<pre><code>1. 一开始将整个脚本作为一个宏任务执行
2. 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列
3. 当前宏任务执行完后，检查其微任务队列，有则依次执行，知道全部执行完，然后当前宏任务出队
4. 执行浏览器 UI 线程的渲染工作
5. 检查是否有 Web Worker 任务，有则执行
6. 执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列都为空
</code></pre>
<h2 id="promise">Promise</h2>
<p>Promise 解决了异步编码风格的问题。传统异步编码中，如果异步之间存在依赖关系，就需要层层嵌套回调来满足依赖关系。如果嵌套层数过多就会产生“回调地狱”，而 Promise 将嵌套回调模式改变为链式回调，从而避免产生“回调地狱”。</p>
<p>Promise 通过以下两步解决回调地狱问题：</p>
<pre><code>1. Promise 实现了回调函数的延时绑定
2. 将回调函数的返回值穿透到最外层
</code></pre>
<p>重点部分：Promise 回调函数的延时绑定、Promise 回调函数返回值穿透、Promise 出错的冒泡传递机制</p>
<p>then 函数传入的参数期待值为函数，若不为函数则会发生值穿透问题。</p>
<h3 id="promise-练习题">Promise 练习题</h3>
<ol>
<li>使用 Promise 实现间隔 1s，依次输出 1，2，3</li>
</ol>
<ul>
<li>先上一个简易版的</li>
</ul>
<pre><code class="language-javascript">Promise.resolve()
    .then(() =&gt; {
        return new Promise(r =&gt; {
            setTimeout(() =&gt; {
                r(console.log(1));
            }, 1000);
        })
    })
    .then(() =&gt; {
        return new Promise(r =&gt; {
            setTimeout(() =&gt; {
                r(console.log(2));
            }, 1000);
        })
    })
    .then(() =&gt; {
        return new Promise(r =&gt; {
            setTimeout(() =&gt; {
                r(console.log(3));
            }, 1000);
        })
    });
</code></pre>
<ul>
<li><code>Promise</code> + <code>Array#reduce()</code> 实现</li>
</ul>
<pre><code class="language-javascript">const arr = [1, 2, 3];
arr.reduce((p, x) =&gt; {
    return p.then(() =&gt; {
        return new Promise(r =&gt; {
            setTimeout(() =&gt; {
                r(console.log(x))
            }, 1000);
        });
    });
}, Promise.resolve());
</code></pre>
<ol start="2">
<li>使用 Promise 实现红绿灯交替重复</li>
</ol>
<pre><code class="language-javascript">function red() {
    console.log(&quot;red&quot;);
}

function yellow() {
    console.log(&quot;yellow&quot;);
}

function green() {
    console.log(&quot;green&quot;);
}

const light = function(timer, cb) {
    return new Promise(resolve =&gt; {
        setTimeout(() =&gt; {
            cb();
            resolve();
        }, timer);
    });
}

const step = function() {
    Promise.resolve().then(() =&gt; {
        return light(3000, red);
    }).then(() =&gt; {
        return light(2000, yellow);
    }).then(() =&gt; {
        return light(1000, green);
    }).then(() =&gt; {
        return step();
    });
}

step();
</code></pre>
<ol start="3">
<li>实现 mergePromise 函数</li>
</ol>
<p>实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放入到数组 data 中。</p>
<p>求解思路：</p>
<ul>
<li>定义一个 <code>data</code> 存储所有异步操作的结果</li>
<li>初始化一个 <code>const promise = Promise.resolve()</code>，然后循环遍历数组，在 <code>promise</code> 后面添加执行ajax任务，同时要将添加的结果重新赋值到 <code>promise</code> 上。</li>
</ul>
<pre><code class="language-javascript">const time = (timer) =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve()
    }, timer)
  })
}
const ajax1 = () =&gt; time(2000).then(() =&gt; {
  console.log(1);
  return 1
})
const ajax2 = () =&gt; time(1000).then(() =&gt; {
  console.log(2);
  return 2
})
const ajax3 = () =&gt; time(1000).then(() =&gt; {
  console.log(3);
  return 3
})

function mergePromise (ajaxArray) {
  // 存放每个ajax的结果
  const data = [];
  let promise = Promise.resolve();
  ajaxArray.forEach(ajax =&gt; {
  	// 第一次的then为了用来调用ajax
  	// 第二次的then是为了获取ajax的结果
    promise = promise.then(ajax).then(res =&gt; {
      data.push(res);
      return data; // 把每次的结果返回
    })
  })
  // 最后得到的promise它的值就是data
  return promise;
}

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {
  console.log(&quot;done&quot;);
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]

</code></pre>
<h2 id="asyncawait">async/await</h2>
<p>Promise 将异步回调函数处理线性化，但是太多的 then 函数使得代码不容易阅读，因此 ES 2016 引入了 async/await，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并使得代码逻辑更加清晰。</p>
<p>asnyc：async 是一个通过<strong>异步执行</strong>并**隐式返回一个 Promise **作为结果的函数。</p>
<p>await：执行 await 时，会默认创建一个 Promise 对象，并将其返回。</p>
<p>async 中 await 的 new Promise 如果没有返回值则不执行后面的内容。</p>
<p><em>协程</em>：协程是一种比线程更加轻量级的存在。一个线程可以拥有多个协程，同一线程的不同协程之间是交互执行而非并发执行。若现在执行 A 协程，接下来如果要执行 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程。如果 A 协程启动 B 协程，则称 A 协程是 B 协程的父协程。</p>
<h2 id="创建对象的方式">创建对象的方式</h2>
<pre><code>1. 对象字面量
2. DOM API （document.createElement)
3. JS 内置对象的 API
4. 装箱转换
</code></pre>
<h2 id="this-关键字">this 关键字</h2>
<p>this 是和执行上下文绑定的，指向变量或者函数的上下文环境。</p>
<h3 id="this-的五种绑定方式">this 的五种绑定方式</h3>
<ol>
<li>默认绑定：this 默认指向全局对象（严格模式下函数中的 this 指向 <code>undefined</code>）</li>
<li>隐式绑定：this 指向最后调用它的对象
<blockquote>
<p>隐式绑定的隐式丢失：被隐式绑定的函数在特定情况下会丢失绑定对象</p>
<ul>
<li>使用另一个变量来给函数起别名</li>
<li>将函数作为参数传递时会被隐式赋值，回调函数丢失 this 值</li>
</ul>
</blockquote>
</li>
<li>显示绑定：通过 call、apply、bind 改变 this 指向</li>
<li>new 绑定：使用 new 来调用一个函数，会构造一个新对象并把这个新对象绑定到调用函数中的 this</li>
<li>箭头函数绑定：箭头函数中的 this 是由外层作用域来决定的，且指向函数定义时的 this 而非执行时</li>
</ol>
<h3 id="this-的缺陷">this 的缺陷</h3>
<pre><code>1. 嵌套函数中的 this 不会从外层函数中继承；
2. 普通函数的 this 默认指向全局对象 window</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 23 合并K个排序链表（分治）]]></title>
        <id>https://pineapple126.github.io/post/leetcode-23-mergeKLists/</id>
        <link href="https://pineapple126.github.io/post/leetcode-23-mergeKLists/">
        </link>
        <updated>2020-03-23T11:16:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>问题描述：</strong></p>
<p>合并 k 个排序链表，返回合并后的排序链表。</p>
<p><strong>示例：</strong></p>
<pre><code>输入:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre>
<p><strong>基本思路：</strong></p>
<p>对于合并两个排序链表的问题，我们可以轻松解决。只要创建一个新的哑巴节点，再选择两个链表头节点较小的一个与哑巴节点链接起来，循环该操作，直至合并完成。</p>
<p>那么对于合并K个排序链表，我们可以运用分治的思想，不断地将数组不断拆分。（我们用数组 lists 存储着这些链表）</p>
<p>这里借用官方题解的一张图片：</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1584964378982.png" alt="分治演示" loading="lazy"></figure>
<p>那么拆分过程中有以下情形：</p>
<ul>
<li>
<p><code>lists.length === 0</code>        数组 lists 中已无链表，则返回一个空节点；</p>
</li>
<li>
<p><code>lists.length === 1</code>        数组 lists 中仅剩一个链表，因此直接返回该链表；</p>
</li>
<li>
<p><code>lists.length === 2</code>        数组 lists 中有两个链表，我们执行合并操作；</p>
</li>
<li>
<p><code>other</code>         数组 lists 中的链表数过多，需要继续拆分。</p>
</li>
<li>
<p>时间复杂度：O(nlogK)</p>
<ul>
<li>k 为链表总数</li>
<li>n 为合并两个链表所用的时间</li>
</ul>
</li>
<li>
<p>空间复杂度：O(n)</p>
</li>
</ul>
<p>代码如下：</p>
<pre><code class="language-javascript">/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
    // 如果列表中的 链表 为空 则直接返回
    if (lists.length === 0) return null;
    // 如果列表中的 链表 只剩一个直接返回
    if (lists.length === 1) return lists[0];
    // 如果列表中的 链表 有两个 则合并两个链表
    if (lists.length === 2) return mergeTwoLists(lists[0], lists[1]);
    // 否则继续拆分
    let mid = lists.length &gt;&gt; 1;
    let left = lists.slice(0, mid),
        right = lists.slice(mid);
    return mergeTwoLists(mergeKLists(left), mergeKLists(right));
};

function mergeTwoLists(list1, list2) {
    let ans = new ListNode(-1),
        preAns = ans;
    while(list1 &amp;&amp; list2) {
        if (list1.val &lt; list2.val) {
            preAns.next = list1;
            list1 = list1.next;
        } else {
            preAns.next = list2;
            list2 = list2.next;
        }
        preAns = preAns.next;
    }
    preAns.next = list1 ? list1 : list2;
    return ans.next;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事件委托]]></title>
        <id>https://pineapple126.github.io/post/event-delegation/</id>
        <link href="https://pineapple126.github.io/post/event-delegation/">
        </link>
        <updated>2020-03-21T10:08:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="概念">概念</h2>
<p>事件委托就是通过事件冒泡的机制，利用父级元素去触发子级元素的事件。</p>
<p>使用事件委托可以减少内存开销，提高性能。</p>
<h2 id="示例">示例</h2>
<p>例如，我们要对一堆 li 元素绑定相同的事件，如果将事件都绑定到 li 元素上，会增加内存开销、降低性能。而我们可以将事件侦听器绑定到这些 li 元素的父级元素 ul 或 ol 元素上，这样子我们仅需绑定一次事件。当我们需要触发事件时，会通过冒泡机制传递给父级元素触发事件。</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
    &lt;li&gt;something&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    /* 事件委托的核心原理：给父节点添加侦听器，
        利用事件冒泡机制影响每一个子节点 */
        var ul = document.querySelector(&quot;ul&quot;);
        ul.addEventListener(&quot;click&quot;, function(e) {
            //  e.target 可以得到我们点击的对象
            e.target.style.backgroundColor = &quot;red&quot;;
        });
&lt;/script&gt;
</code></pre>
<p>在这个示例中：</p>
<ul>
<li>我们只操作了一次 DOM，提高了程序的性能</li>
<li>动态创建的子元素，也将拥有事件</li>
</ul>
<h2 id="总结">总结</h2>
<p>综上所述，当我们需要给一组元素添加相同事件时，我们可以通过事件委托的方式将事件直接添加给父级元素。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的三序遍历]]></title>
        <id>https://pineapple126.github.io/post/traversal-binary-tree/</id>
        <link href="https://pineapple126.github.io/post/traversal-binary-tree/">
        </link>
        <updated>2020-03-20T02:48:14.000Z</updated>
        <content type="html"><![CDATA[<h2 id="先序遍历preordertraversal">先序遍历（preorderTraversal）</h2>
<p>节点遍历顺序：根 -&gt; 左 -&gt; 右</p>
<h3 id="递归方式">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    return [
        root.val,
        ...preorderTraversal(root.left),
        ...preorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="迭代方式">迭代方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function preorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            res.push(curr.val);
            curr = curr.left;
        }
        curr = stack.pop();
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="中序遍历inordertraversal">中序遍历（inorderTraversal）</h2>
<p>节点遍历顺序：左 -&gt; 根 -&gt; 右</p>
<h2 id="递归方式-2">递归方式</h2>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    return [
        ...inorderTraversal(root.left),
        root.val,
        ...inorderTraversal(root.right)
    ];
}
</code></pre>
<h3 id="迭代方式-2">迭代方式</h3>
<p>利用栈存储遍历的节点</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function inorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        while(curr) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        res.push(curr.val);
        curr = curr.right;
    }
    return res;
}
</code></pre>
<h2 id="后序遍历postordertraversal">后序遍历（postorderTraversal)</h2>
<p>节点遍历顺序：左 -&gt; 右 -&gt; 根</p>
<h3 id="递归方式-3">递归方式</h3>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    return [
        ...postorderTraversal(root.left),
        ...postorderTraversal(root.right),
        root.val
    ];
}
</code></pre>
<h3 id="迭代方式-3">迭代方式</h3>
<p><strong>方式一：正序解</strong></p>
<p>实现（1）：如果某一结点的子节点已被遍历过，则将其子节点指向 null。（整个过程就像是给一棵树不断地修剪叶子一样）</p>
<p>基本思路：</p>
<ol>
<li>先遍历左节点，当遍历到叶子节点时，记录其值；</li>
<li>返回至该叶子节点的上一层，并让该叶子节点指向 null；</li>
<li>再遍历右节点，当遍历到叶子节点时，记录值；</li>
<li>再次返回上一层节点，顺便让该叶子节点指向 null。</li>
</ol>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length &gt; 0) {
        if (curr.left) {
            stack.push(curr);
            curr = curr.left;
        } else if (curr.right) {
            stack.push(curr);
            curr = curr.right;
        } else {
            res.push(curr.val);
            curr = stack.pop();
            if (curr &amp;&amp; curr.left) curr.left = null;
            else if (curr &amp;&amp; curr.right) curr.right = null;
        }
    }
    return res;
}
</code></pre>
<p>实现（2）：添加标志位 flag，当某一节点的左右子节点的值都已被记录时 flag 为 true，否则为 false。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while (curr || stack.length &gt; 0) {
        while(curr) {
            stack.push([curr, false]);
            curr = curr.left;
        }
        let [node, flag] = stack.pop();
        if (!flag) {
            stack.push([node, true]);
            curr = node.right;
        } else {
            res.push(node.val);
        }
    }
    return res;
}
</code></pre>
<p><strong>方式二：倒序解</strong></p>
<p>思路：该方式类似于先序遍历，只是遍历顺序为 根 -&gt; 右 -&gt; 左。而记录值是从数组的头部插入。</p>
<pre><code class="language-javascript">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
function postorderTraversal(root) {
    if (!root) return [];
    let res = [],
        stack = [],
        curr = root;
    while(curr || stack.length) {
        while(curr) {
            stack.push(curr);
            res.unshift(curr.val);
            curr = curr.right;
        }
        curr = stack.pop();
        curr = curr.left;
    }
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法]]></title>
        <id>https://pineapple126.github.io/post/sort-algorithm/</id>
        <link href="https://pineapple126.github.io/post/sort-algorithm/">
        </link>
        <updated>2020-03-19T03:05:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="快速排序">快速排序</h2>
<p>基本思想：采用分治的思想，选取一个基准，将待排序数组分为两个小、大数组，不断重复这个过程直至数组有序。</p>
<p>基本步骤：</p>
<ol>
<li>选取基准（pivot）；</li>
<li>根据基准将待排序数组分割为两个数组；</li>
<li>重复以上步骤，直至数组有序。</li>
</ol>
<pre><code class="language-javascript">function quickSort(arr) {
    if (arr.length &lt; 2) return arr;
    let pivot = arr[0];
    let left = [],
        right = [];
    for(let i  = 1; i &lt; arr.length; i++) {
        if (arr[i] &lt; pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat(pivot, quickSort(right));
}
</code></pre>
<h2 id="插入排序">插入排序</h2>
<p>基本思想：将数组的第一位视为一个有序数组，将剩下的待排序数组逐个插入到已排序数组中。</p>
<pre><code class="language-javascript">function insertSort(arr) {
    for(let i = 1; i &lt; arr.length; i++) {
        let tmp = arr[i],
            j = i;
        for( ; j &gt; 0; j--) {
            if (tmp &gt; arr[j-1]) {
                break;
            }
            arr[j] = arr[j-1];
        }
        arr[j] = tmp;
    }
    return arr;
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>基本思想：采取分治的思想，将两个有序数组合并为一个有序数组。</p>
<pre><code class="language-javascript">function mergeSort(arr) {
    if (arr.length &lt; 2) return arr;
    let res = [];
    let mid = arr.length &gt;&gt; 1;
    let left = mergeSort(arr.slice(0, mid)),
        right = mergeSort(arr.slice(mid));
    while(left.length &amp;&amp; right.length) {
        if (left[0] &lt; right[0]) {
            res.push(left.shift());
        } else {
            res.push(right.shift());
        }
    }
    return res.concat(left, right);
}
</code></pre>
<h2 id="冒泡排序">冒泡排序</h2>
<pre><code class="language-javascript">function bubbleSort(arr) {
    for(let i = 0; i &lt; arr.length; i++) {
        for(let j = 0; j &lt; arr.length - i - 1; j++) {
            if (arr[j] &gt; arr[j+1]) {
                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
            }
        }
    }
    return arr;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[类型判断]]></title>
        <id>https://pineapple126.github.io/post/type-judgement/</id>
        <link href="https://pineapple126.github.io/post/type-judgement/">
        </link>
        <updated>2020-03-13T08:47:22.000Z</updated>
        <content type="html"><![CDATA[<p>JavaScript 中有 8 种数据类型，又分为基本数据类型和引用数据类型。</p>
<ul>
<li>基本数据类型：Null、Undefined、Number、Boolean、String、Symbol、BigInt</li>
<li>引用数据类新：Object</li>
</ul>
<p>判断数据类型的方法有以下几种：<code>typeof</code> 运算符、<code>instanceof</code> 运算符、<code>constructor</code> 方法和 <code>Object.prototype.toString.call()</code> 方法</p>
<p>我们先创建这些数据类型的变量：</p>
<pre><code class="language-javascript">let nul = null,
    und= undefined,
    num = 1,
    bool = true,
    str = &quot;string&quot;,
    sym = Symbol(),
    bigint = 1n,
    obj = {name: &quot;zs&quot;},
    arr = [1, 2, 3],
    fn = function() { console.log(&quot;function&quot;); };
</code></pre>
<h2 id="typeof">typeof</h2>
<p><code>typeof</code> 可以识别出数据类型，但是不能识别 null 和 array，会将它们归为 Object 类型。判断示例如下：</p>
<pre><code class="language-javascript">console.log(typeof nul);            //  object
console.log(typeof und);            //  undefined
console.log(typeof num);            //  number
console.log(typeof bool);           //  boolean
console.log(typeof str);            //  string
console.log(typeof sym);            //  symbol
console.log(typeof bigint);         //  bigint
console.log(typeof obj);            //  object
console.log(typeof arr);            //  object
console.log(typeof fn);         //  function
</code></pre>
<h2 id="instanceof">instanceof</h2>
<p><code>instanceof</code> 不能识别基本数据类型，但是可以识别出 Array、Function 与 Object。同时，对于 new 声明的类型，还可以检测出多层继承关系。</p>
<pre><code class="language-javascript">console.log(nul instanceof Object);         //  false
console.log(und instanceof Object);         //  false
console.log(num instanceof Number);         //  false
console.log(bool instanceof Boolean);           //  false
console.log(str instanceof String);         //  false
console.log(sym instanceof Symbol);         //  false
console.log(bigint instanceof BigInt);          //  false
console.log(obj instanceof Object);         //  true
console.log(arr instanceof Array);          //  true
console.log(fn instanceof Function);            //  true
</code></pre>
<h2 id="constructor">constructor</h2>
<p>null、undefined 没有 constructor 方法，因此 constructor 不能用于判断 null 和 undefined。并且，constructor 是不安全的，因此 constructor 的指向是可以被改变的。</p>
<pre><code class="language-javascript">console.log(num.constructor === Number);            //  true
console.log(bool.constructor === Boolean);          //  true
console.log(str.constructor === String);            //  true
console.log(sym.constructor === Symbol);            //  true
console.log(bigint.constructor === BigInt);         //  true
console.log(obj.constructor === Object);            //  true
console.log(arr.constructor === Array);         //  true
console.log(fn.constructor === Function);           //  true
</code></pre>
<h2 id="objectprototypetostringcall">Object.prototype.toString.call()</h2>
<p>该方法可以相对较全的判断 JavaScript 的数据类型。</p>
<pre><code class="language-javascript">console.log(Object.prototype.toString.call(nul));           //  [object Null]
console.log(Object.prototype.toString.call(und));           //  [object Undefined]
console.log(Object.prototype.toString.call(num));           //  [object Number]
console.log(Object.prototype.toString.call(bool));          //  [object Boolean]
console.log(Object.prototype.toString.call(str));           //  [object String]
console.log(Object.prototype.toString.call(sym));           //  [object Symbol]
console.log(Object.prototype.toString.call(bigint));            //  [object BigInt]
console.log(Object.prototype.toString.call(obj));           //  [object Object]
console.log(Object.prototype.toString.call(arr));           //  [object Array]
console.log(Object.prototype.toString.call(fn));            //  [object Function]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map集合（2）]]></title>
        <id>https://pineapple126.github.io/post/map/</id>
        <link href="https://pineapple126.github.io/post/map/">
        </link>
        <updated>2020-03-12T03:16:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="es6-中的-map-集合">ES6 中的 Map 集合</h2>
<p>ES6 中的 Map 类型是一种<strong>储存着许多键值对</strong>的<strong>有序列表</strong>，其中的键名和对应的值支持所有的数据类型。键名的等价性判断是通过调用 <code>Object.is()</code> 方法实现的，所以数字 5 与字符串 &quot;5&quot; 会被判定为两种类型，可以分别作为独立的两个键出现在程序中。</p>
<h3 id="map-集合创建方法以及支持的方法和属性">Map 集合创建方法以及支持的方法和属性</h3>
<p>创建方法：调用 <code>new Map()</code> 即可创建一个 Map 集合。</p>
<p>支持方法：</p>
<ul>
<li><code>set(key, value)</code> 方法：向 Map 集合中添加新的元素；</li>
<li><code>get(key)</code> 方法：从 Map 集合中获取信息，若传入的键名不存在，则返回 undefined；</li>
<li><code>has(key)</code> 方法：检测指定的键名在 Map 集合中是否已经存在；</li>
<li><code>delete(key)</code> 方法：从 Map 集合中移除指定键名及其对应的值；</li>
<li><code>clear()</code> 方法：移除 Map 集合中所有的键值对；</li>
<li><code>size</code> 属性：获取当前集合中包含的键值对数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new Map();
map.set(&quot;name&quot;, &quot;Nicholas&quot;);
map.set(&quot;age&quot;, 25);

console.log(map.size);          //  2

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;

console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25

map.delete(&quot;name&quot;);
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.size);          //  1

map.clear();
console.log(map.has(&quot;name&quot;));           //  false
console.log(map.get(&quot;name&quot;));           //  undefined
console.log(map.has(&quot;age&quot;));            //  false
console.log(map.get(&quot;age&quot;));            //  undefined
console.log(map.size);          //  0
</code></pre>
<p>也可以向 Map 构造函数传入数组来初始化一个 Map 集合，数组中的每一个元素都是一个子数组，子数组包含一个键值对的键名与值两个元素。示例如下：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

console.log(map.has(&quot;name&quot;));           //  true
console.log(map.get(&quot;name&quot;));           //  &quot;Nicholas&quot;
console.log(map.has(&quot;age&quot;));            //  true
console.log(map.get(&quot;age&quot;));            //  25
console.log(map.size);          //  2
</code></pre>
<h3 id="map-集合中的-foreach-方法">Map 集合中的 forEach() 方法</h3>
<p>Map集合的 <code>forEach()</code> 方法与 Set 集合和数组中的 <code>forEach()</code> 方法类似，回调函数都接受 3 个参数：</p>
<ul>
<li>Map 集合中下一次索引的值</li>
<li>值对应的键名</li>
<li>Map 集合本身</li>
</ul>
<p>这些回调参数与数组中的更相近，第一个参数是值，第二个参数是键名。请看这个示例：</p>
<pre><code class="language-javascript">let map = new Map([[&quot;name&quot;, &quot;Nicholas&quot;], [&quot;age&quot;, 25]]);

map.forEach(function (value, key, ownerMap) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerMap === map);
});
</code></pre>
<p>这段代码会输出以下内容：</p>
<pre><code class="language-javascript">name Nicholas
true
age 25
true
</code></pre>
<p>遍历过程中，会按照键值对插入 Map 集合的顺序将相应信息传入 <code>forEach()</code> 方法的回调函数，而在数组中，则会按照数值型索引值的顺序依次传入回调函数。</p>
<p><strong>注意</strong>：可以指定 <code>forEach()</code> 函数的第二个参数作为回调函数的 <code>this</code> 值。</p>
<h2 id="weak-map-集合">Weak Map 集合</h2>
<p>Weak Set 集合是弱引用的 Set 集合，相对应的，Weak Map 集合是弱引用的 Map 集合，也用于存储对象的弱引用。Weak Map 集合中的键名必须是一个对象。集合中保存的是这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的键值对。但是只有集合的键名遵从这个规则，键名对应的值如果是个对象，则保存的是对象的强引用，不会触发垃圾回收机制。</p>
<p>Weak Map 集合最大的用途是跟踪 Web 页面中的 DOM 元素，当 DOM 元素消失时，可以自动销毁集合中的相关对象。</p>
<h3 id="使用-weak-map-集合">使用 Weak Map 集合</h3>
<p>ES6 中的 Weak Map 类型是一种存储着许多键值对的无序列表，列表的键名必须是非 null 类型的对象，键名对应的值则可以是任意类型。</p>
<p>我们可以通过 WeakMap 构造函数来创建一个 Weak Map 集合。Weak Map 集合也支持以下方法：</p>
<ul>
<li><code>set()</code></li>
<li><code>get()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let map = new WeakMap(),
    element = document.querySelector(&quot;.element&quot;);

map.set(element, &quot;Original&quot;);

console.log(map.has(element));          //  true
console.log(map.get(element));          //  &quot;Original&quot;

map.delete(element);
console.log(map.has(element));          //  false
console.log(map.get(element));          //  undefined
</code></pre>
<h2 id="小结">小结</h2>
<p>Set 集合是一种包含多个非重复值的有序列表，值与值之间的等价性是通过 <code>Object.is()</code> 方法来判断的，如果相同，则会自动过滤重复的值，所以可以用 Set 集合来过滤数组中的重复元素。</p>
<p>Weak Set 集合是一类特殊的 Set 集合，集合只支持存放对象的弱引用。由于内存管理非常复杂，Weak Set 集合不可以被检查，因此追踪成组的对象是该集合最好的使用方式。</p>
<p>Map 是多个键值对组成的有序集合，键名支持任意数据类型，与 Set 集合相似的是，Map 集合也是通过 <code>Object.is()</code> 方法来过滤重复值。</p>
<p>Weak Map 集合是一类特殊的 Map 集合，只支持对象类型的键名，集合中存放的键是对象的弱引用。Weak Map 集合可以为那些实际使用与生命周期管理分离的对象添加额外信息。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Set 集合与 Map 集合（1）]]></title>
        <id>https://pineapple126.github.io/post/set/</id>
        <link href="https://pineapple126.github.io/post/set/">
        </link>
        <updated>2020-03-09T11:55:04.000Z</updated>
        <content type="html"><![CDATA[<p>这是学习阅读《深入理解ES6》第七章 Set 集合与 Map 集合 后整理而成的学习笔记。</p>
<p>Set 集合是一种<strong>无重复元素</strong>的列表；Map 集合内含多组键值对，集合中每个元素分别存放着可访问的键名和它对应的值，Map 集合经常被用于缓存频繁取用的数据。</p>
<h2 id="es5-中的-set-集合与-map-集合">ES5 中的 Set 集合与 Map 集合</h2>
<p>在 ES5 中，开发者们用对象属性来模拟这两种集合：</p>
<pre><code class="language-javascript">var set = Object.create(null);

set.foo = true;

//  检查属性是否存在
if (set.foo) {
    //  要执行的代码
}
</code></pre>
<p>这里的变量 set 是一个原型为 null 的对象，不继承任何属性。在 ES5 中，开发者们经常使用类似的方法检查对象的某个属性值是否存在。</p>
<p>模拟这两种集合的唯一区别是存储的值不同，以下这个示例是用对象模拟 Map 集合：</p>
<pre><code class="language-javascript">var map = Object.create(null);
map.foo = &quot;bar&quot;;

//  获取已存值
var value = map.foo;

console.log(value);         //  &quot;bar&quot;
</code></pre>
<p>一般来说，Set 集合经常被用于检查对象中是否存在某个键名，而 Map 集合常被用于获取已存值的信息。</p>
<h3 id="该方案可能存在的问题">该方案可能存在的问题</h3>
<p>需要注意的是，所有对象的属性名必须是字符串类型，因此必须确保每个键名都是字符串类型且在对象中是唯一的。若以数字为属性名，数字则会被自动转换成字符串；若以对象为属性名，则会被自动转换为对象对应的默认字符串 &quot;[object Object]&quot;。如果不不注意的话，则内部的自动转换机制将会导致很多问题。</p>
<h2 id="es6-中的-set-集合">ES6 中的 Set 集合</h2>
<p>ES6 新增的 Set 类型是一种有序列表，其中含有一些<strong>相互独立</strong>的<strong>非重复值</strong>，通过 Set 集合可以快速访问其中的数据，更有效地追踪各种离散值。</p>
<h3 id="创建-set-集合以及支持的方法与属性">创建 Set 集合以及支持的方法与属性</h3>
<p>调用 <code>new Set()</code> 即可创建 Set 集合。</p>
<p>Set 集合支持以下方法和属性：</p>
<ul>
<li><code>add(value)</code> 方法，用于给 Set 集合添加元素；</li>
<li><code>has(value)</code> 方法，用于判断 Set 集合是否含有 value 值；</li>
<li><code>delete(value)</code> 方法，用于从 Set 集合中删除指定的 value 值；</li>
<li><code>clear()</code> 方法，用于清空 Set 集合；</li>
<li><code>size</code> 属性，可以获取集合中目前的元素数量。</li>
</ul>
<p>请看以下这段代码：</p>
<pre><code class="language-javascript">let set = new Set();
set.add(5);
set.add(&quot;5&quot;);

let key1 = {};
let key2 = {};
set.add(key1);
set.add(key2);

console.log(set.has(5));            //  true
console.log(set.has(&quot;5&quot;));          //  true
console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true

set.delete(5);
set.delete(key1);
console.log(set.has(5));            //  false
console.log(set.has(key1));            //  false
console.log(set.size);          //  2

set.clear();

console.log(set.has(&quot;5&quot;));          //  false
console.log(set.has(key2));         //  false
console.log(set.size);          //  0
</code></pre>
<p>通过这个示例，我们发现数字 5 和字符串 &quot;5&quot;、key1 和 key2 作为独立的值存储入 Set 集合中。实际上，在 Set 集合中，不会对所存值进行强制的类型转换，数字 5 和字符串 &quot;5&quot; 是作为两个独立元素存在，对象key1 和 key2 也不会被转换成字符串，因而两者在 Set 集合中是两个对立的元素。（引擎内部使用 <code>Object.is()</code> 方法检测两个值是否一致，唯一例外的是，Set 集合中的 +0 和 -0 被认为是相等的）</p>
<p><strong>提示</strong>：Set 构造函数可以接受所有可迭代对象作为参数，数组、Set 集合、Map 集合都是可迭代的，因而都可以作为 Set 构造函数的参数使用；构造函数通过迭代器从参数中提取值。</p>
<p>Set 构造函数同样会过滤掉重复的值从而保证集合中的元素各自唯一。示例如下：</p>
<pre><code class="language-javascript">let set = new Set([1,2,2,3,4,5,5,6]);

console.log(set.size);          //  6
</code></pre>
<h3 id="set-集合的-foreach-方法">Set 集合的 forEach() 方法</h3>
<p>ES6 也为 Set 集合添加了 <code>forEach()</code> 方法，其运行机制和数组的 <code>forEach()</code> 方法类似。</p>
<p><code>forEach()</code> 方法的回调函数接受以下 3 个参数：</p>
<ul>
<li>Set 集合中下一次索引的位置</li>
<li>与第一个参数一样的值</li>
<li>被遍历的 Set 集合本身</li>
</ul>
<p>数组和 Map 集合的 <code>forEach()</code> 方法的回调函数都是接受 3 个参数，前两个分别为值和键名，而 Set 集合没有键名，ES6 为了保持方法分歧不大，因此也将 Set 集合中的每个元素也按照键名和值的形式存储，从而保证所有 <code>forEach()</code> 方法的回调函数中前两个参数具有相同意义。</p>
<p>请看以下示例：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

set.forEach(function(value, index, ownerSet) {
    console.log(key + &quot; &quot; + value);
    console.log(ownerSet === set);
});
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-javascript">1 1
true
2 2
true
</code></pre>
<p>在 Set 集合的 <code>forEach()</code> 方法中，第二个参数也与数组的一样，如果需要在回调函数中使用 <code>this</code> 引用，则可以将它作为第二个参数传入 <code>forEach()</code> 函数：</p>
<pre><code class="language-javascript">let set = new Set([1, 2]);

let processor = {
    output(value) {
        console.log(value);
    },
    process(dataSet) {
        dataSet.forEach(function(value) {
            this.output(value);
        }, this);
    }
};

processor.process(set);
</code></pre>
<p>当然我们也可以使用箭头函数，这样在这里就不用向回调函数传入 <code>this</code> 参数了。</p>
<h3 id="将-set-集合转换为数组">将 Set 集合转换为数组</h3>
<p>将数组转换为 Set 集合的过程很简单，只需要给 Set 构造函数传入数组即可；将 Set 集合再转换回数组的过程也很简单，只需要使用<strong>展开运算符</strong>即可。（展开运算符可以将可迭代对象转换为数组）举个例子：</p>
<pre><code class="language-javascript">let set = new Set([1, 2, 3, 3, 3, 4, 5]),
    array = [...set];

console.log(array);             //  [1, 2, 3, 4, 5]
</code></pre>
<p>在这里，用一个含有重复元素的数组初始化 Set 集合，集合会自动移除这些重复元素；然后再用展开运算符将这些元素放到一个新数组中。</p>
<h3 id="weak-set-集合">Weak Set 集合</h3>
<p>将对象存储在 Set 的实例与存储在变量中完全一样，只要 Set 实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间，于是可以将前面的 Set 类型看作是一个<strong>强引用</strong>的 Set 集合。</p>
<p>为了解决这个问题，ES6 引入了另外一个类型：Weak Set 集合（弱引用 Set 集合）。Weak Set 集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</p>
<p>用 WeakSet 构造函数可以创建 Weak Set 集合，集合支持 3 个方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<p>示例如下：</p>
<pre><code class="language-javascript">let set = new WeakSet(),
    key = {};

//  向集合 set 中添加元素
set.add(key);

console.log(set.has(key));          //  true

set.delete(key);

console.log(set.has(key));          //  false
</code></pre>
<p>WeakSet 构造函数也可以传入一个可迭代对象来创建 Weak Set 集合：</p>
<pre><code class="language-javascript">let key1 = {},
    key2 = {},
    set = new WeakSet([key1, key2]);

console.log(set.has(key1));         //  true
console.log(set.has(key2));         //  true
</code></pre>
<p><strong>注意</strong>：WeakSet 构造函数不接受任何原始值，如果数组中包含其他非对象值，程序会抛出错误。</p>
<h3 id="两种-set-类型的主要区别">两种 Set 类型的主要区别</h3>
<p>两种 Set 类型之间最大的区别是 <strong>Weak Set 保存的是对象值得弱引用</strong>。</p>
<p>普通 Set 集合和 Weak Set 集合还有下面几个特性：</p>
<ul>
<li>在 WeakSet 实例中，如果向 <code>add()</code> 方法传入非对象参数会导致程序报错，而向 <code>has()</code> 和 <code>delete()</code> 方法传入非对象参数则会返回 false。</li>
<li>Weak Set 集合不可迭代，所以不能被用于 for-of 循环。</li>
<li>Weak Set 集合不暴露任何迭代器，所以无法通过程序本身来检测其中的内容。</li>
<li>Weak Set 集合不支持 forEach() 方法。</li>
<li>Weak Set 集合不支持 size 属性。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[防抖和节流]]></title>
        <id>https://pineapple126.github.io/post/debounce-and-throttle/</id>
        <link href="https://pineapple126.github.io/post/debounce-and-throttle/">
        </link>
        <updated>2020-03-06T11:36:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>防抖</strong>（debounce）：动作绑定事件，在动作发生一段时间后再触发事件。如果这段时间内动作再次发生，则重新等待一段时间后再触发事件。</p>
<p>第一版：根据防抖的定义简单实现防抖功能</p>
<pre><code class="language-javascript">function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;         //  记录调用对象的 this 值
        var args = arguments;           //  记录调用对象的 参数

        clearTimeout(timeout);
        timeout = setTimeout(() =&gt; {
            func.apply(context, args);
        }, wait);
    }
}
</code></pre>
<p>第二版：事件立即执行，然后再根据定义实现防抖</p>
<pre><code class="language-javascript">function debounce(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        //  如果 timeout = null 则立即执行
        if (!timeout) {
            func.apply(context, args);
            timeout = setTimeout(() =&gt; {
                timeout = null;
            }, wait);
        } else {
            timeout = setTimeout(() =&gt; {
                func.apply(context, args);
            }, wait);
        }
    }
}
</code></pre>
<p>第三版：将两种结合起来，并添加了手动取消定时器的功能</p>
<pre><code class="language-javascript">/**
 * @param { function } func
 * @param { number } wait 延迟执行毫秒数
 * @param { boolean } immediate  true 表立即执行，false 表非立即执行
 * @return { function }
 */
function debounce(func, wait, immediate) {
    var timeout;

    var debounced = function () {
        var context = this;
        var args = arguments;

        //  如果定时器存在，则清楚定时器，再重新计时
        if (timeout) clearTimeout(timeout);
        if (immediate) {
            //  如果已经执行过，则不再执行
            var callNow = !timeout;
            timeout = setTimeout(() =&gt; {
                timeout = null;
            }, wait);
            if (callNow) func.apply(context, args);
        } else {
            timeout = setTimeout(() =&gt; {
                func.apply(context, args);
            }, wait);
        }
    }
    return debounced;
}
</code></pre>
<p><strong>节流</strong>（throttle）：动作绑定事件，在动作发生一段时间后再触发事件。如果在这段时间内动作再次发生，则无视此次动作，等待事件完成后，才能重新触发。</p>
<p>第一版：时间戳版——使用时间戳，当事件触发时，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳；如果小于，则不必执行。</p>
<pre><code class="language-javascript">function throttle(func, wait) {
    var previous = 0;

    return function () {
        var context = this;
        var args = arguments;

        var now = +new Date();
        if (now - previous &gt; wait) {
            func.apply(context, this);
            previous = now;
        }
    }
}
</code></pre>
<p>第二版：定时器版——当事件触发的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，则不执行，直到定时器执行时执行事件函数，并清空定时器。</p>
<pre><code class="language-javascript">function throttle(func, wait) {
    var timeout;

    return function () {
        var context = this;
        var args = arguments;

        if (!timeout) {
            timeout = setTimeout(() =&gt; {
                timeout = null;
                func.apply(context, args);
            }, wait);
        }
    }
}
</code></pre>
<p>第三版：将时间戳版本与定时器版本合并起来</p>
<pre><code class="language-javascript">/**
 * @param { function } func 函数
 * @param { number } wait 延迟执行毫秒数
 * @param { number } type 1 表示时间戳版，2 表示定时器版
 * @return { function }
 */
function throttle(func, wait, type) {
    var previous = 0;
    var timeout;
    
    return function () {
        var context = this;
        var args = arguments;

        if (type === 1) {
            var now = +new Date();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        } else if (type === 2) {
            if (!timeout) {
                timeout = setTimeout(() =&gt; {
                    timeout = null;
                    func.apply(context, args);
                }, wait);
            }
        }

    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用模块封装代码]]></title>
        <id>https://pineapple126.github.io/post/module/</id>
        <link href="https://pineapple126.github.io/post/module/">
        </link>
        <updated>2020-02-28T08:12:23.000Z</updated>
        <content type="html"><![CDATA[<p>这是学习阅读《深入理解ES6》第十三章 用模块封装代码 后整理而成的学习笔记。</p>
<p>JavaScript 用“共享一切”的方法加载代码，这是语言中最容易出错且容易令人感到困惑的地方。为了解决作用域问题，也为了使 JavaScript 应用程序显得有序，因此 ES6 引入了模块。</p>
<h2 id="什么是模块">什么是模块</h2>
<p><strong>模块是自动运行在严格模式下并且没有办法退出运行的 JavaScript 代码</strong>。与共享一切架构相反的是，在模块顶部创建的变量不会自动被添加到全局共享作用域，这个变量仅在模块的顶级作用域中存在，而且模块必须导出一些外部代码可以访问的元素，比如变量或函数。模块也可以从其他模块导入绑定。在模块的顶部，this 的值是 undefined。</p>
<p>模块的魔力所在是仅<strong>导出和导入</strong>我们所需要的绑定，而不是将所有的东西都放到一个文件中。</p>
<h2 id="导出的基本语法">导出的基本语法</h2>
<p>我们可以用 <code>export</code> 关键字将一部分已发布的代码暴露给其他模块，例如：</p>
<pre><code class="language-javascript">//  导出数据
export var color = &quot;red&quot;;
export let name = &quot;Nicolas&quot;;
export const magicNumber = 7;

//  导出函数
export function sum(num1, num2) {
    return num1 + num2;
}

//  导出类
export class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
}

//  这个函数模块是私有的
function substract(num1, num2) {
    return num1 - num2;
}

//  定义一个函数
function multiply(num1, num2) {
    return num1 * num2;
}

//  再将其导出
export multiply;
</code></pre>
<p>导出的函数和类声明需要有一个名字，除非是用 <code>default</code> 关键字否则不能用这个语法导出匿名函数或类。任何未显式导出的变量、函数或类都是模块私有的，无法从模块外访问。</p>
<h2 id="导入的基本语法">导入的基本语法</h2>
<p>从模块中导出的功能可以使用 <code>import</code> 关键字在另一个模块中访问，<code>import</code> 语句的两个部分是：<strong>要导入的标识符</strong>和<strong>标识符应当从哪个模块导入</strong>。</p>
<p>语句的基本形式如下：</p>
<pre><code class="language-javascript">import { identifier1, identifier2 } from &quot;./example.js&quot;;
</code></pre>
<p><code>import</code> 后面的大括号表示从给定模块导入的绑定（binding），关键字 from 表示从哪个模块导入给定的绑定，该模块由表示模块路径的字符串指定（模块说明符）。</p>
<p>当从模块中导入一个绑定时，它就好像使用 const 定义的一样。结果是我们无法定义另一个同名变量（包括导入另一个同名绑定），也无法在 import 语句前使用标识符或改变绑定的值。</p>
<h3 id="导入单个绑定">导入单个绑定</h3>
<p>假设在一个名为 &quot;example.js&quot; 的模块中，我们可以导入并以多种方式使用这个模块中的绑定。举例来说，可以只导入一个标识符：</p>
<pre><code class="language-javascript">//  只导入一个
import { sum } from &quot;./example.js&quot;;

console.log(sum(1, 2));     //  3

sum = 1;            //  抛出错误
</code></pre>
<p>尽管 example.js 导出的函数不止一个，但是我们导入的只有 sum() 函数。如果尝试给 sum 赋新值，结果会抛出错误，因为<strong>不能给导入的绑定重新赋值</strong>。</p>
<h3 id="导入多个绑定">导入多个绑定</h3>
<p>如果要导入多个绑定，则可以明确的将他们列出：</p>
<pre><code class="language-javascript">//  导入多个
import { sum, multiply, magicNumber } from &quot;./example.js&quot;;

console.log(sum(1, magicNumber));           //  8
console.log(multiply(1, 2));            //  2
</code></pre>
<h3 id="导入整个模块">导入整个模块</h3>
<p>特殊情况下，可以导入整个模块作为一个单一的对象。然后所有的导出都可以作为对象的属性使用。例如：</p>
<pre><code class="language-javascript">//  导入一切
import * as example from &quot;./example.js&quot;;

console.log(example.sum(1, example.magicNumber));           //  8
console.log(example.multiply(1, 2));            //  2
</code></pre>
<p>需要注意的是，不管在 import 语句中把一个模块写了多少次，该模块只会执行一次。导入模块的代码执行后，实例化过的模块被保存在内存中，只要另一个 import 语句引用它就可以重复使用它。如果同一个应用程序的其他模块也从该模块中引入绑定，那么那些模块与此代码将使用相同的<strong>模块实例</strong>。</p>
<p><strong>注意</strong>：export 和 import 的一个重要限制是，它们必须在其他语句和函数之外使用。模块语法存在的一个原因是要让 JavaScript 引擎静态地确定哪些可以导出，因此，只能在顶部使用 export。而 import 语句为变量、函数和类创建的是<strong>只读</strong>绑定，而不是像正常变量一样简单地引用原始绑定。</p>
<h2 id="导出和导入时重命名">导出和导入时重命名</h2>
<p>我们可以使用 as 关键字在导出过程和导入过程中改变导出元素和导入元素的名称。</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export { sum as add };
</code></pre>
<p>在这里，函数 sum() 是本地名称，add() 是导出时使用的名称。当另一个模块要导入这个函数时，必须使用 add 这个名称：</p>
<pre><code class="language-javascript">import { add as sum } from &quot;./example.js&quot;;

console.log(typeof add);            //  &quot;undefined&quot;
console.log(sum(1, 2));         //  3
</code></pre>
<p>这段代码导入 add() 函数时使用了一个导入名称来重命名 sum() 函数。</p>
<h2 id="模块的默认值">模块的默认值</h2>
<p>模块的默认值值得是通过 <code>default</code> 关键字指定的单个变量、函数或类，只能为每个模块设置一个默认的导出值。</p>
<h3 id="导出默认值">导出默认值</h3>
<p>下面是一个使用 default 关键字的简单示例：</p>
<pre><code class="language-javascript">export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>
<p>这个模块导出了一个函数作为它的默认值，default 关键字表示这是一个默认的导出，由于函数被模块所代表，因而它不需要一个名称。</p>
<p>也可以在 export default 之后添加默认导出值的标识符，就像这样：</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export default sum;
</code></pre>
<p>为默认导出值指定标识符的第三种方法是使用重命名语法，如下所示：</p>
<pre><code class="language-javascript">function sum(num1, num2) {
    return num1 + num2;
}

export { sum as default };
</code></pre>
<p>在重命名导出时标识符 default 具有特殊含义，用来只是模块的默认值。</p>
<h3 id="导入默认值">导入默认值</h3>
<p>可以使用以下语法从一个模块中导入一个默认值：</p>
<pre><code class="language-javascript">//  导入默认值
import sum from &quot;./examole.js&quot;;

console.log(sum(1, 2));         //  3
</code></pre>
<p>对于导出默认值和一或多个非默认绑定的绑定，可以用一条语句导入所有导出的绑定，例如，假设有一下这个模块：</p>
<pre><code class="language-javascript">export let color = &quot;red&quot;;

export default function(num1, num2) {
    return num1 + num2;
}
</code></pre>
<p>可以用一下这条 import 语句导入 color 和默认函数：</p>
<pre><code class="language-javascript">import sum, { color } from &quot;./example.js&quot;;

console.log(sum(1, 2));         //  3
console.log(color);         //  &quot;red&quot;
</code></pre>
<p>用逗号将默认的本地名称与大括号包裹的非默认值分隔开，请记住，在 export 语句中，默认值必须排在非默认值之前。</p>
<p>与导出默认值相同，也可以在导入默认值时使用重命名语法：</p>
<pre><code class="language-javascript">import { default as sum, color } from &quot;./example.js&quot;;

console.log(sum(1, 2));         //  3
console.log(color);         //  &quot;red&quot;
</code></pre>
<h2 id="重新导出一个绑定">重新导出一个绑定</h2>
<p>如果需要重新导入模块中已经导入的内容，可以使用一条语句完成：</p>
<pre><code class="language-javascript">export { sum } from &quot;./example.js&quot;;
</code></pre>
<p>同样的我们也可以使用不同的名称导出：</p>
<pre><code class="language-javascript">export { sum as add } from &quot;./example.js&quot;;
</code></pre>
]]></content>
    </entry>
</feed>