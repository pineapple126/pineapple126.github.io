<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pineapple126.github.io/</id>
    <title>深海大菠萝盖饭</title>
    <updated>2020-11-18T14:29:44.635Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pineapple126.github.io/"/>
    <link rel="self" href="https://pineapple126.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://pineapple126.github.io/images/avatar.png</logo>
    <icon>https://pineapple126.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 深海大菠萝盖饭</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.12 —— 922. 按奇偶排序数组 II Easy]]></title>
        <id>https://pineapple126.github.io/post/leetcode-sort-array-by-parity-ii/</id>
        <link href="https://pineapple126.github.io/post/leetcode-sort-array-by-parity-ii/">
        </link>
        <updated>2020-11-12T09:17:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p><strong>示例</strong></p>
<pre><code>输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一两次遍历">方法一：两次遍历</h3>
<p>遍历一遍数组把所有的偶数放进 <code>even</code> 数组内，再遍历一遍数组把所有的奇数放进 <code>odd</code> 数组内。</p>
<pre><code class="language-javascript">var sortArrayByParityII = function(A) {
  const odd = A.filter(val =&gt; (val &amp; 1) === 1);
  const even = A.filter(val =&gt; (val &amp; 1) === 0);
  const ans = [];
  for (let i=0; i&lt;A.length/2; i++) {
    ans.push(even.shift(), odd.shift());
  }
  return ans;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h3 id="方法二双指针">方法二：双指针</h3>
<p>如果原数组可以修改，则可以使用就地算法求解。</p>
<p>为数组的偶数下标部分和奇数下标部分分别维护指针 i, j。随后，在每一步中，如果 A[i] 为奇数，则不断地向前移动 j（每次移动两个单位），直到遇见下一个偶数。此时，可以直接将 A[i] 与 A[j] 交换。我们不断进行这样的过程，最终能够将所有的整数放在正确的位置上。</p>
<pre><code class="language-javascript">var sortArrayByParityII = function(A) {
    const len = A.length;
    let j = 1;
    for (let i=0; i&lt;len; i+=2) {
        if (A[i] &amp; 1) {
            while (A[j] &amp; 1) {
                j += 2;
            }
            [A[i], A[j]] = [A[j], A[i]];
        }
    }
    return A;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是数组 <code>A</code> 的长度。</li>
<li>空间复杂度：O(1)。不考虑输出数组的空间占用。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.9 —— 973. 最接近原点的 K 个点]]></title>
        <id>https://pineapple126.github.io/post/leetcode-k-closest-points-to-origin/</id>
        <link href="https://pineapple126.github.io/post/leetcode-k-closest-points-to-origin/">
        </link>
        <updated>2020-11-09T15:38:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。</p>
<p>（这里，平面上两点之间的距离是欧几里德距离。）</p>
<p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p>
<p><strong>示例</strong></p>
<pre><code>输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="排序">排序</h3>
<p>将每个点到原点的欧几里得距离的平方从小到大排序后，取出前 K 个即可。</p>
<pre><code class="language-javascript">var kClosest = function(points, K) {
    const getDistance = (point) =&gt; {
        return Math.pow(point[0], 2) + Math.pow(point[1], 2);
    }
    points.sort((a, b) =&gt; {
        return getDistance(a) - getDistance(b);
    });
    return points.slice(0, K);
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 是数组 points 的长度。算法的时间复杂度即排序的时间复杂度。</li>
<li>空间复杂度：O(logn)，排序所需额外的空间复杂度为 O(logn)。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/k-closest-points-to-origin</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[「前端进阶」JS中的栈内存堆内存]]></title>
        <id>https://pineapple126.github.io/post/stack-memery-and-heap-memery-in-js/</id>
        <link href="https://pineapple126.github.io/post/stack-memery-and-heap-memery-in-js/">
        </link>
        <updated>2020-11-08T10:32:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>文章来源于掘金，作者 云中桥</p>
</blockquote>
<h2 id="引言">引言</h2>
<p>JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。</p>
<p>其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。</p>
<h2 id="栈数据结构">栈数据结构</h2>
<p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。<br>
栈被称为是一种后入先出（LIFO，last-in-first-out）的数据结构。<br>
由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。<br>
为了得到栈底的元素，必须先拿掉上面的元素。<br>
在这里，为方便理解，通过类比乒乓球盒子来分析栈的存取方式。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1604846528569.jpg" alt="stack_structure" loading="lazy"></figure>
<p>这种乒乓球的存放方式与栈中存取数据的方式如出一辙。<br>
处于盒子中最顶层的乒乓球 5，它一定是最后被放进去，但可以最先被使用。<br>
而我们想要使用底层的乒乓球 1，就必须将上面的 4 个乒乓球取出来，让乒乓球1处于盒子顶层。<br>
这就是栈空间先进后出，后进先出的特点。</p>
<h2 id="堆数据结构">堆数据结构</h2>
<p>堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，我们只需要关心书的名字。</p>
<h2 id="变量类型与内存的关系">变量类型与内存的关系</h2>
<h3 id="基本数据类型">基本数据类型</h3>
<p>基本数据类型共有 7 种：</p>
<ol>
<li>null</li>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>symbol</li>
<li>bigint</li>
</ol>
<p>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。</p>
<p>为了更好的搞懂基本数据类型变量与栈内存，我们结合以下例子与图解进行理解：</p>
<pre><code class="language-javascript">let num1 = 1;
let num2 = 1;
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1604846803112.jpg" alt="stack_example" loading="lazy"></figure>
<p>PS: 需要注意的是闭包中的基本数据类型变量不保存在栈内存中，而是保存在堆内存中。这个问题，我们后文再说。</p>
<h3 id="引用数据类型">引用数据类型</h3>
<p>Array,Function,Object...可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。</p>
<p>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<p>为了更好的搞懂变量对象与堆内存，我们结合以下例子与图解进行理解。</p>
<pre><code class="language-javascript">// 基本数据类型-栈内存
let a1 = 0;
// 基本数据类型-栈内存
let a2 = 'this is string';
// 基本数据类型-栈内存
let a3 = null;

// 对象的指针存放在栈内存中，指针指向的对象存放在堆内存中
let b = { m: 20 };
// 数组的指针存放在栈内存中，指针指向的数组存放在堆内存中
let c = [1, 2, 3];
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1604846889629.jpg" alt="heap_example" loading="lazy"></figure>
<p>因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量中获取了该对象的地址指针， 然后再从堆内存中取得我们需要的数据。</p>
<h2 id="从内存角度来看变量复制">从内存角度来看变量复制</h2>
<h3 id="基本数据类型的复制">基本数据类型的复制</h3>
<pre><code class="language-javascript">let a = 20;
let b = a;
b = 30;
console.log(a); // 此时 a 的值是多少，是 30？还是 20？
</code></pre>
<p>答案是：20</p>
<p>在这个例子中，a、b 都是基本类型，它们的值是存储在栈内存中的，a、b 分别有各自独立的栈空间， 所以修改了 b 的值以后，a 的值并不会发生变化。</p>
<p>从下图可以清晰的看到变量是如何复制并修改的。</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1604847075199.jpg" alt="basic_data_type_copy" loading="lazy"></figure>
<h3 id="引用数据类型的复制">引用数据类型的复制</h3>
<pre><code class="language-javascript">let m = { a: 10, b: 20 };
let n = m;
n.a = 15;
console.log(m.a) //此时m.a的值是多少，是10？还是15？
</code></pre>
<p>答案是：15</p>
<p>在这个例子中，m、n都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变自动分配一个新的值保存在变量中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改 n.a 的值后，相应的 m.a 也就发生了改变。</p>
<p>从下图可以清晰的看到变量是如何复制并修改的。</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1604847155965.jpg" alt="reference_data_type_copy" loading="lazy"></figure>
<h2 id="栈内存和堆内存的优缺点">栈内存和堆内存的优缺点</h2>
<p>在JS中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。</p>
<p>栈内存由于它的特点，所以它的系统效率较高。堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。</p>
<h2 id="栈内存和堆内存的垃圾回收">栈内存和堆内存的垃圾回收</h2>
<p>栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。</p>
<h2 id="闭包与堆内存">闭包与堆内存</h2>
<p>闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。</p>
<p>我们先来看什么是闭包：</p>
<pre><code class="language-javascript">function A() {
  let a = 1;
  function B() {
      console.log(a);
  }
  return B;
}
let res = A();
</code></pre>
<p>函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p>
<p>函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<pre><code>读者注释：作者此处对于闭包的定义不是很准确，闭包不应该简单地理解成
调用外部函数变量并且被外部函数返回的内部函数，闭包是一个变量对象，
储存着被 被外部函数返回的内部函数 引用着的 外部函数的变量。

以作者给出的例子来讲，内部函数 B 引用着外部函数 A 的变量 a，并且内部
函数 B 被外部函数 A 返回。那么我们称变量集合 { a } 是函数 A 的闭包。
</code></pre>
<blockquote>
<p>本文完</p>
</blockquote>
<blockquote>
<p>作者：云中桥<br>
链接：https://juejin.im/post/6844903873992196110<br>
来源：掘金</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.8 —— 122. 买卖股票的最佳时机 II]]></title>
        <id>https://pineapple126.github.io/post/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-beney-2/</id>
        <link href="https://pineapple126.github.io/post/leetcode-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-beney-2/">
        </link>
        <updated>2020-11-07T16:22:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一动态规划">方法一：动态规划</h3>
<p>考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>
<p>定义状态 <code>dp[i][0]</code> 表示第 i 天交易完后手里没有股票的最大利润，<code>dp[i][1]</code> 表示第 i 天交易完后手里持有一直股票的最大利润（i 从 0 开始）。</p>
<p>考虑 <code>dp[i][0]</code> 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 <code>dp[i-1][0]</code>，或者前一天结束的时候手里持有一支股票，即 <code>dp[i-1][1]</code>，这时候我们要将其卖出，并获得 <code>prices[i]</code> 的收益。因此为了收益最大化，我们列出如下的转移方程：</p>
<pre><code>dp[i][0] = max{dp[i-1][0], dp[i-1][1] + prices[i]}
</code></pre>
<p>再来考虑 <code>dp[i][1]</code>，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code>，或者前一天结束时还没有股票，即 <code>dp[i−1][0]</code>，这时候我们要将其买入，并减少 <code>prices[i]</code> 的收益。可以列出如下的转移方程：</p>
<pre><code>dp[i][1]=max{dp[i−1][1],dp[i−1][0]−prices[i]}
</code></pre>
<p>对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 <code>dp[0][0]=0</code>，<code>dp[0][1]=−prices[0]</code>。</p>
<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候 <code>dp[n−1][0]</code> 的收益必然是大于 <code>dp[n−1][1]</code> 的，最后的答案即为 <code>dp[n−1][0]</code>。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    const len = prices.length;
    const dp = Array(len).fill(0).map(x =&gt; Array(2).fill(0));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (let i=1; i&lt;len; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
    }
    return dp[len-1][0];
};
</code></pre>
<p><strong>空间优化</strong></p>
<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0]</code> 和 <code>dp[i−1][1]</code> 存放在两个变量中，通过它们计算出 <code>dp[i][0]</code> 和 <code>dp[i][1]</code> 并存回对应的变量，以便于第 i+1 天的状态转移即可。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    const len = prices.length;
    let dp0 = 0,
        dp1 = -prices[0];
    for (let i=1; i&lt;len; i++) {
        dp0 = Math.max(dp0, dp1 + prices[i]);
        dp1 = Math.max(dp1, dp0 - prices[i]);
    }
    return dp0;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为 O(1)，因此时间复杂度为 O(2n)=O(n)。</li>
<li>空间复杂度：O(n)。我们需要开辟 O(n) 空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至 O(1)。</li>
</ul>
<h3 id="方法二贪心">方法二：贪心</h3>
<p>虽然「不能同时参与多笔交易」，但是在每一笔交易中我们完全可以<strong>见好就收，积少成多</strong>，因此就有了一个大致的思路：我们可以<strong>在一天中既卖出又买入</strong>。只要第 i 天比第 i-1 天的价格高，就在第 i-1 天买入，并在第 i 天卖出。这样每一次的累计利润必然是最大的。</p>
<p>简而言之：<strong>上升区域，全部都算入利润当中</strong>。</p>
<pre><code class="language-javascript">var maxProfit = function(prices) {
    let profit = 0;
    for (let i=1; i&lt;prices.length; i++) {
        profit += Math.max(0, prices[i] - prices[i-1]);
    }
    return profit;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 为数组的长度。我们只需要遍历一次数组即可。</li>
<li>空间复杂度：O(1)。只需要常数空间存放若干变量。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.6 —— 1356. 根据数字二进制下 1 的数目排序 Easy]]></title>
        <id>https://pineapple126.github.io/post/leetcode-sort-integers-by-the-number-of-1-bits/</id>
        <link href="https://pineapple126.github.io/post/leetcode-sort-integers-by-the-number-of-1-bits/">
        </link>
        <updated>2020-11-06T12:36:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>
<p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<p>示例：</p>
<pre><code>输入：arr = [0,1,2,3,4,5,6,7,8]
输出：[0,1,2,4,8,3,5,6,7]
解释：[0] 是唯一一个有 0 个 1 的数。
[1,2,4,8] 都有 1 个 1 。
[3,5,6] 有 2 个 1 。
[7] 有 3 个 1 。
按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]
</code></pre>
<h2 id="题解">题解</h2>
<h3 id="方法一暴力">方法一：暴力</h3>
<p>对每个十进制的数转二进制的时候统计一下 1 的个数即可。</p>
<pre><code class="language-javascript">var sortByBits = function(arr) {
    const countBits = n =&gt; {
        let count = 0;
        while (n &gt; 0) {
            count += n &amp; 1;
            n &gt;&gt; 1;
        }
        return count;
    }
    return arr.sort((a, b) =&gt; {
        return countBits(a) - countBits(b) || a - b;
    });
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 为整数数组 arr 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为整数数组 arr 的长度。</li>
</ul>
<h3 id="解法二递推预处理">解法二：递推预处理</h3>
<p>我们定义 bit[i] 为数字 i 二进制表示下数字 1 的个数，则可以列出递推式：</p>
<pre><code>bit[i] = bit[i&gt;&gt;1] + (i&amp;1)
</code></pre>
<p>所以我们线性预处理 bitbit 数组然后去排序即可。</p>
<pre><code class="language-javascript">var sortByBits = function(arr) {
    const maxVal = arr.sort((a, b) =&gt; b - a)[0];
    const bit = Array(maxVal+1).fill(0);
    for (let i=1; i&lt;=maxVal; i++) {
        bit[i] = bit[i&gt;&gt;1] + (i&amp;1);
    }
    return arr.sort((a, b) =&gt; {
        return bit[a] - bit[b] || a - b;
    });
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(nlogn)，其中 n 为整数数组 arr 的长度。</li>
<li>空间复杂度：O(n)，其中 n 为整数数组 arr 的长度。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits">https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端模块化的十年征程]]></title>
        <id>https://pineapple126.github.io/post/modularization/</id>
        <link href="https://pineapple126.github.io/post/modularization/">
        </link>
        <updated>2020-11-03T16:30:08.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>文章来源于知乎，作者 外婆的</p>
</blockquote>
<p><strong>这是一篇关于前端模块化的文章，但这里并不讲新技术，而是谈一谈——历史</strong></p>
<blockquote>
<p>夫以铜为镜，可以正衣冠；以史为镜，可以知兴替 ——《旧唐书·魏徵传》</p>
</blockquote>
<h2 id="前言">前言</h2>
<p>也许在谈论具体的内容之前，我们需要谈论一下关键词的定义。 什么是&quot;模块&quot;？在不同的语境下模块有不同的含义。</p>
<p>但在本文中，我们从广义的角度出发，将它解释为两个方面：</p>
<ul>
<li><strong>外部的模块</strong>: 指代引入前端工程的某个外部的包(package),可能由多个JS文件组成，但会通过入口暴露给我们项目调用。</li>
<li><strong>内部的模块</strong>: 指代我们自己的工程项目中编码的最小单元： 即单个的JS文件。</li>
</ul>
<p>模块化已经发展了有十余年了，不同的工具和轮子层出不穷，但总结起来，它们解决的问题主要有三个：</p>
<ul>
<li>外部模块的管理</li>
<li>内部模块的组织</li>
<li>模块源码到目标代码的编译和转换</li>
</ul>
<h2 id="时间线">时间线</h2>
<p>下面是最各大工具或框架的诞生时间，不知不觉，模块化的发展已有十年之久了。</p>
<pre><code> 生态                       诞生时间
 Node.js                  2009 年   
 NPM                      2010 年   
 requireJS(AMD)     2010 年
 seaJS(CMD)           2011 年
 broswerify             2011 年
 webpack                2012 年
 grunt                     2012 年 
 gulp                       2013 年
 react                      2013 年 
 vue                        2014 年
 angular                 2016 年
 redux                    2015 年 
 vite                       2020 年
 snowpack             2020 年          
</code></pre>
<h2 id="外部模块的管理">外部模块的管理</h2>
<p>在模块化的过程中，首先要解决的就是<strong>外部模块的管理问题</strong>。</p>
<h3 id="nodejs-和-npm-的发布">Node.js 和 NPM 的发布</h3>
<p>时间倒回到2009年，一个叫**莱恩(Ryan Dahl)**的精神小伙创立了一个能够运行 JavaScript 的服务器环境——Node.js，并在一年之后，发布了 Node.js 自带的模块管理工具 npm，npm 的全称是node package manager，也就是 Node 包管理器。</p>
<p>Node 的出现给 JavaScript 的带来了许多改变：</p>
<p>一方面, Node 使 JavaScript 不局限于前端，同时还成为了一门后端语言。更重要的是: 经过 10 年的发展，Node.js 已经完全融入到了前端开发流程中。我们用它创建静态资源服务器，实现热重载和跨域代理等功能，同时还用它源代码中的特殊写法做编译转换处理(JSX/Sass/TypeScript)，将代码翻译成浏览器可以理解的格式(ES5/CSS)。到今天，即使我们不用Node.js独立开发程序后台，它作为开发工具的重要性也不会改变。</p>
<p>另一方面, Node.js 自带的 JS 模块管理工具 npm，从根本上改变了前端使用外部模块的方式，如果要打个比方的话，就好比从原始社会进入了现代社会。</p>
<h3 id="npm-时代以前的外部模块使用方式">NPM 时代以前的外部模块使用方式</h3>
<p>在一开始没有 npm 的时候，如果我们需要在项目里使用某个外部模块，我们可能会去官网直接把文件下载下来放到项目中，同时在入口 html 中通过 script 标签引用它。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1604595619073.jpg" alt="downloading_jquery" loading="lazy"></figure>
<p>每引用一个外部模块，我们都要重复这个过程：</p>
<ol>
<li>需要用到 jQuery，去 jQuery 官网下载 jQuery 库，导入到项目中</li>
<li>需要用到 lodash,去 lodash 官网下载 lodash 库</li>
<li>需要用到某个 BootStrap，去 BootStrap官网官网下载 BootStrap 库，导入到项目中</li>
<li>...</li>
</ol>
<p>除了这些全局的 UI 库或工具库，我们可能还会使用到很多实现细节功能的辅助模块，如果都按这种方式使用未免过于粗暴，而且给我们带来许多麻烦：</p>
<ul>
<li>使用上缺乏便利性</li>
<li>难以跟踪各个外部模块的来源</li>
<li>没有统一的版本管理机制</li>
</ul>
<p>而 npm 的出现改变了这种情况。</p>
<h3 id="npm-时代以后外部模块的使用方式">NPM 时代以后外部模块的使用方式</h3>
<p>我们上面说过，NPM 在2010年伴随着 Node.js 的新版本一起发布，是一个 Node 自带的模块管理工具。</p>
<p>从概念上看它由以下两个部分组成：</p>
<ul>
<li>NPM 是一个远程的 JavaScript 代码仓库，所有的开发者都可以向这里提交可共享的模块，并给其他开发者下载和使用</li>
<li>NPM还包含一个命令行工具，开发者通过运行 npm publish 命令把自己写的模块发布到 NPM 仓库上去，通过运行 npm install [模块名]，可以将别人的模块下载到自己项目根目录中一个叫 node_modules 的子目录下</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1604421836062.jpg" alt="npm_install" loading="lazy"></figure>
<p>每次 npm install 的时候，都会在 package.json 这个文件中更新模块和对应的版本信息。</p>
<pre><code class="language-json">// package.json
{ 
    ...
    &quot;dependencies&quot;: {
        &quot;bootstrap&quot;: &quot;^4.5.2&quot;,
        &quot;jquery&quot;: &quot;^3.5.1&quot;
    }
}
</code></pre>
<p>于是乎，包括 jQuery 等知名模块开发者的前端工程师们，都通过 npm publish 的方式把自己的模块发布到 NPM 上去了。前端开发者们真正有了一个属于自己的社区和平台，如万千漂泊游船归于港湾，而 NPM 也名声渐噪。</p>
<p>早在 2019 年 6 月，NPM 平台上的模块数量就超过了 100 万，而到写下这篇文章的时候，NPM 模块数量已超过了 140 万。</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1604422887037.jpg" alt="npm_website" loading="lazy"></figure>
<p>NPM 的出现实际上是一个必然，前端工程的复杂化要求我们必须要有这么一个集中的 JS 库管理平台。但为什么它会是 NPM 呢？这和后来 Node.js 的火热有很大关系，因为 NPM 是 Node.js 内置的包管理器，所以跟随着 Node 得到了开发者的追捧。</p>
<p>综上所述，NPM 解决了外部模块的管理问题。</p>
<h2 id="内部模块的组织">内部模块的组织</h2>
<p>在模块化的过程中，还需要解决的是内部模块的组织问题。</p>
<h3 id="模块化第一阶段原生-js-组织阶段">模块化第一阶段：原生 JS 组织阶段</h3>
<p>在最原始的时代，我们是通过下面这种方式组织我们的模块代码的，将不同的 JS 文件在 html 中一一引入。每个文件代表一个模块</p>
<pre><code class="language-html">&lt;!-- index.html --&gt;
&lt;script src=&quot;./a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./b.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./c.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./d.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>并通过模块模式去组织代码：如下所示，我们通过一个“立即调用的函数表达式”(IIFE)去组织模块</p>
<ul>
<li>将每个模块包裹在一个函数作用域里面执行，这样就可以最大程度地避免污染全局执行环境</li>
<li>通过执行匿名函数得到模块输出，可以暴露给下面的其他模块使用</li>
</ul>
<pre><code class="language-html">&lt;script&gt;
    var module1 = (function () {
    var x = 1;
    return { a: x };
  })();
&lt;/script&gt;
&lt;script&gt;
    var module2 = (function () {
    var a = module1.a;   
    return { b: a };
 })();
&lt;/script&gt;
</code></pre>
<p>但这种使用方式仍然比较粗暴</p>
<ul>
<li>随着项目扩大，html文件中会包含大量script标签。</li>
<li>script标签的先后顺序并不能很好地契合模块间的依赖关系。在复杂应用中，模块的依赖关系通常树状或网状的，如a.js依赖于b.js和c.js，b.js依赖于b1.js和b2.js。相对复杂的依赖关系难以用script标签的先后顺序组织。</li>
<li>让代码的逻辑关系难以理解，也不便于维护，容易出现某个脚本加载时依赖的变量尚未加载而导致的错误。</li>
<li>因为对script标签顺序的要求而使用同步加载，但这却容易导致加载时页面卡死的问题。</li>
<li>仍然会因为全局变量污染全局环境，导致命名冲突。</li>
</ul>
<p>我们需要针对这些问题提出解决方案，<strong>而 AMD 和 CMD 就是为解决这些问题而提出的规范</strong>。</p>
<h3 id="模块化的第二阶段在线处理阶段">模块化的第二阶段：在线处理阶段</h3>
<h4 id="模块化规范的野蛮生长">模块化规范的野蛮生长</h4>
<p>10 多年以前，前端模块化刚刚开始，正处在野蛮生长的阶段。这个过程中诞生了诸多模块化规范: AMD/CMD/CommonJS/ES6 Module。没错，前端并没有一开始就形成统一的模块化规范，而是多个规范同时多向发展。直到某一类规范占据社区主流之时，模块化规范野蛮生长的过程才宣告结束。</p>
<p>首先开始在前端流行的模块化规范是 AMD/CMD, 以及实践这两种规范的 require.js 和 Sea.js, AMD 和 CMD 可看作是&quot;<strong>在线处理</strong>&quot;模块的方案，也就是等到用户浏览 web 页面下载了对应的require.js和sea.js文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。模块组织过程在线上进行。</p>
<h4 id="amd-cmd">AMD &amp;&amp; CMD</h4>
<blockquote>
<p>AMD 和 CMD 只是一种设计规范，而不是一种实现。</p>
</blockquote>
<h4 id="amd">AMD</h4>
<p>我们先来说下 AMD，它的全称是 <code>Asynchronous Module Definition</code>，即“异步模块定义”。它是一种组织前端模块的方式。</p>
<p><strong>AMD的理念可以用如下两个API概括： define和require</strong></p>
<p><strong>define</strong> 方法用于定义一个模块，它接受两个参数：</p>
<ul>
<li>第一个参数是一个数组，表示这个模块所依赖的其他模块</li>
<li>第二个参数是一个方法，这个方法通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，同时将返回值传递给依赖它的其他模块使用。</li>
</ul>
<pre><code class="language-javascript">// module0.js
define(['Module1', 'Module2'], function (module1, module2) {
    var result1 = module1.exec();
    var result2 = module2.exec();
    return {
      result1: result1,
      result2: result2
    }
});    
</code></pre>
<p><strong>require</strong> 用于真正执行模块，通常 AMD 框架会以 require 方法作为入口，进行依赖关系分析并依次有序地进行加载。</p>
<pre><code class="language-javascript">// 入口文件
require(['math'], function (math) {
　 math.sqrt(15)
});
</code></pre>
<p><strong>define &amp;&amp; require 的区别</strong></p>
<p>可以看到 define 和 require 在依赖模块声明和接收方面是一样的，它们的区别在于 define 能自定义模块而 require 不能，require 的作用是执行模块加载。</p>
<p><strong>通过 AMD 规范组织后的 JS 文件看起来像下面这样</strong></p>
<p>depModule.js</p>
<pre><code class="language-javascript">define(function () {
  return printSth: function () {
    alert(&quot;some thing&quot;)
  }
});
</code></pre>
<p>app.js</p>
<pre><code class="language-javascript">define(['depModule'], function (mod) {
  mod.printSth();
});
</code></pre>
<p>index.html</p>
<pre><code class="language-html">&lt;!-- amd.js意为某个实现了AMD规范的库 --&gt;
&lt;script src=&quot;...amd.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  require(['app'], function (app) {
    // ...入口文件
  })
&lt;/script&gt;
</code></pre>
<p>我们可以看到，AMD 规范去除了纯粹用 script 标签顺序组织模块带来的问题：</p>
<ol>
<li>通过依赖数组的方式声明依赖关系，具体依赖加载交给具体的 AMD 框架处理</li>
<li>避免声明全局变量带来的环境污染和变量冲突问题</li>
<li>正如 AMD 其名所言(Asynchronous), 模块是异步加载的，防止 JS 加载阻塞页面渲染</li>
</ol>
<p><strong>遵循AMD规范实现的模块加载器</strong></p>
<p>我们前面说过，AMD 只是一个倡议的规范，那么它有哪些实现呢？</p>
<p>根据史料记载，AMD 的实现主要有两个: requireJS 和 curl.js, 其中 requireJS 在2010年推出，是 AMD 的主流框架。</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1604588072430.jpg" alt="requirejs" loading="lazy"></figure>
<pre><code>官网: https://requirejs.org/
</code></pre>
<h4 id="cmd">CMD</h4>
<p>CMD 是除 AMD 以外的另外一种模块组织规范。CMD 即 <code>Common Module Definition</code>，意为“通用模块定义”。</p>
<p>和 AMD 不同的是，CMD 没有提供前置的依赖数组，而是接收一个 factory 函数，这个 factory 函数包括 3 个参数：</p>
<ul>
<li><strong>require</strong>: 一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>
<li><strong>exports</strong>: 一个对象，用于对其他模块提供输出接口，例如：exports.name = &quot;xxx&quot;</li>
<li><strong>module</strong>: 一个对象，存储了当前模块相关的一些属性和方法，其中 module.exports 属性等同于上面的 exports</li>
</ul>
<p>如下所示</p>
<pre><code class="language-javascript">// CMD
define(function (requie, exports, module) {
    //依赖就近书写
    var module1 = require('Module1');
    var result1 = module1.exec();
    module.exports = {
      result1: result1,
    }
});

// AMD
define(['Module1'], function (module1) {
    var result1 = module1.exec();
    return {
      result1: result1,
    }
}); 
</code></pre>
<p><strong>CMD &amp;&amp; AMD的区别</strong></p>
<p>从上面的代码比较中我们可以得出 AMD 规范和 CMD 规范的区别：</p>
<p>一方面，在依赖的处理上</p>
<ul>
<li>AMD 推崇依赖前置，即通过依赖数组的方式提前声明当前模块的依赖</li>
<li>CMD 推崇依赖就近，在编程需要用到的时候通过调用 require 方法动态引入</li>
</ul>
<p>另一方面，在本模块的对外输出上</p>
<ul>
<li>AMD 推崇通过返回值的方式对外输出</li>
<li>CMD 推崇通过给 module.exports 赋值的方式对外输出</li>
</ul>
<p><strong>遵循CMD规范实现的模块加载器</strong></p>
<p>sea.js 是遵循 CMD 规范实现的模块加载器，又或者更准确的说法是: CMD 正是在 sea.js 推广的过程中逐步确立的规范，并不是 CMD 诞生了 sea.js。相反，是 sea.js 诞生了 CMD</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1604588468864.jpg" alt="seajs" loading="lazy"></figure>
<blockquote>
<p>CMD 和 AMD 并不是互斥的，require.js 和 sea.js 也并不是完全不同，实际上，通过阅读 API 文档我们会发现，CMD 后期规范容纳了 AMD 的一些写法。</p>
</blockquote>
<p><strong>AMD &amp;&amp; CMD背后的实现原理</strong></p>
<p>下面以 sea.js 为例</p>
<ol>
<li>解析 define 方法内的 require 调用</li>
</ol>
<p>我们之前说过, sea.js 属于 CMD, 所以它的依赖是就近获取的，</p>
<p>所以 sea.js 会多做一项工作：也就是对 define 接收方法体内 require 调用的解析。</p>
<p>先定义 parseDependencies 方法: 通过正则匹配获取字符串中的 require 中的参数并存储到数组中返回</p>
<pre><code class="language-javascript">var REQUIRE_RE = /&quot;(?:\\&quot;|[^&quot;])*&quot;|'(?:\\'|[^'])*'|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*([&quot;'])(.+?)\1\s*\)/g
var SLASH_RE = /\\\\/g

function parseDependencies(code) {
  var ret = []
  code.replace(SLASH_RE, &quot;&quot;)
      .replace(REQUIRE_RE, function(m, m1, m2) {
        if (m2) {
          ret.push(m2)
        }
      })

  return ret
}
</code></pre>
<p>然后通过 toString 将 define 接收的方法转化为字符串，然后调用 parseDependencies 解析。这样我们就获取到了一个 define 方法里面所有的依赖模块的数组</p>
<pre><code class="language-javascript">// Parse dependencies according to the module factory code
if (!isArray(deps) &amp;&amp; isFunction(factory)) {
    deps =  parseDependencies(factory.toString())
}     
</code></pre>
<ol start="2">
<li>然后 Sea.js 执行的时候，会从入口开始遍历依赖模块，并依次将它们加载到浏览器中，加载方法如下所示。</li>
</ol>
<pre><code class="language-javascript">function request(url, callback, charset, crossorigin) {
  var node = doc.createElement(&quot;script&quot;)
  addOnload(node, callback, url) // 添加回调，回调函数在 3 中
  node.async = true //异步
  node.src = url
  head.appendChild(node)
}         
</code></pre>
<p>而且在每个依赖加载完后都会通过回调的方式调用3中的onload方法</p>
<ol start="3">
<li>在 onload 方法中，sea.js 会设置一个计数变量 remain，用来计算依赖是否加载完毕。每加载完一个模块就执行 remain - 1 操作，并通过 remain === 0 判断依赖是否全部加载完毕。</li>
</ol>
<p>如果全部加载完毕就执行4中的 mod.callback 方法</p>
<pre><code class="language-javascript">Module.prototype.onload = function() {
  var mod = this
  mod.status = STATUS.LOADED 
  for (var i = 0, len = (mod._entry || []).length; i &lt; len; i++) {
    var entry = mod._entry[i]
    if (--entry.remain === 0) {
      entry.callback()
    }
  }
  delete mod._entry
}           
</code></pre>
<blockquote>
<p>大概因为 require.js 出来比较早的原因，所以没有用 Promise.all 一类的 API</p>
</blockquote>
<ol start="4">
<li>当判断 entry.remain === 0 时，也即依赖模块全部加载完毕时，会调用一开始 callback 方法，去依次执行加载完毕的依赖模块，并将输出传递给 use 方法回调</li>
</ol>
<pre><code class="language-javascript">// sea.js的use方法类似于AMD规范中的require方法,用于执行入口函数
Module.use = function (ids, callback, uri) {
  var mod = Module.get(uri, isArray(ids) ? ids : [ids])
  mod.callback = function() {
    var exports = []
    var uris = mod.resolve();
    // 依次执行加载完毕的依赖模块，并将输出传递给use方法回调
    for (var i = 0, len = uris.length; i &lt; len; i++) {
      exports[i] = cachedMods[uris[i]].exec()
   }
   // 执行use方法回调
   if (callback) {
      callback.apply(global, exports)
   }
  }
}
</code></pre>
<pre><code>参考资料： https://segmentfault.com/a/1190000016001572    
</code></pre>
<h4 id="es6-的模块化风格">ES6 的模块化风格</h4>
<p>关于 AMD/CMD 的介绍到此为止，后面的事情我们都知道了，伴随着 babel 等编译工具和 webpack 等自动化工具的出现，AMD/CMD 逐渐湮没在历史的浪潮当中，然后大家都习惯于用 CommonJS 和 ES6 的模块化方式编写代码了。</p>
<p>这一切是怎么发生的呢？ 请看</p>
<h5 id="commonjs-es6">CommonJS &amp;&amp; ES6</h5>
<p>CommonJS 是 Node.js 使用的模块化方式，而 import/export 则是 ES6 提出的模块化规范。它们的语法规则如下。</p>
<pre><code class="language-javascript"> // ES6
import { foo } from './foo'; // 输入
export const bar = 1;        // 输出

// CommonJS
const foo = require('./foo'); // 输入
module.exports = { 。         // 输出
    bar:1
}
</code></pre>
<p>实际上我们能感觉到，这种模块化方式用起来比CMD/AMD方便。</p>
<p>但在最开始的时候，我们却不能在前端页面中使用它们，因为浏览器并不能理解这种语法。</p>
<p><strong>但后来，编译工具babel的出现让这变成了可能</strong></p>
<h5 id="babel的出现和es6模块化的推广">babel的出现和ES6模块化的推广</h5>
<p>在2014年十月，babel1.7 发布。babel 是一个 JavaScript 编译器，它让我们能够使用符合开发需求的编程风格去编写代码，然后通过babel的编译转化成对浏览器兼容良好的 JavaScript。</p>
<p>Bablel 的出现改变了我们的前端开发观点。它让我们意识到：对前端项目来说，开发的代码和生产的前端代码可以是不一样的，也应该是不一样的。</p>
<ul>
<li>在开发的时候，我们追求的是编程的便捷性和可阅读性。</li>
<li>而在生产中，我们追求的是代码对各种浏览器的兼容性。</li>
</ul>
<p>babel 编译器让我们能做到这一点。在 babel 出现之前的 AMD/CMD 时代，开发和生产的代码并没有明显的区分性，开发是怎样的生产出来后也就是怎样的。</p>
<p>而 babel 则将开发和生产这两个流程分开了，同时让我们可以用 ES6 中的 import/export 进行模块化开发。</p>
<p>至此，AMD/CMD 的时代宣告结束，ES6 编程的时代到来.</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1604594624961.jpg" alt="babel" loading="lazy"></figure>
<h5 id="babel-的工作原理">Babel 的工作原理</h5>
<p>Babel 的工作流程可概括为三个阶段:</p>
<ul>
<li><strong>Parse</strong>(解析): 通过词法分析和语法分析，将源代码解析成抽象语法树(AST)</li>
<li><strong>Transform</strong>(转换)：对解析出来的抽象语法树做中间转换处理</li>
<li><strong>Generate</strong>(生成)：用经过转换后的抽象语法树生成新的代码</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1604594788324.jpg" alt="babel_principle" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1604594814444.jpg" alt="babel_principle2" loading="lazy"></figure>
<h3 id="模块化的第三阶段预处理阶段">模块化的第三阶段：预处理阶段</h3>
<p>现在时间来到了 2013 年左右，AMD/CMD 的浪潮已经逐渐退去，模块化的新阶段——预编译阶段开始了。</p>
<p>一开始的CMD/AMD方案，可看作是“<strong>在线编译</strong>”模块的方案，也就是等到用户浏览 web 页面下载了 js 文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。但这样却不可避免的带来了一些问题：</p>
<ul>
<li>在线组织模块的方式会延长前端页面的加载时间，影响用户体验。</li>
<li>加载过程中发出了海量的http请求，降低了页面性能。</li>
</ul>
<p><strong>于是开发者们想了对应的方法去解决这些问题：</strong></p>
<ul>
<li>开发一个工具，让它把组织模块的工作提前做好，在代码部署上线前就完成，从而节约页面加载时间</li>
<li>使用工具进行代码合并，把多个script的代码合并到少数几个script里，减少http请求的数量。</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1604595124513.jpg" alt="pretreatment" loading="lazy"></figure>
<p>在这样的背景下，一系列模块预处理的工具如雨后春笋般出现了。</p>
<p>典型的代表是 2011 年出现的 <strong>broswerify</strong> 和 2012 年发明的 <strong>webpack</strong>。</p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1604595379830.jpg" alt="broswerify_webpack" loading="lazy"></figure>
<p>它们一开始的定位是类似的，都是通过预先打包的方式，把前端项目里面的多个文件打包成单个文件或少数几个文件，这样的话就可以压缩首次页面访问时的http请求数量，从而提高性能。</p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1604595239383.jpg" alt="bundle" loading="lazy"></figure>
<p>当然后面的事情我们都知道了，webpack 因为发展得更好而占据了主流的前端社区，而 broswerify 则渐渐消失在红尘之中。</p>
<p><strong>broswerify</strong></p>
<p>以 broswerify 为例，我们可以通过npm安装它</p>
<pre><code>npm install -g broswerify
</code></pre>
<p>broswerify 允许我们通过 CommonJS 的规范编写代码，例如下面的入口文件 main.js</p>
<pre><code class="language-javascript">// main.js
var a = require('./a.js');
var b = require('./b.js');
...     
</code></pre>
<p>然后我们可以用 broswerify 携带的命令行工具处理 main.js，它会自动分析依赖关系并进行打包,打包后会生成集合文件 bundle.js。</p>
<pre><code>broswerify main.js -o bundle.js     
</code></pre>
<p><strong>webpack</strong></p>
<p>webpack 是自 broswerify 出现一年以后，后来居上并占据主流的打包工具。webpack 内部使用 babel 进行解析，所以 ES6 和 CommonJS 等模块化方式是可以在 webpack 中自由使用的。</p>
<p>通过安装 webpack 这一 npm 模块便可使用 webpack 工具</p>
<pre><code class="language-javascript">npm install --save-dev webpack
</code></pre>
<p>它要求我们编写一份名为 webpack.config.js 的配置文件，并以 entry 字段和 output 字段分别表示打包的入口和输出路径</p>
<pre><code class="language-javascript">// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {   
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js'
  }
};   
</code></pre>
<p>打包完毕后，我们的index.html只需要加载bundle.js就可以了。</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
    &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;   
</code></pre>
<h4 id="打包工具面临的问题-解决方案">打包工具面临的问题 &amp;&amp; 解决方案</h4>
<p>代码打包当然不是一本万利的，它们也面临着一些副作用带来的问题，其中最主要的就是打包后代码体积过大的问题</p>
<p>代码打包的初衷是减少类似 CMD 框架造成的加载脚本(http 请求)数量过多的问题，但也带来了打包后单个 script 脚本体积过大的问题：如此一来，首屏加载会消耗很长时间并拖慢速度，可谓是物极必反。</p>
<p>webpack 于是引入了代码拆分的功能(Code Splitting)来解决这个问题, 从全部打包后退一步：可以打包成多个包</p>
<blockquote>
<p>虽然允许拆多个包了，但包的总数仍然比较少，比 CMD 等方案加载的包少很多</p>
</blockquote>
<p><strong>Code Splitting有可分为两个方面的作用：</strong></p>
<ul>
<li><strong>一是实现第三方库和业务代码的分离</strong>：业务代码更新频率快，而第三方库代码更新频率是比较慢的。分离之后可利用浏览器缓存机制加载第三方库，从而加快页面访问速度</li>
<li><strong>二是实现按需加载</strong>: 例如我们经常通过前端路由分割不同页面，除了首页外的很多页面(路由)可能访问频率较低，我们可将其从首次加载的资源中去掉，而等到相应的触发时刻再去加载它们。这样就减少了首屏资源的体积，提高了页面加载速度。</li>
</ul>
<p><strong>A. 实现第三方库和业务代码的分离</strong></p>
<p>这种代码拆分可通过 webpack 独特的插件机制完成。plugins 字段是是一个数组，可接收不同的plugins 实例，从而给 webpack 打包程序附加不同的功能，CommonsChunkPlugin 就是一个实现代码拆分的插件。</p>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: 'commons',        // the commons chunk name
      filename: 'commons.js', // the filename of the commons chunk)
      minChunks: 3,           // Modules must be shared between 3 entries
    });
  ]
};          
</code></pre>
<p>通过上面的配置，webpack 在执行打包的时候会把被引用超过 3 次的依赖文件视为&quot;公共文件&quot;，并单独打包到 commons.js 中，而不是打包到主入口文件里。</p>
<p>对于 React，Redux,lodash 这些第三方库，因为引用次数远远超过 3 次，当然也是会被打包到common.js 中去的。</p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1604595944743.jpg" alt="bundle2" loading="lazy"></figure>
<p><strong>B. 实现按需加载</strong></p>
<p>正如其字面意思，按需加载就是等到需要的时候才加载一部分模块。并不选择将其代码打包到首次加载的入口bundle 中，而是等待触发的时机，届时才通过动态脚本插入的方式进行加载: 即创建 script 元素，添加脚本链接并通过 appendChild 加入到 html 元素中</p>
<p>例如我们需要实现一个功能，在点击某个按钮的时候，使用某个模块的功能。这时我们可以使用 ES6 的import 语句动态导入，webpack 会支持 import 的功能并实现按需加载</p>
<pre><code class="language-javascript">button.addEventListener('click',function(){
  import('./a.js').then(data =&gt; {
    // use data
  })
});
</code></pre>
<h3 id="模块化的第四阶段自动化构建阶段">模块化的第四阶段：自动化构建阶段</h3>
<p>正当打包工具方兴未艾的时候，另外一个发展浪潮也几乎在同步发生着。</p>
<p>它就是 —— 全方位的自动化构建工具的发展。</p>
<p>什么叫自动化构建工具呢？ 简单的说就是： 我们需要这样一个工具，专门为开发过程服务，尽可能满足我们开发的需求，提高开发的效率。</p>
<p>前面说过，在模块化的过程中，我们渐渐有了“开发流程”和“生产流程”的区分，而自动化构建工具就是在开发流程中给开发者最大的自由度和便捷性，同时在生产流程中能保证浏览器兼容性和良好性能的工具。而所有的功能已经由插件直接提供，所以被称作“自动化” 构建工具。</p>
<figure data-type="image" tabindex="13"><img src="https://pineapple126.github.io//post-images/1604596105632.jpg" alt="automation" loading="lazy"></figure>
<p>在这时，我们已经不再满足于“打包”这个功能了，我们渴望做更多的事情：</p>
<ul>
<li>开发时使用丰富且方便的 JS 新特性，如用 ES6，typescript 编程，由自动化构建工具转化成浏览器兼容的 ES5 格式的 JS 代码</li>
<li>用Sass，less 编写阅读性和扩展性良好的样式代码，由自动化构建工具转化成浏览器兼容的 CSS 代码</li>
<li>提供开发时 SourceMap 功能，也即提供生产代码(如 ES5)到源代码(typescript)的映射，方便开发调试</li>
<li>提供生产时代码压缩功能，压缩js和css，删除注释，替换变量名(长变短)，减少代码加载体积</li>
<li>提供开发热重载功能(Hot Module Reload), 也即在编辑器保存代码的时候自动刷新浏览调试页面。</li>
<li>当然也还包括基本的模块打包功能</li>
<li>其他.....</li>
</ul>
<p><strong>自动化构建工具的代表性工具有三个，分别是</strong></p>
<ul>
<li>2012年出现的 <strong>webpack</strong></li>
<li>2012年出现的 <strong>grunt</strong></li>
<li>2013年出现的 <strong>gulp</strong></li>
</ul>
<blockquote>
<p>下图中，左中右分别是gulp, grunt 和 webpack</p>
</blockquote>
<figure data-type="image" tabindex="14"><img src="https://pineapple126.github.io//post-images/1604596267079.jpg" alt="gulp_grunt_webpack" loading="lazy"></figure>
<p>这一次，webpack 并没有止步于成为一个单纯的打包工具，而是参与到自动化构建的浪潮里，并且成为了最后的赢家。而 grunt 和 gulp 则像过去的 Sea.js,Require.js 等工具一样。逐渐地从热潮中隐退，静静地待在前端社区里的一方僻静的角落里</p>
<h4 id="gulp-webpack">gulp &amp;&amp; webpack</h4>
<p>因为篇幅关系，我们下面只来介绍下 gulp 和 webpack 这两个自动化构建工具。</p>
<h5 id="gulp-和-webpack-的区别">gulp 和 webpack 的区别</h5>
<p>对于使用者来说，gulp 和 webpack 最大的区别也许在它们的使用风格上</p>
<ul>
<li>gulp 是编程式的自动化构建工具</li>
<li>webpack 是配置式的自动化构建工具<br>
下面我们以 less 代码的编译为例，展示 Gulp 和 webpack 的区别</li>
</ul>
<p><strong>Gulp</strong></p>
<p>Gulp 基本的风格是编程式的, 它是一种基于流即 Node.js 封装起来的 stream 模块的自动化构建工具，一般先通过 gulp.src 将匹配的文件转化成stream(流)的形式，然后通过一连串的 pipe 方法进行链式的加工处理处理，对后通过 dest 方法输出到指定路径。</p>
<pre><code class="language-javascript">// gulpfile.js
const { src, dest } = require('gulp');
const less = require('gulp-less');
const minifyCSS = require('gulp-csso');

function css() {
  return src('client/templates/*.less')
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(dest('build/css'))
}             
</code></pre>
<p><strong>Webpack</strong></p>
<p><strong>webpack</strong> 的基本风格则是配置式的，它通过 loader 机制实现文件的编译转化。通过配置一组 loader 数组，每个 loader 会被链式调用，处理当前文件代码后输出给下一个 loader, 全部处理完毕后进行输出</p>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/, // 正则匹配less文件
        use: [
          { loader: 'style-loader' }, // creates style nodes from JS strings
          { loader: 'css-loader' },   // translates CSS into CommonJS
          { loader: 'less-loader' },  // compiles Less to CSS
        ],
      },
    ],
  },
};       
</code></pre>
<h5 id="gulp-和-webpack-的共同点">gulp 和 webpack 的共同点</h5>
<p>gulp 和 webpack 并没有自己完成所有的功能，而是搭建起一个平台，吸引世界各地的开发者们贡献插件，并构建起来一个繁荣的生态。</p>
<p>从提供的功能上看，gulp 和 webpack 在很多方面是类似的,这从它们的相关生态上也可以看得出来</p>
<p><strong>Gulp</strong></p>
<ul>
<li>gulp-uglify : 压缩js文件</li>
<li>gulp-less : 编译less</li>
<li>gulp-sass：编译sass</li>
<li>gulp-livereload : 实时自动编译刷新</li>
<li>gulp-load-plugins：打包插件</li>
</ul>
<p><strong>Webpack</strong></p>
<ul>
<li>uglifyjs-webpack-plugin: 压缩js文件</li>
<li>less-loader: 编译less</li>
<li>sass-loader： 编译sass</li>
<li>devServer.hot配置为true: 实时自动编译刷新</li>
<li>....</li>
</ul>
<h5 id="gulp-的没落和-webpack-的兴起">Gulp 的没落和 webpack 的兴起</h5>
<p>经过了七八年的发展，webpack 逐渐取代了 gulp 成为前端开发者的主流自动化构建工具。</p>
<p><strong>究其原因</strong></p>
<ul>
<li>一方面，是因为 gulp 是编程式的，webpack 是配置式的，webpack 用起来更加简单方便，上手难度相对低一些，所以得到众多开发者的喜欢</li>
<li>另一方面，从 2014 年 React,Vue 等 SPA 应用的热潮兴起后，webpack 和它们的结合性更好，所以也助长了 webpack 生态的繁荣</li>
</ul>
<p><strong>模块化的故事，到这里就先告一段落了。</strong></p>
<h4 id="十年征程前端模块化终于从呱呱坠地到长大成人">十年征程，前端模块化终于从呱呱坠地到长大成人,</h4>
<figure data-type="image" tabindex="15"><img src="https://pineapple126.github.io//post-images/1604596780777.jpg" alt="modularization" loading="lazy"></figure>
<p><strong>自动构建工具的新趋势：bundleless</strong></p>
<p><strong>webpack 之所以在诞生之初采用集中打包方式进行开发，有几个方面的原因</strong>:</p>
<ul>
<li>一是浏览器的兼容性还不够良好，还没提供对 ES6 的足够支持(import|export)，需要把每个 JS 文件打包成单一 bundle 中的闭包的方式实现模块化</li>
<li>二是为了合并请求，减少 HTTP/1.1 下过多并发请求带来的性能问题</li>
</ul>
<p><strong>而发展到今天，过去的这些问题已经得到了很大的缓解，因为</strong></p>
<ul>
<li>主流现代浏览器已经能充分支持 ES6 了,import 和 export 随心使用</li>
<li>HTTP2.0 普及后并发请求的性能问题没有那么突出了</li>
</ul>
<p>bundleless 就是把开发中拖慢速度的打包工作给去掉，从而获得更快的开发速度。代表性工具是 vite 和 snowpack.</p>
<figure data-type="image" tabindex="16"><img src="https://pineapple126.github.io//post-images/1604596992861.jpg" alt="snowpack_vite" loading="lazy"></figure>
<ul>
<li><strong>vite</strong>: 尤雨溪开发的 bundleless 工具，能很好的配合 Vue 框架的开发，github 上 star 为 11k</li>
<li><strong>snowpack</strong>: 另一个 bundleless 工具，目前框架生态更广泛一些，支持 React/Vue/Svelte，github 上 star 为11.9k</li>
</ul>
<p>具体的内容介绍可看之前写的一篇文章，这里暂不多介绍了</p>
<blockquote>
<p>本文完。</p>
</blockquote>
<hr>
<blockquote>
<p>作者：外婆的<br>
链接：https://zhuanlan.zhihu.com/p/265632724<br>
来源：知乎</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 每日一题 2020.11.3 —— 941. 有效的山脉数组 Easy]]></title>
        <id>https://pineapple126.github.io/post/leetcode-valid-mountain-array/</id>
        <link href="https://pineapple126.github.io/post/leetcode-valid-mountain-array/">
        </link>
        <updated>2020-11-03T13:49:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2>
<p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>山脉数组的定义如下：</p>
<ul>
<li><code>A.length &gt;= 3</code></li>
<li>在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：
<ul>
<li><code>A[0] &lt; A[1] &lt; ... &lt; A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code>输入：[2, 1]
输出：false
</code></pre>
<h2 id="题解">题解</h2>
<p><strong>线性扫描</strong>：</p>
<p>我们从数组的最左侧开始向右扫描，直到找到第一个不满足 A[i] &lt; A[i+1] 的下标 i，那么 i 就是这个数组的最高点的下标。如果 i = 0 或者返回不存在这样的 i（即整个数组都是单调递增的），那么就返回 false。否则从 i 开始继续向右扫描，判断接下来的下标 j 是否都满足 A[j]&gt;A[j+1]，若都满足就返回 true，否则返回 false。</p>
<pre><code class="language-javascript">var validMountainArray = function(A) {
    const len = A.length;

    // 递增扫描
    while (i+1 &lt; len &amp;&amp; A[i] &lt; A[i+1]) {
        i++;
    }

    // 最高点不能是数组的第一个位置或最后一个位置
    if (i === 0 || i === len-1) {
        return false;
    }

    // 递减扫描
    while (i+1 &lt; len &amp;&amp; A[i] &gt; A[i+1]) {
        i++;
    }

    return i === len-1;
};
</code></pre>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是数组 A 的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<blockquote>
<p>来源：力扣（LeetCode）<br>
链接：<a href="https://leetcode-cn.com/problems/valid-mountain-array/">https://leetcode-cn.com/problems/valid-mountain-array/</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《透视 HTTP 协议》学习记录——破冰篇]]></title>
        <id>https://pineapple126.github.io/post/http-study-route-1/</id>
        <link href="https://pineapple126.github.io/post/http-study-route-1/">
        </link>
        <updated>2020-04-14T03:48:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-http-的前世今生">1. HTTP 的前世今生</h2>
<h3 id="创世纪">创世纪</h3>
<p>1989 年，任职于欧洲核子研究中心的<strong>蒂姆·伯纳斯 - 李（Tim Berners-Lee）<strong>在他的论文中提出了</strong>在互联网上构建超链接文档系统的构想</strong>。在论文中他确立了三项关键技术：</p>
<ol>
<li>URI（Uniform Resource Identifier），即统一资源标识符，作为互联网上资源的唯一身份；</li>
<li>HTML（HyperText Markup Language），即超文本标记语言，描述超文本文档；</li>
<li>HTTP（HyperText Transfer Protocol），即超文本传输协议，用来传输超文本。</li>
</ol>
<p>因此可以说，“HTTP”是在这一年诞生的。</p>
<h3 id="http09">HTTP/0.9</h3>
<p>20 世纪 90 年代初期，网络上绝大多数资源都是纯文本，很多通信协议也都使用纯文本，所以 HTTP 的设计也不可避免地受到了时代的限制。</p>
<p>这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器与客户端处理，也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都只是可读的，所以只允许使用 “GET”动作从服务器上获取 HTML 文档，并在响应之后立即关闭连接，功能有限。</p>
<p>HTTP/0.9 虽然简单，但是它作为一个“原型”，充分验证了 Web 服务的可行性。</p>
<h3 id="http10">HTTP/1.0</h3>
<p>1993 年，NCSA（美国国家超级计算应用中心）开发出了第一个可以图文混排的浏览器 Mosaic，随后又在 1995 年开发出了服务器软件 Apache，简化了 HTTP 服务器的搭建工作。同一时期，JEPG 图像格式和 MP3 音乐格式等计算机多媒体技术被发明出来，成功吸引了广大网民的热情，更多的人开始使用互联网，研究 HTTP 并提出改进意见。</p>
<p>于是在这些已有实践的基础上，经过一系列草案，HTTP/1.0 版本在 1996 年正式发布。它在多方面增强了 0.9 版，例如：</p>
<ul>
<li>增加了 HEAD、POST 等新方法；</li>
<li>增加了响应状态码，标记可能错误的原因；</li>
<li>引入了协议版本号的概念；</li>
<li>引入了 HTTP Header 的概念，让 HTTP处理请求和响应更加灵活；</li>
<li>传输的数据不再局限于文本。</li>
</ul>
<p>但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力。</p>
<p>小贴士：HTTP/1.0 的 RFC 编号是 1945，而 HTTP/0.9 则没有 RFC 。</p>
<h3 id="http11">HTTP/1.1</h3>
<p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”。这一场“战役”推动了 Web 的发展，HTTP/1.0 在这个过程中经受住了考验。于是在“浏览器大战”结束后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十年的传奇。</p>
<p>HTTP/1.1 虽然是对 HTTP/1.0 的修正，但一个重要区别是：它是一个“正式的标准”，而不是一份可有可无的“参考文档”。这意味着今后互联网上的所有浏览器、服务器、网关、代理等等，只要用到 HTTP 协议，就必须严格遵守这个标准，相当于是互联网世界的一次“立法&quot;。</p>
<p>HTTP/1.1 主要变更有：</p>
<ul>
<li>增加了 PUT、DELETE 等新的方法；</li>
<li>增加了缓存管理和控制；</li>
<li>明确了连接管理，允许持久连接；</li>
<li>允许响应数据分块（chunked），利于传输大文件；</li>
<li>强制要求 Host 头，让互联网主机托管成为可能。</li>
</ul>
<p>由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分为六分较小的文档，编号为 7230 - 7235，优化了一些细节，没有什么实质性的改动。</p>
<h3 id="http2">HTTP/2</h3>
<p>互联网标准化组织以 Google 推出的 SPDY 协议为基础制定新版本的 HTTP 协议，在 2015 年发布了 HTTP/2，RFC 编号 7540。</p>
<p>HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做出了很大的努力，主要特点有：</p>
<ul>
<li>二进制协议，不再是纯文本；</li>
<li>可发起多个请求，废弃了 1.1 里的管道；</li>
<li>使用专用算法压缩头部，减少数据传输量；</li>
<li>允许服务器主动向客户端推送数据；</li>
<li>增强了安全性，“事实上”要求通信加密。</li>
</ul>
<p>目前，HTTP/2 的普及率还比较低，大多数网站使用的仍然是 HTTP/1.1。</p>
<h3 id="http3">HTTP/3</h3>
<p>在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC。</p>
<p>2018 年，互联网标准化组织提议将 “HTTP over QUIC”更名为 “HTTP/3”并获得批准，HTTP/3 正式进入标准化制定阶段。</p>
<h2 id="2-http-是什么http-又不是什么">2. HTTP 是什么？HTTP 又不是什么？</h2>
<h3 id="http-是什么">HTTP 是什么？</h3>
<p>HTTP（HyperText Transfer Protocol），即超文本传输协议。它可以分解为三部分：<strong>超文本</strong>、<strong>传输</strong>和<strong>协议</strong>。我们从后向前逐个解析，来理解这三个词。</p>
<ol>
<li>
<p>“<strong>协议</strong>”：在现实生活中，“协议”意味着两个及以上参与者为了达成某个共同目的而对彼此的一种行为约定或规范。在这里，<strong>HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</strong></p>
</li>
<li>
<p>“<strong>传输</strong>”：HTTP 是一个“<strong>传输协议</strong>”，所谓“传输”（Transfer），就是把一堆东西从 A 点搬到 B 点，或者是从 B 点搬到 A 点，即 “A &lt;===&gt; B”。这里包含了两项重要信息：一、HTTP 协议是一个“<strong>双向协议</strong>”。二、数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 两个角色，允许中间有“中转”或“接力”。（如：A &lt;=&gt; X &lt;=&gt; Y &lt;=&gt; Z &lt;=&gt; B）因此，<strong>HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</strong></p>
</li>
<li>
<p>“<strong>超文本</strong>”：所谓“文本”，就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分杂乱无章的二进制包（datagram），而是完整的，有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。而所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p>
</li>
</ol>
<p>综上所述，我们可以给出比“超文本传输协议”这七个字更准确更具有技术含量的解释：<strong>HTTP 是一个在计算机世界里专门用来在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</strong></p>
<h3 id="http-不是什么">HTTP 不是什么？</h3>
<p>“HTTP 不是什么？”等价于询问“HTTP 不能干什么？”</p>
<p>HTTP 不是互联网，但是 HTTP 是构建互联网的一块重要拼图，而且是比重最大的一块。</p>
<p>HTTP 不是编程语言，而是计算机与计算机沟通交流的语言。</p>
<p>HTTP 也不是一个孤立的协议，HTTP 协议通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠的数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。这些协议相互交织，构成了一个协议网，而 HTTP 处于中心位置。</p>
<p>我们可以这样定义 HTTP：<strong>与 HTTP 协议相关的所有应用层技术的总和。</strong></p>
<h2 id="3-与-http-相关的各种概念">3. 与 HTTP 相关的各种概念</h2>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1586866865483.png" alt="" loading="lazy"></figure>
<p><strong>总结：</strong></p>
<ul>
<li>互联网上绝大多数资源都是用 HTTP 协议传输；</li>
<li>浏览器是 HTTP 协议里的请求方，即 User Agent;</li>
<li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li>
<li>CDN（Content Delivery Network，内容分发网络） 位于浏览器和服务器之间，主要起到缓存加速的作用；</li>
<li>爬虫（Crawler）是另一类的 User Agent，是自动访问网络资源的程序。</li>
</ul>
<h2 id="4-与-http-相关的各种协议">4. 与 HTTP 相关的各种协议</h2>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1586866943488.png" alt="" loading="lazy"></figure>
<h3 id="tcpip">TCP/IP</h3>
<p><strong>IP 协议</strong>是“<span style="color: red;">I</span>nternet <span style="color: red;">P</span>rotocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点之间传输数据包。IP 协议使用“<strong>IP 地址</strong>”的概念来定位互联网中的每一台计算机。</p>
<p>现在我们大多使用的 IP 协议是 v4 版（IPv4），总共有 2^32，大约有 42 亿个可以分配的地址。但随着互联网的飞速发展，IP 地址的分配很快就“捉襟见肘”。所以，又出现了 IPv6，有 2^128 个。</p>
<p><strong>TCP 协议</strong>是“<span style="color: red;">T</span>ransmission <span style="color: red;">C</span>ontrol <span style="color: red;">P</span>rotocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供<span style="color: red;">可靠的</span>（保证数据不丢失）、<span style="color: red;">字节流</span>（保证数据完整）形式的通信，是 HTTP 协议得以实现的基础。</p>
<p>HTTP 是一个“传输协议”，他不关心寻址、路由、数据完整性等传输细节，而 TCP/IP 协议刚好可以满足这些工作的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地成为“<strong>HTTP over TCP/IP</strong>”。</p>
<h3 id="uriurl">URI/URL</h3>
<p><strong>URI</strong>（Uniform Resource Identifier），中文名字是 <strong>统一资源标识符</strong>，使用它就能唯一地标记互联网上地资源。</p>
<p>URI 另一个常见的表现形式是 <strong>URL</strong>（Uniform Resource Location），<strong>统一资源定位符</strong>，也即我们俗称的“网址”，它是 URI 地一个子集，两者之间差异不大，不做严格划分。</p>
<p>举一个简单的例子：</p>
<pre><code>http://nginx.org/en/download.html
</code></pre>
<p>我们可以将 URI 划分为三个部分：</p>
<ol>
<li>协议名：即访问该资源应当使用的协议，在这里是“HTTP”；</li>
<li>主机名：即互联网上主机的标记，可以是域名或者 IP 地址，在这里是“ngix.org”；</li>
<li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。</li>
</ol>
<h3 id="https">HTTPS</h3>
<p>HTTPS 的全称是“<strong>HTTP over SSL/TLS</strong>”，也就是运行在 SSL/TLS 协议上的 HTTP。</p>
<p>这里的 SSL/TLS 是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是一个可靠的传输协议，可以被当作 HTTP 的下层。</p>
<p>SSL 的全称是“<strong>Secure Socket Layer</strong>”，由网景公司发明，当发展到 3.0 时被标准化，该名为 TLS，即 <strong>Transport Layer Security</strong>。SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p>
<h3 id="代理">代理</h3>
<p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，即可以转发客户端的请求，也可以转发服务器的响应。</p>
<p>代理分为很多类，常见的有：</p>
<ol>
<li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</li>
<li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界即知道代理，也知道客户端；</li>
<li>正向代理：靠近客户端，代表客户端向服务器发送请求；</li>
<li>反向代理：靠近服务器，代替服务器响应客户端的请求。</li>
</ol>
<p>CDN 实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>
<p>由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，例如：</p>
<ul>
<li>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；</li>
<li>内容缓存：暂存上下行的数据，减轻后端的压力；</li>
<li>安全防护：隐匿 IP，使用 WAF 等工具抵御网络攻击，保护被代理的机器；</li>
<li>数据处理：提供压缩，加密等额外的功能。</li>
</ul>
<h3 id="总结">总结</h3>
<ol>
<li>TCP/IP 是网络世界最常使用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</li>
<li>DNS 域名是 IP 地址的等价替代，需要用域名解析系统实现到 IP 地址的映射；</li>
<li>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</li>
<li>HTTPS 相当于“HTTP + SSL/TLS + TCP/IP”，为 HTTP 套了一个安全的外壳；</li>
<li>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</li>
</ol>
<h2 id="5-四层模型与七层模型">5. 四层模型与七层模型</h2>
<h3 id="tcpip-网络分层模型四层模型">TCP/IP 网络分层模型（四层模型）</h3>
<p>层次图如下：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1586940265489.png" alt="TCP/IP 网络分层模型" loading="lazy"></figure>
<p>第一层：<strong>链接层</strong>（Link Layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备。</p>
<p>第二层：<strong>网际层</strong>（Internet Layer），IP 协议就处于这一层。因为 IP 协议定义了 “IP 地址”的概念，所以可以在链接层的基础上，用 IP 地址代替 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络。</p>
<p>第三层：<strong>传输层</strong>（Transport Layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作地层次，另外还有它地一个小伙伴 UDP。TCP 是一个有状态的协议，需要双方先建立连接后才能发送数据，而且保证数据不丢失。而 UDP 是无状态的协议，不用事先建立连接就可以发送数据，但不保证数据一定会发送到对方。</p>
<p>第四层：<strong>应用层</strong>（Application Layer），这一层主要是各种面向具体应用的协议。如：Telnet、SSH、FTP、SMTP 以及 HTTP。</p>
<h3 id="osi-网络分层模型七层模型">OSI 网络分层模型（七层模型）</h3>
<p>OSI（Open System Interconnected Reference Model），全称是<strong>开放式系统网络互联通信参考模型</strong>，是由国际标准组织（ISO）设计出来的用来统一既存的各种网络协议的网络分层模型。</p>
<p>层次图如下：</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1586940969763.png" alt="OSI 网络分层模型" loading="lazy"></figure>
<p>OSI 模型分为了七层，部分层次和 TCP/IP 很像，从下到上分别是：</p>
<p>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等；</p>
<p>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</p>
<p>第三层：网络层，相当于 TCP/IP 的网际层；</p>
<p>第四层：传输层，相当于 TCP/IP 的传输层；</p>
<p>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</p>
<p>第六层：表示层，把数据转换为合适、可理解的语法和语义；</p>
<p>第七层：应用层，面向具体的应用传输数据。</p>
<p><strong>注意</strong>：OSI 为每一层标记了明确的编号，最底是一层，最上层是七层，而 TCP/IP 的层次只有名字而没有编号。</p>
<h3 id="两个层次模型的映射关系">两个层次模型的映射关系</h3>
<p>OSI 在设计之初就参考了 TCP/IP 等多个协议，可以比较容易在两个模型间实现对应关系：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1586941518170.png" alt="两种层次模型的映射关系" loading="lazy"></figure>
<ol>
<li>第一层：物理层，TCP/IP 里无对应；</li>
<li>第二层：数据链路层，对应 TCP/IP 的链接层；</li>
<li>第三层：网络层，对应 TCP/IP 的网际层；</li>
<li>第四层：传输层，对应 TCP/IP 的传输层；</li>
<li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP 响应代码]]></title>
        <id>https://pineapple126.github.io/post/http-status-code/</id>
        <link href="https://pineapple126.github.io/post/http-status-code/">
        </link>
        <updated>2020-04-13T06:29:38.000Z</updated>
        <content type="html"><![CDATA[<p>HTTP 响应状态代码的职责是<strong>当客户端向服务器发送请求时，描述返回的请求结果</strong>（即指示特定 HTTP 请求是否已成功完成）。借助状态码，用户可以知道服务器是正常处理了请求，还是出现了错误。</p>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1587284793494.PNG" alt="相应的状态码可描述请求的处理过程" loading="lazy"></figure>
<p><strong>响应代码的类别：</strong></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="1xx-信息响应">1XX 信息响应</h2>
<p><strong><code>100 Continue</code></strong></p>
<p>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><strong><code>101 Switching Protocol</code></strong></p>
<p>该代码是响应客户端的 <code>Upgrade</code> 标头发送的，并且指示服务器也正在切换的协议。</p>
<p><strong><code>102 Processing</code></strong></p>
<p>此代码表示服务器已收到并正在处理该请求，但没有响应可用。</p>
<p><strong><code>103 Early Hints</code></strong></p>
<p>此状态代码主要用于与 <code>Link</code> 连接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</p>
<hr>
<h2 id="2xx-成功响应">2XX 成功响应</h2>
<p>2XX 的响应结果表明请求被正常处理了。</p>
<p><strong><code>200 OK</code></strong></p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1587284933631.PNG" alt="200" loading="lazy"></figure>
<p>请求成功。默认情况下状态码为 200 的响应可以被缓存。</p>
<p>不同请求方式对于请求成功的意义如下：</p>
<ul>
<li>GET：资源已被提取并在消息正文中传输。</li>
<li>HEAD：实体标头位于消息正文中。</li>
<li>POST：描述动作结果的资源在消息体中传输。</li>
<li>TRACE：消息正文包含服务器收到的请求消息。</li>
</ul>
<p><strong><code>201 Created</code></strong></p>
<p>201 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 <code>Location</code> 首部的值。</p>
<p>该状态码的常规使用场景是作为 <code>POST</code> 请求的返回值。</p>
<p><strong><code>202 Accepted</code></strong></p>
<p>202 表示服务器端已经接收到请求消息，但是尚未进行处理。对于这个消息的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p>
<p>该状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</p>
<p><strong><code>203 Non-Authoritative Information</code></strong></p>
<p>203 表示请求已经被响应，但是获得的负载与源头服务器的状态码为 200 的响应相比，经过了拥有转换功能的 proxy （代理服务器）的修改。</p>
<p><strong><code>204 No Content</code></strong></p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1587285036464.PNG" alt="204" loading="lazy"></figure>
<p>204 是成功状态响应码，表示该请求已经成功了，但是在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么服务器显示的页面不发生更新。</p>
<p>一般在只需要从客户端向服务器发送信息，而对客户端不需要发送新消息内容的情况下使用。</p>
<p><strong><code>206 Partical Content</code></strong></p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1587285243593.PNG" alt="206" loading="lazy"></figure>
<p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中含有由 Content-Range 指定范围的实体内容。</p>
<hr>
<h2 id="3xx-重定向">3XX 重定向</h2>
<p>3XX 响应结果表示浏览器需要执行某些特殊的处理以正确处理请求。</p>
<p><strong><code>300 Multiple Choices</code></strong></p>
<p>300 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。（由于没有如何进行选择的方法，该状态码极少使用）</p>
<p>加入服务器可以提供一个优先选择，那么它应该生成一个 <code>Location</code> 首部。</p>
<p><strong><code>301 Moved Permanently</code></strong></p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1587285423555.PNG" alt="301" loading="lazy"></figure>
<p><code>301 永久重定向</code> 说明请求的资源已经被移动到了有 <code>Location</code> 头部指定的 URL 上，是固定的不会再改变。搜索引擎会根据响应修正。</p>
<p><strong><code>302 Found</code></strong></p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1587285515711.PNG" alt="302" loading="lazy"></figure>
<p><code>302 Found</code> 重定向状态码表明请求的资源被暂时的移动到了由 <code>Location</code> 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新。</p>
<p><strong><code>303 See Other</code></strong></p>
<p>HTTP <strong>303 See Other</strong> 重定向状态码，通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或者上传进度页面。</p>
<p><strong><code>304 Not Modified</code></strong></p>
<p>HTTP <strong>304 Not Modified</strong>说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法，例如 GET 或 HEAD 或在请求中附带了头部信息：<code>If-None-Match</code> 或 <code>If-Modified-Since</code>。</p>
<hr>
<h2 id="4xx-客户端响应">4XX 客户端响应</h2>
<p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<p><strong><code>400 Bad Request</code></strong></p>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1587285839787.PNG" alt="400" loading="lazy"></figure>
<p>HTTP <strong>400 Bad Request</strong> 响应状态码表示由于语法无效，服务器无法理解该请求。客户端不应该在未修改的情况下重复此请求。</p>
<p><strong><code>401 Unauthorized</code></strong></p>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1587285913524.PNG" alt="401" loading="lazy"></figure>
<p>状态码 <strong>401 Unauthorized</strong> 表示发送的请求需要有通过 HTTP 认证的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。</p>
<p>返回含有 401 的响应必须包含一个是用于被请求资源的 <code>WWW-Authenticate</code> 首部用以质询的用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p><strong><code>403 Forbidden</code></strong></p>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1587286139595.PNG" alt="403" loading="lazy"></figure>
<p>状态码 <strong>403 Forbidden</strong> 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。<strong>（权限不够）</strong></p>
<p>未获得文件系统的访问授权，访问授权出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。</p>
<p><strong><code>404 Not Found</code></strong></p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1587286253568.PNG" alt="404" loading="lazy"></figure>
<p>状态码 <strong>404 Not Found</strong> 代表客户端错误，指的是服务器端无法找到所请求的资源。404 状态码并不能说明请求的资源是临时的还是永久丢失。</p>
<hr>
<h2 id="5xx-服务器响应">5XX 服务器响应</h2>
<p>5XX 的响应结果表明服务器本身发生错误。</p>
<p><strong><code>500 Internal Server Error</code></strong></p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1587286352389.PNG" alt="500" loading="lazy"></figure>
<p><strong>500 Internal Server Error</strong> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。</p>
<p><strong><code>501 Not Implemented</code></strong></p>
<p><strong>501 Not Implemented</strong> 服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法只有 GET 和 HEAD。</p>
<p><strong><code>502 Bad Gateway</code></strong></p>
<p><strong>502 Bad Gateway</strong> 是一种 HTTP 协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</p>
<p><strong><code>503 Service Unavailable</code></strong></p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1587286644684.PNG" alt="503" loading="lazy"></figure>
<p><strong>503 Service Unavailable</strong> 是一种 HTTP 协议的服务器端错误状态码，它表示服务器尚未处于可以接受请求的状态。</p>
<p>通常造成这种情况的原因是由于服务器停机维护或者已超载。</p>
<p><strong><code>504 Gateway Timeout</code></strong></p>
<p><strong>504 Gateway Timeout</strong> 是一种 HTTP 协议的服务器端错误状态代码，表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>
<p><strong><code>505 HTTP Version Not Support</code></strong></p>
<p><strong>505 HTTP Version Not Support</strong> 是一种 HTTP 协议的服务器端错误状态码，表示服务器不支持请求所使用的 HTTP 版本。</p>
<p><strong><code>511 Network Authentication Required</code></strong></p>
<p><strong>511 Network Authentication Required</strong> 是一种 HTTP 协议的错误状态码，表示客户端需要通过验证才能使用该网络。</p>
<p>该状态码不是有源头服务器产生的，而是由控制网络访问的拦截代理服务器生成的。</p>
<hr>
<p>参考书籍及文档：</p>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">MDN web docs——HTTP 响应代码</a></li>
<li>《图解 HTTP》上野宣 —— 第 4 章 返回结果的 http 状态码</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从用户输入 URL 到页面渲染完毕，这中间发生了什么？]]></title>
        <id>https://pineapple126.github.io/post/what-happened-between-input-url-and-web-presentation/</id>
        <link href="https://pineapple126.github.io/post/what-happened-between-input-url-and-web-presentation/">
        </link>
        <updated>2020-04-07T07:23:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="从输入-url-到页面展示中间发生了什么">从输入 URL 到页面展示，中间发生了什么？</h2>
<figure data-type="image" tabindex="1"><img src="https://pineapple126.github.io//post-images/1586580599184.png" alt="从输入 URL 到页面展示完整流程示意图" loading="lazy"></figure>
<p>用户输入阶段 -&gt; 导航阶段 -&gt; 准备渲染 -&gt; 提交文档 -&gt; 渲染阶段</p>
<p><strong>用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。</strong></p>
<h2 id="1-用户输入">1. 用户输入</h2>
<p>当用户在地址栏里输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，那么地址栏会根据规则，把这段内容加上协议，合为完整的 URL。</li>
</ul>
<p>默认情况下，当用户输入关键字并键入回车之后，当前页面将会被替换为新的页面，不过浏览器提供了一个 <code>beforeunload</code> 事件，在这个流程继续之前，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开该页面，因此用户可以用通过 <code>beforeunload</code> 事件来取消导航，让浏览器不再进行任何后续工作。</p>
<h2 id="2-url-请求过程">2. URL 请求过程</h2>
<p>页面资源请求过程，浏览器进程通过 进程间通讯（IPC）把 URL 请求发送给 网络进程，网络进程接收到 URL 请求后，会发起真正的 URL 请求流程。</p>
<p>首先，网络进程会在本地缓存中检查是否缓存了请求资源。如果有缓存资源，则直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求第一步是进行 DNS 解析（将域名转换为 IP 地址），以获取请求服务器的 IP 地址。如果请求的协议是 HTTPS，那么还要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头、响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头中的数据，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重新开始。</p>
<p>注意：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p><strong><code>Context-Type</code> 是 HTTP 头中的一个非常重要的字段，它告诉浏览器服务器返回的响应体数据是什么类型。</strong>，然后浏览器会根据 <code>Context-Type</code> 字段的值来决定如何显示响应体的内容。</p>
<p>不同 <code>Context-Type</code> 的后续处理流程也截然不同。如果 <code>Context-Type</code> 字段的值被浏览器判断为<strong>下载类型</strong>，<strong>那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航栏流程就此结束</strong>。但如果是 <strong>HTML</strong>，<strong>那么浏览器则会继续进行导航流程。</strong></p>
<h2 id="3-准备渲染进程">3. 准备渲染进程</h2>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。**官方把这个默认策略叫做 process-per-site-instance。</p>
<p>总结一下：</p>
<ul>
<li>通常情况下，打开的新页面都会使用单独的渲染进程；</li>
<li>如果从 A 页面打开 B 页面，且 A 与 B 都属于<strong>同一站点</strong>的话，B 页面会复用 A 页面的渲染进程。</li>
</ul>
<h2 id="4-提交文档">4. 提交文档</h2>
<p>所谓提交文档，就是指浏览器将网络进程接收到的 HTML 数据提交给渲染进程，具体流程如下：</p>
<ul>
<li>首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；</li>
<li>渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；</li>
<li>等文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；</li>
<li>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括安全状态、地址 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>至此，一个完整的导航流程结束，紧接着是渲染阶段</p>
<h2 id="5-渲染阶段">5. 渲染阶段</h2>
<p>一旦文档被提交，渲染进程便开始页面解析和子资源加载了。一旦页面生成完毕，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<p>渲染模块在执行过程中会被划分为许多子阶段。我们把这样一个处理流程叫做<strong>渲染流水线</strong>，其大致流程如下图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://pineapple126.github.io//post-images/1586244905056.png" alt="渲染流水线示意图" loading="lazy"></figure>
<p>按照渲染的时间顺序，流水线可分为如下几个阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。在每个阶段中，我们需要注意以下三点内容:</p>
<ul>
<li>每个子阶段都有其<strong>输入内容</strong>；</li>
<li>每个子阶段都有其<strong>处理过程</strong>；</li>
<li>每个子阶段都会生成<strong>输出内容</strong>。</li>
</ul>
<h3 id="构建-dom-树">构建 DOM 树</h3>
<p><strong>由于浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。</strong></p>
<p>DOM 树的构建过程可以参考下图：</p>
<figure data-type="image" tabindex="3"><img src="https://pineapple126.github.io//post-images/1586245031193.png" alt="DOM 树构建过程示意图" loading="lazy"></figure>
<p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个简单的 HTML 文件，然后经由 HTML 解析器解析，最终输入树状结构的 DOM。</p>
<h3 id="样式计算recalculate-style">样式计算（Recalculate Style）</h3>
<p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大致可分为三个步骤：</p>
<p><strong>1. 把 CSS 转换为浏览器可以理解的结构。</strong></p>
<p>CSS 样式来源主要有三种：</p>
<ul>
<li>通过 link 引入的外部 CSS 文件</li>
<li><code>&lt;style&gt;</code> 标记内的样式</li>
<li>元素 style 属性内嵌的 CSS</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。</strong>（渲染引擎会将获取的 CSS 文本全部转换为 styleSheets 结构中的数据，并且该结构同时具备了查询和修改功能）</p>
<p><strong>2. 转换样式表中的属性值，使其标准化</strong></p>
<p>我们已经将 CSS 文本转换为浏览器可以理解的结构了，<strong>接下来我们要对其进行属性值的标准化操作</strong>。</p>
<p>那什么是标准化呢？假如我们有以下一段 CSS 文本：</p>
<pre><code class="language-css">body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
</code></pre>
<p>可以看到文本内有很多属性值，如 2em、blue、bold 等，<strong>这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎所能够理解的、标准化的计算值</strong>，这个过程就是属性值的标准化。</p>
<p>标准化后的属性值如下图所示：</p>
<figure data-type="image" tabindex="4"><img src="https://pineapple126.github.io//post-images/1586246231460.png" alt="标准化属性值" loading="lazy"></figure>
<p><strong>3. 计算出 DOM 树中每个节点的具体样式</strong></p>
<p>现在样式的属性值已经被标准化了，接下来就要计算 DOM 树中每个节点的样式属性了。而计算过程涉及到 <strong>CSS 的继承规则</strong>和<strong>层叠规则</strong>两部分。</p>
<p>首先是 CSS 的继承规则。<strong>CSS 继承就是每个 DOM 节点都包含父节点的样式。</strong></p>
<p>我们结合下面的实例，看看一张样式表如何应用到 DOM 节点上：</p>
<pre><code class="language-css">body { font-size: 20px }
p {color:blue;}
span  {display: none}
div {font-weight: bold;color:red}
div  p {color:green;}
</code></pre>
<p>这张样式表最终应用到 DOM 节点的效果如下图所示：</p>
<figure data-type="image" tabindex="5"><img src="https://pineapple126.github.io//post-images/1586246783746.png" alt="计算后 DOM 的样式" loading="lazy"></figure>
<p>从图中可以看出，所有的子节点都继承了父节点的样式。</p>
<p>样式计算的第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称是“层叠样式表”正是强调了这一点。</strong></p>
<h3 id="布局阶段">布局阶段</h3>
<p>我们现在已经拥有了 DOM 树和 DOM 树中元素的样式，接下来<strong>我们需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程称为布局。</strong></p>
<p>Chrome 在布局阶段需要完成两个步骤：创建布局树和布局计算。</p>
<p><strong>1. 创建布局树</strong></p>
<p><strong>在 DOM 树显示之前，我们还需要额外地构建一棵只包含可见元素布局树。</strong></p>
<p>我们可以结合下图来看看布局树的构造过程：</p>
<figure data-type="image" tabindex="6"><img src="https://pineapple126.github.io//post-images/1586329485462.png" alt="布局树构建流程示意图" loading="lazy"></figure>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含在布局树中。</p>
<p>为了构建布局树，浏览器大致完成了下面这些工作：</p>
<ul>
<li>遍历 DOM 树中的节点，并把这些节点加到布局树中；</li>
<li>不可见的节点暂时会被忽略掉。</li>
</ul>
<p><strong>2. 布局计算</strong></p>
<p>现在我们拥有一棵完整的布局树，我们要做的是计算布局树中节点的坐标位置。</p>
<p>在执行布局操作时，会把布局计算的结果重新写回到布局树中，所以布局树既是输入内容，也是输出内容。</p>
<h3 id="分层">分层</h3>
<p>因为页面中有很多复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（Layer Tree）。</p>
<p>通过 Chrome 的“开发者工具”中的“Layers”标签，就可以可视化页面的分层情况。</p>
<p>渲染引擎给页面分了许多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。也即**浏览器的页面实际上被分为了许多图层，这些图层叠加后合成了最终的页面。**我们可以通过下图看看图层和布局树节点之间的关系：</p>
<figure data-type="image" tabindex="7"><img src="https://pineapple126.github.io//post-images/1586331052930.png" alt="布局树和图层树关系示意图" loading="lazy"></figure>
<p>通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。**不管如何，最终每个节点都会直接或间接地从属于一个图层。</p>
<p>通常满足下面两点中任意一点的元素就可以被渲染引擎提升为单独的一个图层：</p>
<ul>
<li><strong>拥有层叠上下文属性的元素会被提升为单独的一层。</strong>（我们假定用户正面向视窗或者网页，而 HTML 元素沿着相对于用户的一条虚拟的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想）</li>
<li><strong>需要裁剪（clip）的地方也会被创建为图层。</strong>（当元素内容超出元素限定范围时，就会发生裁剪。出现裁剪时，渲染引擎会为元素内容单独创建一个图层）</li>
</ul>
<h3 id="图层绘制">图层绘制</h3>
<p>在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。</p>
<p>渲染引擎实现图层的绘制时，会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：</p>
<figure data-type="image" tabindex="8"><img src="https://pineapple126.github.io//post-images/1586506394268.png" alt="绘制列表" loading="lazy"></figure>
<p>绘制一个元素通常需要好几条绘制指令，因此在图层绘制阶段，输出的内容就是这些待绘制列表。</p>
<h3 id="栅格化raster操作">栅格化（raster）操作</h3>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程。</p>
<p>通过<strong>视口（viewport）</strong>（用户可以看到页面的部分）用户只能看到页面的很小一部分，如果要绘制出所有图层内容的话，就会产生很大的开销。</p>
<p>基于这个原因，<strong>合成线程将图层划分为图块（tile）</strong>（图块的大小通常为 256×256 或 512×512），**然后合成线程会按照视口附近的图块来优先生成位图，实际上生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**而图块是栅格化的最小单位。渲染进程维护了一个栅格化的线程池，所有图块的栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://pineapple126.github.io//post-images/1586507976232.png" alt="合成线程提交图块给栅格化线程池" loading="lazy"></figure>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫做快速栅格化，或者 GPU 栅格化，生成的位图保存在 GPU 内存中。</p>
<h3 id="合成与显示">合成与显示</h3>
<p>一旦所有的图块都被栅格化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程中有一个叫 viz 的组件，用于接收来自合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后将内存显示在屏幕上。</p>
<h3 id="渲染总结">渲染总结：</h3>
<p>完整的渲染流水线示意图：</p>
<figure data-type="image" tabindex="10"><img src="https://pineapple126.github.io//post-images/1586506955163.png" alt="" loading="lazy"></figure>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成<strong>图层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分为<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换为位图。</li>
<li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程。</li>
<li>浏览器进程根绝 DrawQuad 消息<strong>生成页面</strong>，并显示到显示器上。</li>
</ol>
<h3 id="相关概念">相关概念：</h3>
<p><strong>1. 更新了元素的几何位置（重排）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="11"><img src="https://pineapple126.github.io//post-images/1586508485468.png" alt="重排" loading="lazy"></figure>
<p>如果我们通过 JS 或者 CSS 修改元素的几何位置属性，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫做<strong>重排</strong>。<strong>重排需要更新完整的渲染流水线，所以开销也是最大的。</strong></p>
<p><strong>2. 更新了元素的绘制属性（重绘）</strong></p>
<p>参考下图：</p>
<figure data-type="image" tabindex="12"><img src="https://pineapple126.github.io//post-images/1586508688667.png" alt="重绘" loading="lazy"></figure>
<p>如果我们修改了元素的绘制属性，那么布局阶段将不会被执行，而是直接进入到绘制阶段，然后执行之后的一系列子阶段，这个过程就叫做<strong>重绘</strong>。相较于重排，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</strong></p>
<p><strong>3. 直接合成阶段</strong></p>
<p>如果我们更改一个既不要布局也不要绘制的属性，会发生什么？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程称作<strong>合成</strong>。参考下图：</p>
<figure data-type="image" tabindex="13"><img src="https://pineapple126.github.io//post-images/1586508967109.png" alt="合成" loading="lazy"></figure>
<p><strong>相对于重排和重绘，合成能大大提升绘制效率。</strong></p>
<h2 id="总结从用户输入-url到最终的页面展示到底发生了什么">总结：从用户输入 URL，到最终的页面展示到底发生了什么？</h2>
<ol>
<li>用户输入 URL 并按下回车，浏览器进程检查 URL，组装协议，构成完整的 URL</li>
<li>浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为还没有获得新页面的响应数据</li>
<li>浏览器进程通过进程间通信（IPC）把 URL 请求发送给网络进程</li>
<li>网络进程接收到 URL 请求后检查本地缓存是否含有该请求资源，如果有则直接将该资源返回给浏览器进程（状态码 200）</li>
<li>如果没有，网络进程向 Web 服务器发起 HTTP 请求（网络请求），请求流程如下:<br>
5.1 进行 DNS 解析，获取服务器的 IP 地址：如果缓存过当前域名信息，就会直接返回缓存信息；<br>
5.2 根据 IP 地址和服务器建立 TCP 连接（三次握手）；<br>
5.3 如果是 HTTPS 请求则还需要建立 TLS 连接；<br>
5.4 浏览器端构建并发送请求头信息；<br>
5.5 服务器端响应后，网络进程接收响应头和响应信息，并解析响应内容；<br>
5.6 数据传输完成后，断开 TCP 连接（四次挥手）。如果浏览器端或服务器端在 HTTP 头部加上 <code>Connection: Keep-Alive</code> 字段，TCP 连接将一直保持下去。保持 TCP 连接可以节省建立连接所需的事件，提高资源加载速度。</li>
<li>网络进程响应流程：<br>
6.1 检查状态码，如果是 301/302，则需要重定向，从响应信息中 <code>Location</code> 字段获取地址，重新发起 URL 请求；<br>
6.2 如果不是重定向，首先服务器会根据请求头中的 <code>if-None-Match</code> 字段的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以继续使用，就不用再返回数据了。<br>
6.3 其他状态码响应处理：<br>
检查响应类型 <code>Context-Type</code> 字段：如果是 字节流 类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染阶段；如果是 text/html 类型，则通知浏览器进程，准备进行渲染阶段。</li>
<li>准备渲染阶段：<br>
7.1 浏览器进程获取到来自网络进程的通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是同一个站点（根域名和协议相同就被认为同一站点）<br>
7.2 如果相同，则新页面复用页面 A 的渲染进程；如果不同，则浏览器为页面 B 创建一个新的渲染进程</li>
<li>传输数据、更新状态<br>
8.1 渲染进程准备好后，浏览器进程向渲染进程发起“提交文档”的消息，渲染进程接收到消息后，和网络进程建立数据传输的“管道”<br>
8.2 渲染进程接受完数据后，向浏览器进程发送“确认提交”的消息<br>
8.3 浏览器进程接收到“确认提交”的消息后，更新浏览器界面的状态：包括安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面，此时 Web 页面是空白页。</li>
<li>渲染进程渲染页面：<br>
9.1 构建 DOM 树<br>
9.2 样式计算（构建 CSSOM 树）<br>
9.3 页面布局（构建布局树）<br>
9.4 分层（构建图层树）<br>
9.5 图层绘制（绘制列表）<br>
9.6 分块（将图层划分为图块）<br>
9.7 栅格化（栅格化，是指将图块转换为位图）<br>
9.8 合成和显示</li>
</ol>
]]></content>
    </entry>
</feed>