<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>深海大菠萝盖饭</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://pineapple126.github.io//favicon.ico?v=1617075029577">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://pineapple126.github.io//styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://pineapple126.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://pineapple126.github.io//images/avatar.png?v=1617075029577" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">深海大菠萝盖饭</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0-array-of">1. 静态函数 Array of(..)</a></li>
<li><a href="#2-%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0-arrayfrom">2. 静态函数 Array.from(..)</a>
<ul>
<li><a href="#1-%E9%81%BF%E5%85%8D%E7%A9%BA%E6%A7%BD%E4%BD%8D">1. 避免空槽位</a></li>
<li><a href="#2-%E6%98%A0%E5%B0%84">2. 映射</a></li>
</ul>
</li>
<li><a href="#3-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-copywithin">3. 原型方法 copyWithin(..)</a></li>
<li><a href="#4-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-fill">4. 原型方法 fill(..)</a></li>
<li><a href="#5-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-find">5. 原型方法 find(..)</a></li>
<li><a href="#6-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-findindex">6. 原型方法 findIndex(..)</a></li>
<li><a href="#7-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95-entries-values-keys">7. 原型方法 entries()、values()、keys()</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://pineapple126.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">JS学习笔记--ES6新增API Array部分</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-01-02 / 9 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://pineapple126.github.io//post-images/js-notes-es6api-array.jpg" alt="">
        
        <div class="post-content yue">
          <p>这篇文章是我学习了《你不知道的JavaScript》下卷 ES6 新增API Array部分，然后摘抄与整理所学到的多种 Array 函数。</p>
<h2 id="1-静态函数-array-of">1. 静态函数 Array of(..)</h2>
<p><code>Array(..)</code> 构造器有一个众所周知的陷阱，就是如果只传入一个参数，并且这个参数是数字的话，那么不会构造一个值为这个数字的单个元素的数组，而是构造一个空数组，其length属性为这个数字。</p>
<p><code>Array.of(..)</code> 取代了 <code>Array(..)</code>成为数组的推荐函数形式构造器，因为<code>Array.of(..)</code>并没有这个特殊的单个数字参数的问题。</p>
<pre><code class="language-javascript">var a = Array( 3 );
a.length;                       // 3
a[0];                           // undefined

var b = Array.of( 3 );
b.length;                       // 1
b[0];                           // 3

var c = Array.of( 1, 2, 3 );
c.length;                       // 3
c;                              // [1,2,3]
</code></pre>
<p>在以下两种情况可能需要使用<code>Array.of(..)</code>语法创建一个数组：</p>
<p>(1)有一个回调函数需要传入的参数封装成数组，<code>Array.of(..)</code>可以完美解决这个需求。</p>
<p>(2)构建Array的子类，并且想要在子类实例中创建和初始化元素，比如：</p>
<pre><code class="language-javascript">class MyCoolArray extends Array {
    sum() {
        return this.reduce( function reducer(acc,curr){
            return acc + curr;
        }, 0 );
    }
}

var x = new MyCoolArray( 3 );
x.length;                       // 3--oops!
x.sum();                        // 0--oops!

var y = [3];                    // Array,而不是MyCoolArray
y.length;                       // 1
y.sum();                        // sum不是一个函数

var z =MyCoolArray.of( 3 );
z.length;                       // 1
z.sum();                        // 3
</code></pre>
<h2 id="2-静态函数-arrayfrom">2. 静态函数 Array.from(..)</h2>
<p>JavaScript 中的 “类（似）数组对象” 是指一个有length属性，具体说是大于等于0的整数值的对象。</p>
<p>这样的值在使用时是非常令人沮丧的，普遍的需求就是把他们转换为真正的数组，这样就可以应用各种 <code>Array.prototype</code> 方法<br>
(<code>map(..)</code>、<code>indexOf(..)</code>等)。转换过程类似于：</p>
<pre><code class="language-javascript">// 类数组对象
var arrLike = {
    length: 3,
    0: &quot;foo&quot;,
    1: &quot;bar&quot;
};

var arr = Array.prototype.slice.call( arrLike );
</code></pre>
<p>另一个常见的任务是使用slice(..)来复制产生一个真正的数组：</p>
<pre><code class="language-javascript">var arr2 = arr.slice();
</code></pre>
<p>两种情况下，新的ES6 Array.from(..)方法都是更好理解、更优雅、更简洁的替代方法：</p>
<pre><code class="language-javascript">var arr = Array.from( arrLike );

var arrCopy = Array.from( arr );
</code></pre>
<p><code>Array.from(..)</code>检查第一个参数是否为iterable，如果是的话，就使用迭代器来产生值并“复制”进入返回的数组。</p>
<p>而如果把类数组对象作为第一个参数传给<code>Array.from(..)</code>，它的行为方式和<code>slice()</code>（没有参数）或者<code>apply(..)</code>是一样的，就是简单地按照数字命名的属性从0开始直到<code>length</code>值在这些值上循环。</p>
<p>考虑：</p>
<pre><code class="language-javascript">var arrLike = {
    length: 4,
    2: &quot;foo&quot;
};

Array.from( arrLike );
// [ undefined, undefined, &quot;foo&quot;, undefined ]
</code></pre>
<p>因为位置0、1和3在<code>arrLike</code>上并不存在，所以在这些位置上是<code>undefined</code>值。</p>
<h3 id="1-避免空槽位">1. 避免空槽位</h3>
<p>使用<code>Array.from(..)</code>永远不会产生空槽位。</p>
<p>在ES6之前，如果想要产生一个初始化为某长度，在每个槽位上都是真正的<code>undefined</code>值（不是空槽位!）的数组，不得不做额外的工作：</p>
<pre><code class="language-javascript">var a = Array(4);
// 4个空槽位！

var b = Array.apply( null, {length: 4} );
// 4个undefined值
</code></pre>
<p>而现在<code>Array.from(..)</code>使其简单了很多：</p>
<pre><code class="language-javascript">var c = Array.from( { length: 4 } );
// 4个undefined值
</code></pre>
<h3 id="2-映射">2. 映射</h3>
<p><code>Array.from(..)</code>工具还有另外一个有用的技巧。如果提供了话，第二个参数是一个映射回调，这个函数会被调用，来把来自于源的每个值映射/转换到返回值。考虑：</p>
<pre><code class="language-javascript">var arrLike = {
    length: 4,
    2: &quot;foo&quot;
};

Array.from( arrLike, function mapper(val,idx){
    if(typeof val == &quot;string&quot;) {
        return val.toUpperCase();
    }
    else {
        return idx;
    }
});
// [ 0, 1, &quot;FOO&quot;, 3 ]
</code></pre>
<p><code>Array.from(..)</code>接受一个可选的第三个参数，如果设置了的话，这个参数为作为第二个参数传入的回调指定this绑定。否则 this将会是undefined。</p>
<h2 id="3-原型方法-copywithin">3. 原型方法 copyWithin(..)</h2>
<p><code>Array#copyWithin(..)</code>是一个新的修改器方法，所有数组都支持。<code>copyWithin(..)</code>从一个数组中复制一部分到同一个数组的另一个位置，覆盖这个位置所有原来的值。</p>
<p>参数是 target（要复制到的索引）、start（开始复制的源索引，包括在内）以及可选的 end（复制结束的不包含索引）。如果任何一个参数是负数，就被当做是相对于数组结束的相对值。</p>
<p>考虑：</p>
<pre><code class="language-javascript">[1,2,3,4,5].copyWithin( 3, 0 );         // [1,2,3,1,2]

[1,2,3,4,5].copyWithin( 3, 0, 1 );      // [1,2,3,1,5]

[1,2,3,4,5].copyWithin( 0, -2 );        // [4,5,3,4,5]

[1,2,3,4,5].copyWithin( 0, -2, -1 );    // [4,2,3,4,5]
</code></pre>
<p><code>copyWithin(..)</code>方法不会增加数组的长度。到达数组结尾复制就会停止。</p>
<h2 id="4-原型方法-fill">4. 原型方法 fill(..)</h2>
<p>可以通过ES6原生支持的方法<code>Array#full(..)</code>用指定值完全（或部分）填充已存在的数组：</p>
<pre><code class="language-javascript">var a = Array( 4 ).fill( undefined );
a;
// [undefined,undefined,undefined,undefined]
</code></pre>
<p><code>fill(..)</code>可选地接受参数start和end，它们指定了数组要填充的子集位置，比如：</p>
<pre><code class="language-javascript">var a = [ null, null, null, null].fill( 42, 1, 3 );

a;                                  // [null,42,42,null]
</code></pre>
<h2 id="5-原型方法-find">5. 原型方法 find(..)</h2>
<p>一般来说，在数组中搜索一个值的最常用方法一直是<code>indexOf(..)</code>方法，这个方法返回找到值的索引，如果没有找到就返回-1：</p>
<pre><code class="language-javascript">var a = [1,2,3,4,5];

(a.indexOf( 3 ) != -1);                 // true
(a.indexOf( 7 ) != -1);                 // false

(a.indexOf( &quot;2&quot; ) != -1);               // false
</code></pre>
<p>相比之下，indexOf(..)需要严格匹配===，所以搜索&quot;2&quot;不会找到值2，反之也是如此。<code>indexOf(..)</code>的匹配算法无法覆盖，而且要手动与值-1进行比较也很麻烦/笨拙。</p>
<p>从ES5以来，控制匹配逻辑的最常用变通技术是使用<code>some(..)</code>方法。它的实现是通过为每个元素调用一个函数回调，直到某次调用返回 true/真值时才会停止。你可以可定这个回调函数，因此也就有了对匹配方式的完全控制：</p>
<pre><code class="language-javascript">var a = [1,2,3,4,5];

a.some( function matcher(v){
    return v == &quot;2&quot;;
} );                            // true

a.some( function matcher(v){
    return v == 7;
} );                            // false
</code></pre>
<p>但这种方式的缺点是如果找到匹配的值的时候，只能得到匹配的 true/false 指示，而无法得到真正的匹配值本身。</p>
<p>ES6的<code>find(..)</code>解决了这个问题。基本上它和<code>some(..)</code>的工作方式一样，除了一旦回调返回 true/真值，还会返回实际的数组值：</p>
<pre><code class="language-javascript">var a = [1,2,3,4,5];

a.find( function matcher(v){
    return v == &quot;2&quot;;
} );                            // 2

a.find( function matcher(v){
    return v == 7;
} );                            // undefined
</code></pre>
<p>通过自定义<code>matcher(..)</code>函数也可以支持比较像对象这样的复杂值：</p>
<pre><code class="language-javascript">var points = [
    { x: 10, y: 20 },
    { x: 20, y: 30 },
    { x: 30, y: 40 },
    { x: 40, y: 50 },
    { x: 50, y: 50 }
];

points.find( function matcher(point){
    return (
        point.x % 3 == 0 &amp;&amp;
        point.y % 4 == 0
    );
} );                                // { x: 30, y: 40 }
</code></pre>
<p><code>find(..)</code>接受一个可选的第二个参数，如果设定这个参数就绑定到第一个参数回调的<code>this</code>。否则，<code>this</code>就是<code>undefined</code>。</p>
<h2 id="6-原型方法-findindex">6. 原型方法 findIndex(..)</h2>
<p>如果要从数组中找到匹配值的位置索引，<code>indexOf(..)</code>会提供这项功能，但是无法控制匹配逻辑，它总是使用 === 严格相等。所以ES6的<code>findIndex(..)</code>才是解决方案：</p>
<pre><code class="language-javascript">var points = [
    { x: 10, y: 20 },
    { x: 20, y: 30 },
    { x: 30, y: 40 },
    { x: 40, y: 50 },
    { x: 50, y: 50 }
];

points.findIndex( function matcher(point){
    return (
        point.x % 3 == 0 &amp;&amp;
        point.y % 4 == 0
    );
} );                                // 2

points.findIndex( function matcher(point){
    return (
        point.x % 6 == 0 &amp;&amp;
        point.y % 7 == 0
    );
} );                                // -1
</code></pre>
<p>就像其他接受回调的数组方法一样，<code>findIndex(..)</code>方法接受一个可选的第二个参数，如果设定这个参数就绑定到第一个参数回调的<code>this</code>。否则，<code>this</code>就是<code>undefined</code>。</p>
<h2 id="7-原型方法-entries-values-keys">7. 原型方法 entries()、values()、keys()</h2>
<p>因为<code>Array</code>对于ES6来说已经不是新的了，所以从传统角度来说，它可能不会被看作是“集合”，但是它提供了同样的迭代器方法<code>entries(..)</code>、<code>values(..)</code>和<code>keys(..)</code>,从这个意义上说，它是一个集合。考虑：</p>
<pre><code class="language-javascript">var a = [1,2,3];

[...a.values()];                    // [1,2,3]
[...a.keys()];                      // [0,1,2]
[...a.entries()];                   // [ [0,1], [1,2], [2,3] ]

[...a.[Symbol.iterator]()];         // [1,2,3]
</code></pre>
<p>就像<code>Set</code>一样，默认的<code>Array</code>迭代器和<code>values()</code>返回的值一样。</p>
<p><strong>完</strong></p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://pineapple126.github.io/tag/DEJyveMLT/">
            <span class="flex-auto">JavaScript</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://pineapple126.github.io/tag/MWXepM6P0E/">
            <span class="flex-auto">你不知道的JS学习笔记</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://pineapple126.github.io/post/js-notes-es6api-object/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  JS学习笔记--ES6新增API Object部分
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://pineapple126.github.io/post/hello-gridea/">
                <h3 class="post-title">
                  Hello Gridea
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '6629aced96004c0f2422',
    clientSecret: '52e96f46e58f554ec81bcb7c020ee4c6669abded',
    repo: 'pineapple126.github.io',
    owner: 'pineapple126',
    admin: ['pineapple126'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://pineapple126.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
