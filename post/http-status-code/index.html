<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>深海大菠萝盖饭</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://pineapple126.github.io//favicon.ico?v=1586836967667">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://pineapple126.github.io//styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://pineapple126.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://pineapple126.github.io//images/avatar.png?v=1586836967667" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">深海大菠萝盖饭</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BF%A1%E6%81%AF%E5%93%8D%E5%BA%94">信息响应</a></li>
<li><a href="#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94">成功响应</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%93%8D%E5%BA%94">客户端响应</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94">服务器响应</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://pineapple126.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">HTTP 响应代码</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-13 / 7 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="/post-images/http-status-code.jpg" alt="">
        
        <div class="post-content yue">
          <p>HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。响应分为五类：信息响应（100-199），成功响应（200-299），重定向（300-399），客户端错误（400-499）和服务器错误（500-599）。</p>
<hr>
<h2 id="信息响应">信息响应</h2>
<p><strong><code>100 Continue</code></strong></p>
<p>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><strong><code>101 Switching Protocol</code></strong></p>
<p>该代码是响应客户端的 <code>Upgrade</code> 标头发送的，并且指示服务器也正在切换的协议。</p>
<p><strong><code>102 Processing</code></strong></p>
<p>此代码表示服务器已收到并正在处理该请求，但没有响应可用。</p>
<p><strong><code>103 Early Hints</code></strong></p>
<p>此状态代码主要用于与 <code>Link</code> 连接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</p>
<hr>
<h2 id="成功响应">成功响应</h2>
<p><strong><code>200 OK</code></strong></p>
<p>请求成功。默认情况下状态码为 200 的响应可以被缓存。</p>
<p>不同请求方式对于请求成功的意义如下：</p>
<ul>
<li>GET：资源已被提取并在消息正文中传输。</li>
<li>HEAD：实体标头位于消息正文中。</li>
<li>POST：描述动作结果的资源在消息体中传输。</li>
<li>TRACE：消息正文包含服务器收到的请求消息。</li>
</ul>
<p><strong><code>201 Created</code></strong></p>
<p>201 是一个代表成功的应答状态码，表示请求已经被成功处理，并且创建了新的资源。新的资源在应答之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 <code>Location</code> 首部的值。</p>
<p>该状态码的常规使用场景是作为 <code>POST</code> 请求的返回值。</p>
<p><strong><code>202 Accepted</code></strong></p>
<p>202 表示服务器端已经接收到请求消息，但是尚未进行处理。对于这个消息的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。</p>
<p>该状态码被设计用来将请求交由另外一个进程或者服务器来进行处理，或者是对请求进行批处理的情形。</p>
<p><strong><code>203 Non-Authoritative Information</code></strong></p>
<p>203 表示请求已经被响应，但是获得的负载与源头服务器的状态码为 200 的响应相比，经过了拥有转换功能的 proxy （代理服务器）的修改。</p>
<p><strong><code>204 No Content</code></strong></p>
<p>204 是成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。</p>
<p>使用惯例是，在 PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 <code>204 No Content</code>。如果创建了资源，则返回 <code>201 Created</code>。如果应将页面更改为新更新的页面，则应改用 <code>200 OK</code>。</p>
<hr>
<h2 id="重定向">重定向</h2>
<p><strong><code>300 Multiple Choices</code></strong></p>
<p>300 是一个用来表示重定向的响应状态码，表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。（由于没有如何进行选择的方法，该状态码极少使用）</p>
<p>加入服务器可以提供一个优先选择，那么它应该生成一个 <code>Location</code> 首部。</p>
<p><strong><code>301 Moved Permanently</code></strong></p>
<p><code>301 永久重定向</code> 说明请求的资源已经被移动到了有 <code>Location</code> 头部指定的 URL 上，是固定的不会再改变。搜索引擎会根据响应修正。</p>
<p><strong><code>302 Found</code></strong></p>
<p><code>302 Found</code> 重定向状态码表明请求的资源被暂时的移动到了由 <code>Location</code> 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新。</p>
<p><strong><code>303 See Other</code></strong></p>
<p>HTTP <strong>303 See Other</strong> 重定向状态码，通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或者上传进度页面。</p>
<p><strong><code>304 Not Modified</code></strong></p>
<p>HTTP <strong>304 Not Modified</strong>说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法，例如 GET 或 HEAD 或在请求中附带了头部信息：<code>If-None-Match</code> 或 <code>If-Modified-Since</code>。</p>
<hr>
<h2 id="客户端响应">客户端响应</h2>
<p><strong><code>400 Bad Request</code></strong></p>
<p>HTTP <strong>400 Bad Request</strong> 响应状态码表示由于语法无效，服务器无法理解该请求。客户端不应该在未修改的情况下重复此请求。</p>
<p><strong><code>401 Unauthorized</code></strong></p>
<p>状态码 <strong>401 Unauthorized</strong> 代表客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。</p>
<p>该状态码会与 <code>WWW-Authenticate</code> 首部一起发送，其中包含有如何进行验证的信息。</p>
<p><strong><code>403 Forbidden</code></strong></p>
<p>状态码 <strong>403 Forbidden</strong> 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。<strong>（权限不够）</strong></p>
<p><strong><code>404 Not Found</code></strong></p>
<p>状态码 <strong>404 Not Found</strong> 代表客户端错误，指的是服务器端无法找到所请求的资源。404 状态码并不能说明请求的资源是临时的还是永久丢失。</p>
<hr>
<h2 id="服务器响应">服务器响应</h2>
<p><strong><code>500 Internal Server Error</code></strong></p>
<p><strong>500 Internal Server Error</strong> 是表示服务器端错误的响应状态码，意味着所请求的服务器遇到意外的情况并阻止其执行请求。</p>
<p><strong><code>501 Not Implemented</code></strong></p>
<p><strong>501 Not Implemented</strong> 服务器错误响应码表示请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法只有 GET 和 HEAD。</p>
<p><strong><code>502 Bad Gateway</code></strong></p>
<p><strong>502 Bad Gateway</strong> 是一种 HTTP 协议的服务器端错误状态代码，它表示作为网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</p>
<p><strong><code>503 Service Unavailable</code></strong></p>
<p><strong>503 Service Unavailable</strong> 是一种 HTTP 协议的服务器端错误状态码，它表示服务器尚未处于可以接受请求的状态。</p>
<p>通常造成这种情况的原因是由于服务器停机维护或者已超载。</p>
<p><strong><code>504 Gateway Timeout</code></strong></p>
<p><strong>504 Gateway Timeout</strong> 是一种 HTTP 协议的服务器端错误状态代码，表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。</p>
<p><strong><code>505 HTTP Version Not Support</code></strong></p>
<p><strong>505 HTTP Version Not Support</strong> 是一种 HTTP 协议的服务器端错误状态码，表示服务器不支持请求所使用的 HTTP 版本。</p>
<p><strong><code>511 Network Authentication Required</code></strong></p>
<p><strong>511 Network Authentication Required</strong> 是一种 HTTP 协议的错误状态码，表示客户端需要通过验证才能使用该网络。</p>
<p>该状态码不是有源头服务器产生的，而是由控制网络访问的拦截代理服务器生成的。</p>
<hr>
<p>参考文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">MDN web docs——HTTP 响应代码</a></p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://pineapple126.github.io/tag/R4M6rfyHA/">
            <span class="flex-auto">浏览器与 TCP/IP 协议族</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://pineapple126.github.io/post/what-happened-between-input-url-and-web-presentation/">
                <h3 class="post-title">
                  从用户输入 URL 到页面渲染完毕，这中间发生了什么？
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://pineapple126.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
